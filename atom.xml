<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2021-04-29T08:18:46.783Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>5.线程的生命周期和常用方法</title>
    <link href="https://leslieaibin.github.io/2021/04/29/Java/Thread/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://leslieaibin.github.io/2021/04/29/Java/Thread/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-29T02:15:42.000Z</published>
    <updated>2021-04-29T08:18:46.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 <strong>新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态</strong>。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是 <strong>线程状态也会多次在运行、阻塞之间切换</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,                <span class="comment">// 新创建的线程，未调用 start() 方法</span></span><br><span class="line">    RUNNABLE,           <span class="comment">// 线程正在运行中：可能是在 JVM 中运行，也可能在等待 CPU 时间片</span></span><br><span class="line">    BLOCKED,            <span class="comment">// 阻塞状态： 正等待锁的释放以进入同步区</span></span><br><span class="line">    WAITING,            <span class="comment">// 等待状态： 需要被其他线程唤醒才能重新进入 RUNNABLE 状态</span></span><br><span class="line">    TIMED_WAITING,      <span class="comment">// 超时等待状态： 等待一个具体的时间段，到期会被自动唤醒</span></span><br><span class="line">    TERMINATED;         <span class="comment">// 线程执行结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/bVbClUm" alt="线程状态转换图"></p><p>其流程：</p><ul><li>调用<code>new</code>方法新建一个线程，这时线程处于<code>新建状态</code></li><li>调用<code>start</code> 方法启动一个线程， 这时线程处于<code>就绪状态</code></li><li>处于就绪状态的线程等待线程获取CPU资源，在等待其获取CPU资源后线程会执行<code>run</code>方法进入<code>运行状态</code></li><li>正在运行的线程在调用了<code>yield</code>方法或失去处理器资源时，会再次进入<code>就绪状态</code></li><li>正在执行的线程在执行了<code>sleep</code>方法、I/O阻塞、等待同步锁、等待通知、调用suspend方法等操作后，会挂起并进入<code>阻塞状态</code>，进入<code>Blocked池</code>。</li><li><code>阻塞状态</code>的线程由于出现<code>sleep时间已到</code>、I/O方法返回、获得同步锁、收到通知、调用resume方法等情况，会再次进入<code>就绪状态</code>，等待CPU时间片的轮询。该线程在获取CPU资源后，会再次进入<code>运行状态</code>。</li><li>处于<code>运行状态</code>的线程，在调用<code>run方法或call方法</code>正常执行完成、调用stop方法停止线程或者程序执行错误导致异常退出时，会进入<code>死亡状态</code>。</li></ul><h2 id="新建状态：New"><a href="#新建状态：New" class="headerlink" title="新建状态：New"></a>新建状态：New</h2><p>在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是为线程分配内存并初始化其成员变量的值。</p><ul><li><p><strong>此时JVM为其分配内存，并初始化其成员变量的值</strong>；</p></li><li><p><strong>此时线程对象没有表现出任何线程的动态特征</strong>，程序也不会执行线程的线程执行体；</p></li></ul><h2 id="就绪（Runnable）状态"><a href="#就绪（Runnable）状态" class="headerlink" title="就绪（Runnable）状态"></a>就绪（Runnable）状态</h2><p>当线程对象调用了start()方法之后，该线程处于 <strong>就绪状态</strong>。此时的线程情况如下：</p><ul><li><p>此时JVM会为其 <strong>创建方法调用栈和程序计数器</strong>；</p></li><li><p>该状态的线程一直处于 <strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，<strong>把它称为可运行池而不是可运行队列</strong>。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；</p></li><li><p>此时线程 <strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</p></li></ul><p><strong>调用start()方法与run()方法，对比如下：</strong></p><ul><li><p><strong>调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理</strong>。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，<strong>系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体</strong>；</p></li><li><p>需要指出的是，调用了线程的run()方法之后，<strong>该线程已经不再处于新建状态</strong>，不要再次调用线程对象的start()方法。<strong>只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常</strong>；</p></li></ul><h2 id="运行（Running）状态"><a href="#运行（Running）状态" class="headerlink" title="运行（Running）状态"></a>运行（Running）状态</h2><p>当CPU开始调度处于 <strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 <strong>运行状态</strong>。</p><ul><li>如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；</li><li>如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；</li><li>当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</li></ul><p>处于运行状态的线程最为复杂，它 <strong>不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）</strong>，线程在运行过程中需要被中断，<strong>目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略</strong>。线程状态可能会变为 <strong>阻塞状态、就绪状态和死亡状态</strong>。比如：</p><ul><li><p>对于采用 <strong>抢占式策略</strong> 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 <strong>从运行状态变为就绪状态</strong>，重新等待系统分配资源；</p></li><li><p>对于采用 <strong>协作式策略</strong>的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—<strong>也就是必须由该线程主动放弃所占用的资源</strong>，线程就会又 <strong>从运行状态变为就绪状态</strong>。</p></li></ul><h2 id="阻塞（Blocked）状态"><a href="#阻塞（Blocked）状态" class="headerlink" title="阻塞（Blocked）状态"></a>阻塞（Blocked）状态</h2><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 <strong>阻塞状态</strong>。</p><p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p><ul><li><strong>线程调用sleep()方法</strong>，主动放弃所占用的处理器资源，暂时进入中断状态（<strong>不会释放持有的对象锁</strong>），时间到后等待系统分配CPU继续执行；</li><li><strong>线程调用一个阻塞式IO方法</strong>，在该方法返回之前，该线程被阻塞；</li><li><strong>线程试图获得一个同步监视器</strong>，但该同步监视器正被其他线程所持有;</li><li><strong>程序调用了线程的suspend方法将线程挂起</strong>；</li><li><strong>线程调用wait</strong>，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</li></ul><p><strong>阻塞状态分类：</strong></p><ul><li><strong>等待阻塞</strong>：运行状态中的 <strong>线程执行wait()方法</strong>，使本线程进入到等待阻塞状态；</li><li><strong>同步阻塞</strong>：线程在 <strong>获取synchronized同步锁失败</strong>（因为锁被其它线程占用），它会进入到同步阻塞状态；</li><li><strong>其他阻塞</strong>：通过调用线程的 <strong>sleep()或join()或发出I/O请求</strong> 时，线程会进入到阻塞状态。当 <strong>sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕</strong> 时，线程重新转入就绪状态；</li></ul><p><strong>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态</strong>。而就绪和运行状态之间的转换通常不受程序控制，<strong>而是由系统线程调度所决定</strong>。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；<strong>当处于运行状态的线程失去处理器资源时，该线程进入就绪状态</strong>。</p><p>但有一个方法例外，<strong>调用yield()方法可以让运行状态的线程转入就绪状态</strong>。</p><h3 id="等待（WAITING）状态"><a href="#等待（WAITING）状态" class="headerlink" title="等待（WAITING）状态"></a>等待（WAITING）状态</h3><p>线程处于 <strong>无限制等待状态</strong>，等待一个特殊的事件来重新唤醒，如：</p><ul><li>通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；</li><li>通过join()方法进行等待的线程等待目标线程运行结束而唤醒；</li></ul><p>以上两种一旦通过相关事件唤醒线程，线程就进入了 <strong>就绪（RUNNABLE）状态</strong> 继续运行。</p><h3 id="时限等待（TIMED-WAITING）状态"><a href="#时限等待（TIMED-WAITING）状态" class="headerlink" title="时限等待（TIMED_WAITING）状态"></a>时限等待（TIMED_WAITING）状态</h3><p>线程进入了一个 <strong>时限等待状态</strong>，如：</p><ul><li><strong>sleep(3000)**，等待3秒后线程重新进行 **就绪（RUNNABLE）状态</strong> 继续运行。</li></ul><h2 id="死亡（Dead）状态"><a href="#死亡（Dead）状态" class="headerlink" title="死亡（Dead）状态"></a>死亡（Dead）状态</h2><p>线程会以如下3种方式结束，结束后就处于 <strong>死亡状态</strong>：</p><ul><li><p><strong>run()或call()方法执行完成</strong>，线程正常结束；</p></li><li><p><strong>线程抛出一个未捕获的Exception或Error</strong>；</p></li><li><p><strong>直接调用该线程stop()方法来结束该线程</strong>—该方法容易导致死锁，通常不推荐使用；</p></li></ul><p><strong>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程</strong>。线程一旦死亡，就不能复生。 <strong>如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常</strong>。</p><p><strong>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态</strong>。</p><h3 id="终止（TERMINATED）状态"><a href="#终止（TERMINATED）状态" class="headerlink" title="终止（TERMINATED）状态"></a>终止（TERMINATED）状态</h3><p>线程执行完毕后，进入终止（TERMINATED）状态。</p><h1 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程的启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 线程体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 已废弃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 已废弃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 已废弃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 在指定的毫秒数内让当前正在执行的线程休眠</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span></span>; </span><br><span class="line">    <span class="comment">// 同上，增加了纳秒参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span>; </span><br><span class="line">    <span class="comment">// 测试线程是否处于活动状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 中断线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 测试线程是否已经中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 测试当前线程是否已经中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 等待该线程终止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">    <span class="comment">// 等待该线程终止的时间最长为 millis 毫秒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">    <span class="comment">// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16417a1fd6acc8f4" alt="线程方法状态转换"></p><h2 id="线程就绪、运行和死亡状态转换"><a href="#线程就绪、运行和死亡状态转换" class="headerlink" title="线程就绪、运行和死亡状态转换"></a>线程就绪、运行和死亡状态转换</h2><ol><li><strong>就绪状态转换为运行状态</strong>：此线程得到CPU资源；</li><li><strong>运行状态转换为就绪状态</strong>：此线程主动调用yield()方法或在运行过程中失去CPU资源。</li><li><strong>运行状态转换为死亡状态</strong>：此线程执行执行完毕或者发生了异常；</li></ol><h2 id="sleep-amp-yield"><a href="#sleep-amp-yield" class="headerlink" title="sleep &amp; yield"></a>sleep &amp; yield</h2><p><strong>sleep()**：通过sleep(millis)使线程进入休眠一段时间，</strong>该方法在指定的时间内无法被唤醒，同时也不会释放对象锁**；</p><p><strong>注意如下几点问题：</strong></p><ul><li><p><strong>sleep是静态方法，最好不要用Thread的实例对象调用它</strong>，<strong>因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象</strong>，<strong>它只对正在运行状态的线程对象有效</strong>。看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread&#x3D;new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        &#x2F;&#x2F; 这里sleep的就是main线程，而非myThread线程 </span><br><span class="line">        myThread.sleep(1000); </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><ul><li>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。<strong>因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它</strong>，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</li></ul><p><strong>yield()**：与sleep类似，</strong>也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程<strong>。但是和sleep()方法不同的是，</strong>它不会进入到阻塞状态，而是进入到就绪状态<strong>。yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：</strong>当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行**。</p><ul><li>实际上，<strong>当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会</strong>，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。</li></ul><p><strong>关于sleep()方法和yield()方法的区别如下</strong>：</p><ul><li><p>sleep方法暂停当前线程后，<strong>会进入阻塞状态</strong>，只有当睡眠时间到了，<strong>才会转入就绪状态</strong>。而yield方法调用后 ，<strong>是直接进入就绪状态</strong>，所以有可能刚进入就绪状态，又被调度到运行状态；</p></li><li><p><strong>sleep方法声明抛出了InterruptedException</strong>，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。<strong>而yield方法则没有声明抛出任务异常</strong>；</p></li><li><p>sleep方法比yield方法有更好的可移植性，<strong>通常不要依靠yield方法来控制并发线程的执行</strong>；</p></li></ul><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>线程的合并的含义就是 <strong>将几个并行线程的线程合并为一个单线程执行</strong>，应用场景是 <strong>当一个线程必须等待另一个线程执行完毕才能执行时</strong>，Thread类提供了join方法来完成这个功能，<strong>注意，它不是静态方法</strong>。</p><p><strong>join有3个重载的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">   <span class="comment">// 当前线程等该加入该线程后面，等待该线程终止。    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>    </span></span><br><span class="line"><span class="function">   <span class="comment">// 当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span>    </span></span><br><span class="line"><span class="function">   <span class="comment">// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状</span></span></span><br></pre></td></tr></table></figure><h2 id="suspend-amp-resume-已过时"><a href="#suspend-amp-resume-已过时" class="headerlink" title="suspend &amp; resume (已过时)"></a>suspend &amp; resume (已过时)</h2><p>suspend-<strong>线程进入阻塞状态，但不会释放锁</strong>。此方法已不推荐使用，<strong>因为同步时不会释放锁，会造成死锁的问题</strong>。</p><p>resume-<strong>使线程重新进入可执行状态</strong>。</p><p>为什么 Thread.suspend 和 Thread.resume 被废弃了？</p><p>Thread.suspend 天生容易引起死锁。<strong>如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了</strong>。这种死锁一般自身表现为“冻结（ frozen ）”进程。</p><h2 id="stop（已过时）"><a href="#stop（已过时）" class="headerlink" title="stop（已过时）"></a>stop（已过时）</h2><p><strong>不推荐使用，且以后可能去除，因为它不安全</strong>。为什么 Thread.stop 被废弃了？</p><p>因为其天生是不安全的。<strong>停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）</strong>。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。<strong>这种对象被称为受损的 （damaged）</strong>。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。</p><p><strong>不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程</strong>。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。</p><h2 id="wait-amp-notify-notifyAll"><a href="#wait-amp-notify-notifyAll" class="headerlink" title="wait &amp; notify/notifyAll"></a>wait &amp; notify/notifyAll</h2><p>wait &amp; notify/notifyAll这三个都是Object类的方法。使用 wait ，notify 和 notifyAll <strong>前提是先获得调用对象的锁</strong>。</p><p>调用 wait 方法后，释放持有的对象锁，<strong>线程状态有 Running 变为 Waiting</strong>，并将当前线程放置到对象的 <strong>等待队列</strong>；</p><p>调用notify 或者 notifyAll 方法后，<strong>等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回</strong>；</p><p>notify 方法：<strong>将等待队列的一个等待线程从等待队列种移到同步队列中</strong> ，而 notifyAll 方法：<strong>将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked</strong>。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每个线程执行时都有一个优先级的属性，<strong>优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会</strong>。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，<strong>优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行</strong>。</p><p><strong>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级</strong>；</p><p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   =<span class="number">10</span></span><br><span class="line">MIN_PRIORITY   =<span class="number">1</span></span><br><span class="line">NORM_PRIORITY   =<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程与普通线程写法上基本没啥区别，**调用线程对象的方法setDaemon(true)**，则可以将其设置为守护线程。</p><p>守护线程使用的情况较少，但并非无用，举例来说，<strong>JVM的垃圾回收、内存管理等线程都是守护线程</strong>。还有就是在做数据库应用时候，使用的数据库连接池，<strong>连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等</strong>。</p><h2 id="如何结束一个线程"><a href="#如何结束一个线程" class="headerlink" title="如何结束一个线程"></a>如何结束一个线程</h2><p><strong>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit</strong> 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。</p><ul><li><p>正常执行完run方法，然后结束掉；</p></li><li><p>控制循环条件和判断条件的标识符来结束掉线程；</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://weread.qq.com/web/reader/d0c3212071a74c21d0c04fdk4e73277021a4e732ced3b55">线程生命周期</a></p><p><a href="https://juejin.cn/post/6844903558433734669#heading-8">啃碎并发（二）：Java线程的生命周期</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程的生命周期&quot;&gt;&lt;a href=&quot;#线程的生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程的生命周期&quot;&gt;&lt;/a&gt;线程的生命周期&lt;/h1&gt;&lt;p&gt;当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>4.常用的线程池</title>
    <link href="https://leslieaibin.github.io/2021/04/29/Java/Thread/4.%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://leslieaibin.github.io/2021/04/29/Java/Thread/4.%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-04-28T22:15:42.000Z</published>
    <updated>2021-04-29T06:49:32.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的线程池"><a href="#常用的线程池" class="headerlink" title="常用的线程池"></a>常用的线程池</h1><p>Java定义了Executor接口并在该接口中定义了<code>execute()</code>用于执行一个线程任务，然后通过<code>ExecutorService</code>实现<code>Executor</code>接口并指向具体线程操作。<code>ExecutorService</code>接口有多个实现类可用于创建不同的线程池。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>newWorkStealingPool</code></td><td>可缓存的线程池</td></tr><tr><td><code>newFixedThreadPool</code></td><td>固定大小的线程池</td></tr><tr><td><code>newScheduledThreadPool</code></td><td>可做任务调度的线程池</td></tr><tr><td><code>newSingleThreadExecutor</code></td><td>单个线程的线程池</td></tr><tr><td><code>newWorkStealingPool</code></td><td>足够大小的线程池，JDK1.8新增</td></tr></tbody></table><h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newWorkStealingPool用于创建一个缓存线程池。之所以叫缓存线程池，是因为它创建新线程时如果有可重用的线程，则重用他们，否则重新创建一个新的线程并将其添加到线程池中。对于执行时间很短的任务而言<code>newWorkStealingPool</code>线程池能很大程度的重用线程进而提高系统性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Exectuors.newCachedThreadPool();</span><br></pre></td></tr></table></figure><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newFixedThreadPool用于创建一个固定线程数量的线程池，并将线程资源存放在队列中循环使用。在newFixedThreadPool线程池中，若处于活动状态的线程数量大于等于核心线程池的数量，则新提交的任务将在阻塞队列中排队，直到有可用的线程资源，具体的创建方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool  = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool创建了一个可定时调度的线程池，可设置在给定的延迟时间后执行或者定期执行某个线程任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建一个延迟3秒的执行线程</span></span><br><span class="line">scheduledExecutorService.schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delay 3 seconds execu.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 创建一个延迟1秒执行且每3秒执行一次的线程</span></span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delay 1 seconds, repeat execute every 3 seconds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newSingleThreadExecutor线程池会保证永远有且只有一个可用的线程，在该线程停止或发生异常时，newSingleThreadExecutor线程池会启动一个新的线程来代替该线程继续执行任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThread = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><h2 id="newWorkStealingPool-1"><a href="#newWorkStealingPool-1" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newWorkStealingPool创建持有足够线程的线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService workStealing = Executors.newWorkStealingPool();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用的线程池&quot;&gt;&lt;a href=&quot;#常用的线程池&quot; class=&quot;headerlink&quot; title=&quot;常用的线程池&quot;&gt;&lt;/a&gt;常用的线程池&lt;/h1&gt;&lt;p&gt;Java定义了Executor接口并在该接口中定义了&lt;code&gt;execute()&lt;/code&gt;用于执行一个</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>3.线程池的工作原理</title>
    <link href="https://leslieaibin.github.io/2021/04/28/Java/Thread/3.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/04/28/Java/Thread/3.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-04-27T16:15:42.000Z</published>
    <updated>2021-04-29T02:51:26.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p>Java线程池主要用于主要用于管理线程组及其运行状态，以便java虚拟机更好地利用CPU资源。Java线程池的工作原理为：JVM先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建这些任务，如果正在运行的线程数量，超过了最大线程数量（用户设置的线程池大小），则超出数量的线程派对等候，在任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。</p><h2 id="线程池相关概念"><a href="#线程池相关概念" class="headerlink" title="线程池相关概念"></a>线程池相关概念</h2><ul><li><strong>核心线程CorePool：</strong>当有新任务提交时，如果核心线程都在工作，并且数量已经达到最大核心线程数，则不会新建核心线程，而是把任务放入等待队列。</li><li><strong>阻塞队列 workQueue:</strong> 等待队列是一个线程安全的阻塞队列。当线程都在忙时，阻塞队列用于存放新增的任务。核心线程完成当前任务回去等待队列中拉取新出的任务。</li><li><strong>非核心线程:</strong> 当等待队列满时，若当前总线程线程数没有查过最大线程数，则会创建新的非核心线程。<ul><li>核心线程与非核心线程没有区别，只会在比较线程池中线程数目时，区分核心线程与非核心线程。</li></ul></li><li><strong>线程活动保持时间keepAliveTime:</strong>  当一个线程空闲下来之后，其保持继续存活的时间。超过该时间则线程销毁。默认情况下，核心线程数量会一直保持，即使他空闲下来了；当设置<code>threadPoolExecutor.allowCoreThreadTimeOut(true)</code> 时，则对核心线程也执行销毁。</li><li><strong>饱和策略 rejectedExecutionHandler</strong> ： 当等待队列满，且总线程数达到最大线程数时，会执行饱和策略。默认饱和策略是抛弃新的任务请求。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20180423235340436" alt="img"></p><p>其中，<code>ThreadPoolExecutor</code> 是构建线程的核心方法，该方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">long</span> keepAliveTime, <span class="comment">// 空闲线程的存活时间</span></span><br><span class="line">    TimeUnit unit, <span class="comment">// keepAliveTime的时间单位</span></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 阻塞队列</span></span><br><span class="line">    ThreadFactory threadFactory, <span class="comment">// 线程工厂，用于创建线程</span></span><br><span class="line">    RejectedExecutionHandler handler); <span class="comment">// 饱和策略</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210428163209103.png" alt="image-20210428163209103"></p><p>这个花瓶由 瓶口 、 瓶颈 、 瓶身 三个部分组成。</p><p>这三个部分分别对应着线程池的三个参数：maximumPoolSize, workQueue,corePoolSize。</p><h3 id="Executor框架实例"><a href="#Executor框架实例" class="headerlink" title="Executor框架实例"></a>Executor框架实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            executorService.submit(() -&gt; System.out.println(<span class="string">&quot;i:&quot;</span> + index +</span><br><span class="line">                    <span class="string">&quot; executorService&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submit(Runnable task)方法提交一个线程。</p><p>但是使用最新的“阿里巴巴编码规范插件”检测一下会发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，</span><br><span class="line">这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </span><br><span class="line">说明：Executors各个方法的弊端：</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>）newFixedThreadPool和newSingleThreadExecutor:</span><br><span class="line">  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</span><br><span class="line"><span class="number">2</span>）newCachedThreadPool和newScheduledThreadPool:</span><br><span class="line">  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        executorService.submit(() -&gt; System.out.println(<span class="string">&quot;i:&quot;</span> + index +</span><br><span class="line">                <span class="string">&quot; executorService&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h2><p>线程复用的核心是，我们知道，<code>Thread.start()</code>只能调用一次，一旦这个调用结束，则该线程就到了stop状态，不能再次调用start。则要达到复用的目的，则必须从<code>Runnable</code>接口的<code>run()</code>方法上入手，可以这样设计这个Runnable.run()方法（就叫外面的run()方法）：<br>        它本质上是个无限循环，跑的过程中不断检查我们是否有新加入的子Runnable对象（就叫内部的runnable:run()吧，它就是用来实现我们自己的任务），有就调一下我们的run()，其实就一个大run()把其它小run()#1,run()#2,…给串联起来了，基本原理就这么简单。不停地处理我们提交的Runnable任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tasks available) &#123;</span><br><span class="line">           Runnable task = taskqueue.dequeue();</span><br><span class="line">           task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// wait or whatever</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h2><ul><li><p><strong>降低资源消耗</strong>：通过池化技术复用已创建的线程，降低线程创建和销毁造成的损耗。</p></li><li><p><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</p></li><li><p><strong>提高线程的可管理性</strong>：使用线程池可以进行统一的分配、调优和监控，避免线程被无限制地创建。</p></li><li><p><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池 <code>ScheduledThreadPoolExecutor</code>，就允许任务延期执行或定期执行。</p></li></ul><h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程"></p><h2 id="Java-线程池-ThreadPoolExecutor"><a href="#Java-线程池-ThreadPoolExecutor" class="headerlink" title="Java 线程池 ThreadPoolExecutor"></a>Java 线程池 ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>线程池在内部实际上构建了一个<strong>生产者-消费者</strong>模型，利用阻塞队列，将线程和任务解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p><p>线程池的运行主要分成两部分：<strong>任务管理、线程管理</strong></p><ul><li>任务管理部分充当生产者，当任务提交后，线程池会判断该任务后续的流转：<ul><li>直接申请线程执行该任务</li><li>缓冲到队列中等待线程执行</li><li>拒绝该任务</li></ul></li><li>线程管理部分是消费者，线程被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会获取新的任务去执行，最终当线程获取不到任务的时候，线程会被回收。</li></ul><h3 id="线程池运行状态-runState"><a href="#线程池运行状态-runState" class="headerlink" title="线程池运行状态-runState"></a>线程池运行状态-runState</h3><table><thead><tr><th align="center">运行状态</th><th align="center">状态描述</th></tr></thead><tbody><tr><td align="center"><strong>RUNNING 运行状态</strong></td><td align="center">接收新任务，并且也能处理阻塞队列中的任务。</td></tr><tr><td align="center"><strong>SHUTDOWN 停工状态</strong></td><td align="center">不接收新任务，但是却可以继续处理阻塞队列中的任务。</td></tr><tr><td align="center"><strong>STOP停止状态</strong></td><td align="center">不接收新任务，同时也不处理队列任务，并且中断正在进行的任务。</td></tr><tr><td align="center"><strong>TIDYING清空状态</strong></td><td align="center">所有任务都已终止，workercount(有效线程数)为0，线程转向 TIDYING 状态将会运行 terminated() 钩子方法。</td></tr><tr><td align="center"><strong>TERMINATED终止状态</strong></td><td align="center">terminated() 方法调用完成后变成此状态。</td></tr></tbody></table><p>线程池生命周期状态转化：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/13888" alt="img"></p><h3 id="线程池任务执行机制"><a href="#线程池任务执行机制" class="headerlink" title="线程池任务执行机制"></a>线程池任务执行机制</h3><p><strong>线程池的任务调度 execute()</strong></p><p>当用户提交了一个任务，所有任务的调度都是由 <code>execute()</code> 方法完成的。包括：检查现在线程池的运行状态、运行线程数、运行策略，并决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。具体的<strong>执行过程</strong>如下：</p><ul><li><p>首先检测线程池运行状态 <code>runState</code>，如果不是 <code>RUNNING</code>，则直接拒绝，线程池要保证在 <code>RUNNING</code> 的状态下执行任务。</p></li><li><p>如果 <code>workerCount &lt; corePoolSize</code>，即核心线程还没创建满，则创建并启动一个核心线程来执行新提交的任务。</p></li><li><p>如果 <code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</p></li><li><p>如果 <code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个非核心线程来执行新提交的任务。</p></li><li><p>如果 <code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据<strong>拒绝策略</strong>来处理该任务, 默认的处理方式是直接抛异常。</p></li></ul><h3 id="任务缓冲与阻塞队列-BlockingQueue"><a href="#任务缓冲与阻塞队列-BlockingQueue" class="headerlink" title="任务缓冲与阻塞队列 BlockingQueue"></a>任务缓冲与阻塞队列 BlockingQueue</h3><p>线程池维护了一个 <code>BlockingQueue&lt;Runnable&gt;</code> <strong>阻塞队列</strong>，用于存放等待执行的线程，队列中的所有线程都处于 <code>Runnable</code> 状态。队列的维护相当于一个 producer-consumer 模型，producer 把线程放入阻塞队列，consumer 从阻塞队列中拿出线程来执行。</p><ul><li><p>当阻塞队列满时，生产者线程会等待队列可用；</p></li><li><p>当阻塞队列空时，消费者线程会等待队列变成非空。</p></li></ul><h3 id="为什么用阻塞队列不用普通队列？"><a href="#为什么用阻塞队列不用普通队列？" class="headerlink" title="为什么用阻塞队列不用普通队列？"></a>为什么用阻塞队列不用普通队列？</h3><p>阻塞队列是为了实现生产者-消费者模型。当消费者从空的队列中取元素时，线程会被阻塞直到队列非空，然后消费者会被自动唤醒。</p><p>如果使用普通队列的话，需要我们自己去实现这样的同步和互斥机制，以及一些线程阻塞与唤醒的策略。</p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>若线程池中的核心线程数被用完且阻塞队列已拍满，则此时线程数的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p><ul><li><p><strong>AbortPolicy</strong>         </p><ul><li>当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbortPolicy 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 结果说明：</span></span><br><span class="line"><span class="comment"> * 将&quot;线程池的拒绝策略&quot;由DiscardPolicy修改为AbortPolicy之后，当有任务添加到线程池被拒绝时，会抛出RejectedExecutionException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbortPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210429104351291.png" alt="image-20210429104351291"></p><p>只有0，1两个任务运行OK，其它的8个任务，在往线程池丢的时候，被线程池拒绝了，而且还抛了异常，被catch住了，catch了8次。</p></li></ul><ul><li><p><strong>CallerRunsPolicy</strong>  </p><ul><li>当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CallerRunsPolicy 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务</span></span><br><span class="line"><span class="comment"> * 翻译一下：就是不进入线程池执行，在这种方式（CallerRunsPolicy）中，任务将有调用者线程去执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallerRunsPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory);</span><br><span class="line">        <span class="comment">// 设置线程池的拒绝策略为&quot;CallerRunsPolicy&quot;</span></span><br><span class="line">        pool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210429104711573.png" alt="image-20210429104711573"></p><p>在任务往线程池丢的时候，发现线程池已经装不下了，那么这个时候，就让往线程池丢任务丢这个线程来执行这个任务，在此例子就是main线程了，从结果图可见线程池里面的一个线程和main一起干活，把10个任务给搞完了。</p></li></ul><ul><li><p><strong>DiscardOldestPolicy</strong></p><ul><li>当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</span></span><br><span class="line"><span class="comment"> * 结果说明：线程池pool的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，这意味着&quot;线程池能同时运行的任务数量最大只能是1&quot;。</span></span><br><span class="line"><span class="comment"> * 线程池pool的阻塞队列是ArrayBlockingQueue，ArrayBlockingQueue是一个有界的阻塞队列，ArrayBlockingQueue的容量为1。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。</span></span><br><span class="line"><span class="comment"> * 根据&quot;&quot;中分析的execute()代码可知：线程池中共运行了2个任务。第1个任务直接放到Worker中，通过线程去执行；第2个任务放到阻塞队列中等待。其他的任务都被丢弃了！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDiscardOldestPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory);</span><br><span class="line">        <span class="comment">// 设置线程池的拒绝策略为&quot;DiscardOldestPolicy&quot;</span></span><br><span class="line">        pool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210429104901856.png" alt="image-20210429104901856"></p><p>可见0任务到池子之后，运行，剩下1-9在来池子的时候，没位置了，都的排队，但位置就1个，那每次新来的都会不客气但把旧时代的给挤掉。也就是这个策略的名字的由来。</p></li><li><p><strong>DiscardPolicy</strong>    </p><ul><li>当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</span></span><br><span class="line"><span class="comment"> * 结果说明：线程池pool的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，这意味着&quot;线程池能同时运行的任务数量最大只能是1&quot;。</span></span><br><span class="line"><span class="comment"> * 线程池pool的阻塞队列是ArrayBlockingQueue，ArrayBlockingQueue是一个有界的阻塞队列，ArrayBlockingQueue的容量为1。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。</span></span><br><span class="line"><span class="comment"> * 根据&quot;&quot;中分析的execute()代码可知：线程池中共运行了2个任务。第1个任务直接放到Worker中，通过线程去执行；第2个任务放到阻塞队列中等待。其他的任务都被丢弃了！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDiscardPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory);</span><br><span class="line">        <span class="comment">// 设置线程池的拒绝策略为&quot;丢弃&quot;</span></span><br><span class="line">        pool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210428212820271.png" alt="image-20210428212820271"></p></li></ul><p>任务0来了池子，先抢占了线程，可以执行，之后来的都的在队列里排队，但队列就一个位置，先来的占着位置，后面的来只能看着，被无情的抛弃，所以，输出结果就0，1两个任务执行，其它的都消失了。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团技术团队-Java线程池</a></p><p><a href="http://concurrent.redspider.group/article/03/12.html">redspider-线程池部分</a></p><p><a href="https://zgxh.github.io/2020/11/06/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/12.%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/#toc-heading-15">线程池工作原理</a></p><h2 id="线程池源码分析："><a href="#线程池源码分析：" class="headerlink" title="线程池源码分析："></a>线程池源码分析：</h2><p><a href="https://juejin.im/post/6844903795768459271">掘金-线程池源码分析</a></p><p><a href="https://juejin.im/post/6844903889678893063">掘金-Java 线程池</a></p><p><a href="https://segmentfault.com/a/1190000016326062">segmentfault-线程池源码分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池的工作原理&quot;&gt;&lt;a href=&quot;#线程池的工作原理&quot; class=&quot;headerlink&quot; title=&quot;线程池的工作原理&quot;&gt;&lt;/a&gt;线程池的工作原理&lt;/h1&gt;&lt;p&gt;Java线程池主要用于主要用于管理线程组及其运行状态，以便java虚拟机更好地利用CPU资源</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2.java中多线程的实现</title>
    <link href="https://leslieaibin.github.io/2021/04/24/Java/Thread/2.java%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://leslieaibin.github.io/2021/04/24/Java/Thread/2.java%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-23T16:15:42.000Z</published>
    <updated>2021-04-28T13:35:37.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java多线程编程"><a href="#Java多线程编程" class="headerlink" title="Java多线程编程"></a>Java多线程编程</h2><p>java给多线程编程提供了内置的支持。一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程 ，每条线程并行执行不同的任务。</p><p>一个进程包括由操作系统分配的内存空间，包括一个或多个线程。一个线程不能独立的存在，他必须是进程的一部分。一个进程一直运行，直到所有的非收回线程都结束运行后才能结束。</p><h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210427163338918.png" alt="image-20210427163338918"></p><ul><li><p>新建状态</p><p>使用new关键字和Thread类或器子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序<code>start()</code>线程。</p></li><li><p>就绪状态</p><p>当线程对象调用了<code>start()</code>方法之后，该线程就进入了就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里<strong>线程调度器</strong>的调度。</p></li><li><p>运行状态</p><p>如果就绪状态的线程以获取CPU资源，就可以执行<code>run()</code>，此时线程便处于运行状态。处于运行状态的线程最为复杂，他可以变为<strong>阻塞状态</strong>，<strong>就绪状态</strong>和<strong>死亡状态</strong>。</p></li><li><p>阻塞状态</p><p>如果一个线程执行了<code>sleep（睡眠）</code>、<code>suspend（挂起）</code>等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态</p><p>一个运行状态的线程完成任务或者其他终止条发生时，该线程就切换到终止状态</p></li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>java线程的优先级是一个整数，其取值范围 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="Java-中多线程的实现"><a href="#Java-中多线程的实现" class="headerlink" title="Java 中多线程的实现"></a>Java 中多线程的实现</h2><p>主要有三种方案：</p><ul><li><p>Thread class       继承Thread类</p></li><li><p>Runnable接口    实现Runnable接口</p></li><li><p>Callable接口       实现Callable接口</p></li></ul><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><ul><li>继承<code>Thread</code>类， 并重写<strong>run()</strong> 方法</li><li>Thread类底层也是实现Runnable接口，并重写了<code>run()</code>方法</li><li>调用<code>start()</code>方法后，JVM为创建一个新的线程，并将该线程设置为可<strong>运行态Runnable</strong>,但并没有直接运行</li><li>当线程第一次得到时间片时，<code>run()</code> 方法得以运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ThreadDemo T1 = <span class="keyword">new</span> ThreadDemo(<span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        T1.start();</span><br><span class="line"></span><br><span class="line">        ThreadDemo T2 = <span class="keyword">new</span> ThreadDemo(<span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line">        T2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">200000</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Main: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    ThreadDemo(String name) &#123;</span><br><span class="line">        threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating&quot;</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span> + threadName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">                <span class="comment">// 让线程睡眠一会</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting &quot;</span> + threadName);</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, threadName);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>start() 方法不可被多次调用，否则会抛出异常。</strong></p><h3 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>public void start()</strong></td><td>开始线程，将新线程设置为就绪态; Java虚拟机调用该线程的run()方法</td></tr><tr><td><strong>public void run()</strong></td><td>线程获得时间片时，自动被异步调用，真正开始执行该线程; 该线程实现自<code>Runnable</code>接口</td></tr><tr><td><strong>public final void setName(String name)</strong></td><td>改变线程名称，使之与参数name相同</td></tr><tr><td><strong>public final void setPriority(int priority)</strong></td><td>更改线程的优先级</td></tr><tr><td><strong>public final void setDaemon(boolean on)</strong></td><td>将该线程标记为收回线程或用户线程</td></tr><tr><td><strong>public final void join(long millisec)</strong></td><td>让当前线程等待另一个线程执行完毕后再继续执行； 底层是使用的<code>Object</code>类的<code>wait()</code>方法</td></tr><tr><td><strong>public void interrupt()</strong></td><td>中断线程</td></tr><tr><td><strong>public final boolean isAlive()</strong></td><td>判断线程是否处于活动状态</td></tr></tbody></table><p>上述方法是被Thread对象调用的，线面的方法是Thread类的静态方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>public static void yield()</strong></td><td>让出当前的CPU时间片，并重现变成就绪状态，重新竞争CPU。让出后，可能当前CPU使用权还会被该线程获取到。</td></tr><tr><td><strong>public static void sleep(long millisec)</strong></td><td>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td></tr><tr><td><strong>public static Thread currentThread()</strong></td><td>返回对当前正在执行的线程对象的引用。</td></tr><tr><td><strong>public static boolean holdsLock(Object x)</strong></td><td>当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td></tr><tr><td><strong>public static void dumpStack()</strong></td><td>将当前线程的堆栈跟踪打印至标准错误流。</td></tr></tbody></table><h3 id="线程sleep和yield的区别"><a href="#线程sleep和yield的区别" class="headerlink" title="线程sleep和yield的区别"></a>线程sleep和yield的区别</h3><ul><li><code>sleep()</code>方法暂停当前线程后，会给其他线程执行机会，线程优先级对此没有影响。<code>yield()</code>方法会给优先级相同或更高的线程更高的执行机会</li><li><code>sleep()</code>方法会将线程转入阻塞状态，知道阻塞时间结束，才会转入就绪状态。<code>yield()</code>方法会将当前线程直接转入就绪状态。</li><li><code>sleep()</code>方法生命抛出InterruptedException异常，所以调用sleep()方法时要么捕捉该异常，要么显示声明抛出该异常。<code>yield()</code>方法则没有声明抛出任何异常。</li><li><code>sleep()</code>方法比yield()方法有更好的移植性，通常不建议使用yield()方法来控制并发线程的执行。</li></ul><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>如果一个子类已经继承了一个类，就无法在继承Thread类，此时可以通过Runnable接口创建线程。</p><ul><li><p>通过实现Runnable接口创建RunnableDemo线程，对其进行实例化</p></li><li><p>创建Thread类的实例并传入RunnableDemo线程的实例</p></li><li><p>调用线程的start方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        RunnableDemo R1 = <span class="keyword">new</span> RunnableDemo( <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        R1.start();</span><br><span class="line"></span><br><span class="line">        RunnableDemo R2 = <span class="keyword">new</span> RunnableDemo( <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line">        R2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    RunnableDemo( String name) &#123;</span><br><span class="line">        threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> +  threadName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running &quot;</span> +  threadName );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                <span class="comment">// 让线程睡眠一会</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting &quot;</span> +  threadName );</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread (<span class="keyword">this</span>, threadName);</span><br><span class="line">            t.start ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Runnable</code> 接口来创建并启动线程，有两种方式：</p><ol><li>通过 <strong>普通类</strong> 的方式或 <strong>函数式编程匿名类</strong> 的方式来创建 <code>Runnable</code> 接口的实现类，并实现 <code>run()</code> 方法。</li><li>传入 <code>Runnable</code> 的实现类，实例化 <code>Thread</code> 类对象。</li><li>调用 <code>start()</code> 方法来启动该线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 Thread 类来创建新线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread()).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 8 函数式编程，创建匿名类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-Callable-和-ExecutorService创建线程"><a href="#通过-Callable-和-ExecutorService创建线程" class="headerlink" title="通过 Callable 和 ExecutorService创建线程"></a>通过 Callable 和 ExecutorService创建线程</h2><p>有时，我们需要在主线程中开启多个子线程并发执行一个任务，然后收集各个线程执行返回的结果并将最终结果汇总起来，这时就要用到Callable接口。</p><ul><li><p>创建callable接口的实现类，并实现call方法，该call()方法将作为线程执行体，并且有返回值。</p></li><li><p>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该Future List对象封装了该Callable对象的call()方法的返回值</p></li><li><p>使用Future List 对象作为Thread对象的target创建并启动新线程</p></li><li><p>调用Future List对象的get()方法来获得子线程执行结束后的返回值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// step 2: 创建一个固定大小为5的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// step 3: 创建有多个有返回值的任务列表</span></span><br><span class="line">        List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">// step 4: 创建一个有返回值的线程实例</span></span><br><span class="line">            Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// step 5： 提交线程，获取Future对象并将其保存到Future List中</span></span><br><span class="line">            Future future = pool.submit(c);</span><br><span class="line">            System.out.println(<span class="string">&quot;submit a callable thread: &quot;</span> + i);</span><br><span class="line">            list.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step 6: 关闭线程池，等待线程执行结束</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">        <span class="comment">// step 7: 遍历所有线程的运行结果，</span></span><br><span class="line">        <span class="keyword">for</span> (Future future : list)&#123;</span><br><span class="line">            <span class="comment">// 从Future 对象上获取任务的返回值 并将结果输出到控制台</span></span><br><span class="line">            System.out.println(<span class="string">&quot;get  the result from callable thread: &quot;</span> + future.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 ：通过实现Callable接口创建MyCallable线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 通过构造函数为线程传递函数，以定义线程的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span> <span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul><li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li> 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li></ul><h2 id="面试：-线程无线次创建的时候会拖垮CPU么"><a href="#面试：-线程无线次创建的时候会拖垮CPU么" class="headerlink" title="面试： 线程无线次创建的时候会拖垮CPU么  ?"></a>面试： 线程无线次创建的时候会拖垮CPU么  ?</h2><p>不会拓宽CPU， 只会占满内存，造成out of memery</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java多线程编程&quot;&gt;&lt;a href=&quot;#Java多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程编程&quot;&gt;&lt;/a&gt;Java多线程编程&lt;/h2&gt;&lt;p&gt;java给多线程编程提供了内置的支持。一个线程指的是进程中一个单一顺序的控制流，一个</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>1.Java集合-框架</title>
    <link href="https://leslieaibin.github.io/2021/03/26/Java/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/"/>
    <id>https://leslieaibin.github.io/2021/03/26/Java/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/</id>
    <published>2021-03-25T16:15:42.000Z</published>
    <updated>2021-04-28T06:34:46.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合-1-–java集合分类"><a href="#Java集合-1-–java集合分类" class="headerlink" title="Java集合[1]–java集合分类"></a>Java集合[1]–java集合分类</h1><p>之前大概分为三种，<code>Set</code>，<code>List</code>，<code>Map</code>三种，JDK5之后，增加<code>Queue</code>.主要由<code>Collection</code>和<code>Map</code>两个接口衍生出来,同时<code>Collection</code>接口继承<code>Iterable</code>接口，所以我们也可以说java里面的集合类主要是由<code>Iterable</code>和<code>Map</code>两个接口以及他们的子接口或者其实现类组成。我们可以认为<code>Collection</code>接口定义了单列集合的规范，每次只能存储一个元素，而<code>Map</code>接口定义了双列集合的规范，每次能存储一对元素。</p><p>Iterable接口:主要是实现遍历功能</p><ul><li>Collection接口: 允许重复<ul><li>Set接口：无序，元素不可重复,访问元素只能通过元素本身来访问。</li><li>List接口：有序且可重复，可以根据元素的索引来访问集合中的元素。</li><li>Queue接口：队列集合</li></ul></li></ul><p>Map接口：映射关系，简单理解为键值对&lt;Key，Value&gt;，Key不可重复，与<code>Collection</code>接口关系不大，只是个别函数使用到。</p><p>整个接口框架关系</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20190414213527553.jpg" alt="20190414213527553"></p><h2 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个内部元素为T类型的迭代器（JDK1.5只有这个接口）</span></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历内部元素，action意思为动作，指可以对每个元素进行操作（JDK1.8添加）</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个可分割迭代器（JDK1.8添加），分割的迭代器主要是提供可以并行遍历元素的迭代器，可以适应现在cpu多核的能力，加快速度。</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java集合最源头的接口，实现这个接口的作用主要是集合对象可以通过迭代器去遍历每一个元素。</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>default void</code></td><td><code>forEachRemaining(Consumer&lt;? super E&gt; action)</code>  执行给定的每个剩余元素的动作，直到所有的元素都被处理或操作抛出异常。</td></tr><tr><td><code>boolean</code></td><td><code>hasNext()</code>  返回 <code>true</code>如果迭代具有更多的元素。</td></tr><tr><td><code>E</code></td><td><code>next()</code>  返回迭代中的下一个元素。</td></tr><tr><td><code>default void</code></td><td><code>remove()</code>  从基础集合中移除这个迭代器返回的最后一个元素（可选操作）。</td></tr></tbody></table><p> <strong>iterator方法</strong></p><p>遍历Collection的两种方式：</p><p>​        ① 使用迭代器Iterator  ② foreach循环（或增强for循环）</p><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</p><p> GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;asdfg&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;zxcvb&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">false</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="comment">// hasNext():判断是否还下一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">// next():①指针下移  ②将下移以后集合位置上的元素返回</span></span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;zxcvb&quot;</span>.equals(obj))&#123;</span><br><span class="line">            <span class="comment">// 内部定义了remove(),可以在遍历的时候，删除集合中的元素。</span></span><br><span class="line">            iterator.remove(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator iterator1 = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator1.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************************&quot;</span>);</span><br><span class="line">    <span class="comment">// for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//        // 错误方式一： 一次iterator.next()进行一次指针移动</span></span><br><span class="line">    <span class="comment">//        while(iterator.next() != null)&#123;</span></span><br><span class="line">    <span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        // 错误方式二： 一次coll.iterator()返回一个迭代器对象</span></span><br><span class="line">    <span class="comment">//        while(coll.iterator().hasNext())&#123;</span></span><br><span class="line">    <span class="comment">//            System.out.println(coll.iterator().next());</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。 这是由于<a href="https://zhuanlan.zhihu.com/p/37476508">Fail-fast</a>。</p><h3 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h3><p>其实就是把对每一个元素的操作当成了一个对象传递进来，对每一个元素进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list.forEach(x -&gt; System.out.print(x));</span><br></pre></td></tr></table></figure><p>当然像ArrayList自然也是有自己的实现的，那我们就可以使用这样的写法,简洁优雅。forEach方法在java8中参数是<code>java.util.function.Consumer</code>,可以称为<strong>消费行为</strong>或者说<strong>动作</strong>类型。</p><h3 id="spliterator方法"><a href="#spliterator方法" class="headerlink" title="spliterator方法"></a>spliterator方法</h3><p>这是一个为了并行遍历数据元素而设计的迭代方法，返回的是<code>Spliterator</code>，是专门并行遍历的迭代器。以发挥多核时代的处理器性能，java默认在集合框架中提供了一个默认的<code>Spliterator</code>实现，底层也就是Stream.isParallel()实现的，我们可以看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream使用的就是spliterator</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210326162900813.png" alt="image-20210326162900813"></p><p>Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  确保此集合包含指定的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code>  将指定集合中的所有元素添加到这个集合（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>clear()</code>  从这个集合中移除所有的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>  返回 <code>true</code>如果集合包含指定元素。</td></tr><tr><td><code>boolean</code></td><td><code>containsAll(Collection&lt;?&gt; c)</code>  返回 <code>true</code>如果这个集合包含指定集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此集合进行比较，以进行相等性。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此集合的哈希代码值。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果集合不包含任何元素。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>  返回此集合中的元素的迭代器。</td></tr><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>parallelStream()</code>  返回一个可能并行 <code>Stream</code>与集合的来源。</td></tr><tr><td><code>boolean</code></td><td><code>remove(Object o)</code>  从这个集合中移除指定元素的一个实例，如果它是存在的（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>removeAll(Collection&lt;?&gt; c)</code>  删除此集合中包含的所有元素（可选操作）的所有元素（可选操作）。</td></tr><tr><td><code>default boolean</code></td><td><code>removeIf(Predicate&lt;? super E&gt; filter)</code>  删除满足给定谓词的这个集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的这个集合中的元素（可选操作）。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回此集合中的元素的数目。</td></tr><tr><td><code>default Spliterator&lt;E&gt;</code></td><td><code>spliterator()</code>  创建此集合中的元素的 <a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>。</td></tr><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>stream()</code>  返回一个序列 <code>Stream</code>与集合的来源。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>  返回包含此集合中所有元素的数组。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>  返回包含此集合中所有元素的数组；返回数组的运行时类型是指定的数组的运行时类型。</td></tr></tbody></table><p>可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。<br>其中重点介绍iterator()方法，该方法的返回值是Iterator<E>。</p><h3 id="List-extends-Collection"><a href="#List-extends-Collection" class="headerlink" title="List extends Collection"></a>List extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继承于<code>Collection</code>接口，有顺序，取出的顺序与存入的顺序一致，有索引，可以根据索引获取数据，允许存储重复的元素，可以放入为null的元素。<br> 最常见的三个实现类就是<code>ArrayList</code>，<code>Vector</code>,<code>LinkedList</code>，<code>ArrayList</code>和<code>Vector</code>都是内部封装了对数组的操作，唯一不同的是，<code>Vector</code>是线程安全的，而<code>ArrayList</code>不是，理论上<code>ArrayList</code>操作的效率会比<code>Vector</code>好一些。</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  将指定的元素到这个列表的末尾（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>add(int index, E element)</code>  在列表中指定的位置上插入指定的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code>  追加指定集合的所有元素到这个列表的末尾，按他们的指定集合的迭代器返回（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(int index,  Collection&lt;? extends E&gt; c)</code>  将指定的集合中的所有元素插入到指定位置的列表中（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>clear()</code>  从这个列表中移除所有的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>  返回 <code>true</code>如果这个列表包含指定元素。</td></tr><tr><td><code>boolean</code></td><td><code>containsAll(Collection&lt;?&gt; c)</code>  返回 <code>true</code>如果这个列表包含指定集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此列表进行比较，以进行相等性。</td></tr><tr><td><code>E</code></td><td><code>get(int index)</code>  返回此列表中指定位置的元素。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此列表的哈希代码值。</td></tr><tr><td><code>int</code></td><td><code>indexOf(Object o)</code>  返回此列表中指定元素的第一个出现的索引，或-如果此列表不包含元素，或- 1。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果此列表不包含元素。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>  在这个列表中的元素上返回一个正确的顺序。</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(Object o)</code>  返回此列表中指定元素的最后一个发生的索引，或-如果此列表不包含元素，或- 1。</td></tr><tr><td><code>ListIterator&lt;E&gt;</code></td><td><code>listIterator()</code>  返回列表元素的列表迭代器（在适当的顺序）。</td></tr><tr><td><code>ListIterator&lt;E&gt;</code></td><td><code>listIterator(int index)</code>  在列表中的元素上返回列表迭代器（在适当的顺序），从列表中的指定位置开始。</td></tr><tr><td><code>E</code></td><td><code>remove(int index)</code>  移除此列表中指定位置的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>remove(Object o)</code>  从该列表中移除指定元素的第一个发生，如果它是存在的（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>removeAll(Collection&lt;?&gt; c)</code>  从这个列表中移除包含在指定集合中的所有元素（可选操作）。</td></tr><tr><td><code>default void</code></td><td><code>replaceAll(UnaryOperator&lt;E&gt; operator)</code>  用将运算符应用到该元素的结果替换此列表中的每个元素。</td></tr><tr><td><code>boolean</code></td><td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的列表中的元素（可选操作）。</td></tr><tr><td><code>E</code></td><td><code>set(int index, E element)</code>  用指定元素替换此列表中指定位置的元素（可选操作）。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回此列表中元素的数目。</td></tr><tr><td><code>default void</code></td><td><code>sort(Comparator&lt;? super E&gt; c)</code>  分类列表使用提供的 <code>Comparator</code>比较元素。</td></tr><tr><td><code>default Spliterator&lt;E&gt;</code></td><td><code>spliterator()</code>  创建此列表中的元素的 <a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>。</td></tr><tr><td><code>List&lt;E&gt;</code></td><td><code>subList(int fromIndex,  int toIndex)</code>  返回一个视图之间的指定 <code>fromIndex</code>，包容，和  <code>toIndex</code>这份名单的部分，独家。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>  返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>  返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一到最后一个元素）；返回数组的运行时类型是指定的数组的运行时类型。</td></tr></tbody></table><p>Collection接口：单列集合，用来存储一个一个的对象</p><p><strong>常用类</strong></p><ul><li>List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组<ul><li><strong>ArrayList</strong>：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</li><li><strong>LinkedList</strong>：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li><li><strong>Vector</strong>：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li></ul></li></ul><h3 id="Set-extends-Collection"><a href="#Set-extends-Collection" class="headerlink" title="Set extends Collection"></a>Set extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  如果没有当前（可选操作），则将指定的元素添加到该集合中。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code>  如果没有当前（可选操作），将指定集合中的所有元素添加到该集合中。</td></tr><tr><td><code>void</code></td><td><code>clear()</code>  从这个集合中移除所有的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>  如果这套 <code>true</code>返回包含指定的元素。</td></tr><tr><td><code>boolean</code></td><td><code>containsAll(Collection&lt;?&gt; c)</code>  如果这套 <code>true</code>返回包含指定集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此设置的相等性进行比较。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此组的哈希代码值。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果这个集合不包含元素。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>  返回此集合中元素的迭代器。</td></tr><tr><td><code>boolean</code></td><td><code>remove(Object o)</code>  如果当前（可选操作），则从该集合中移除指定的元素。</td></tr><tr><td><code>boolean</code></td><td><code>removeAll(Collection&lt;?&gt; c)</code>  从这个集合中移除包含在指定集合中的所有元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的此集合中的元素（可选操作）。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回该集合中元素个数（其基数）。</td></tr><tr><td><code>default Spliterator&lt;E&gt;</code></td><td><code>spliterator()</code>  在这个集合中的元素创建一个 <code>Spliterator</code>。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>  返回一个包含此集合中所有元素的数组。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>  返回包含此集合中的所有元素的数组；返回的数组的运行时类型是指定的数组的运行时类型。</td></tr></tbody></table><p><strong>Set</strong>存储的数据特点：无序的、不可重复的元素</p><p><strong>常用类</strong></p><p> 以HashSet为例说明：</p><ul><li><p>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</p></li><li><p>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</p></li></ul><p>Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。</p><p>Collection接口：单列集合，用来存储一个一个的对象</p><ul><li><p>Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”</p><ul><li><p>HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</p><ul><li><p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历。</p><p>在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p></li></ul></li><li><pre><code>         TreeSet：可以照添加对象的指定属性，进行排序。</code></pre></li></ul></li></ul><h3 id="Queue-extends-Collection"><a href="#Queue-extends-Collection" class="headerlink" title="Queue extends Collection"></a>Queue extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  插入指定元素为该队列是否有可能立即这样做不违反容量限制，还  <code>true</code>成功后抛出 <code>IllegalStateException</code>如果没有空间是可用的。</td></tr><tr><td><code>E</code></td><td><code>element()</code>  检索，但不删除此队列的头。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>  如果可能立即在不违反容量限制的情况下这样做的话，将指定的元素插入到队列中。</td></tr><tr><td><code>E</code></td><td><code>peek()</code>  检索，但不删除，这个队列头，或返回 <code>null</code>如果队列为空。</td></tr><tr><td><code>E</code></td><td><code>poll()</code>  检索并移除此队列的头，或返回 <code>null</code>如果队列为空。</td></tr><tr><td><code>E</code></td><td><code>remove()</code>  检索和删除此队列的头。</td></tr></tbody></table><p>队列接口，在Collection接口的接触上添加了增删改查接口定义，一般默认是先进先出，即FIFO，除了优先队列和栈，优先队列是自己定义了排序的优先顺序，队列中不允许放入null元素。</p><ul><li><p>Deque（接口）:Queue的子接口，双向队列，可以从两边存取</p><ul><li>ArrayDeque：Deque的实现类，底层用数组实现，数据存贮在数组中</li></ul></li><li><p>AbstractQueue：Queue的子接口，仅实现了add、remove和element三个方法</p><ul><li>PriorityQueue：按照默认或者自己定义的顺序来排序元素，底层使用堆（完全二叉树）实现，使用动态数组实现，</li></ul></li><li><p>BlockingQueue： 在java.util.concurrent包中，阻塞队列，满足当前无法处理的操作</p></li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interface Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><ul><li>定义双列集合的规范Map&lt;K，V&gt;，每次存储一对元素，即key和value。</li><li>key的类型可以和value的类型相同，也可以不同，任意的引用类型都可以。</li><li>key是不允许重复的，但是value是可以重复的，所谓重复是指计算的hash值系统。</li></ul><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>clear()</code>  从这个映射中移除所有的映射（可选操作）。</td></tr><tr><td><code>default V</code></td><td><code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  试图计算出指定键和当前的映射值的映射（或 <code>null</code>如果没有当前映射）。</td></tr><tr><td><code>default V</code></td><td><code>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>  如果指定的键是不是已经与价值相关的（或映射到  <code>null</code>），尝试使用给定的映射功能，进入到这个Map除非 <code>null</code>计算其价值。</td></tr><tr><td><code>default V</code></td><td><code>computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  如果指定键的值是存在和非空的，尝试计算一个新的映射，给出了键和它当前的映射值。</td></tr><tr><td><code>boolean</code></td><td><code>containsKey(Object key)</code>  返回 <code>true</code>如果这Map包含一个指定的键映射。</td></tr><tr><td><code>boolean</code></td><td><code>containsValue(Object value)</code>  返回 <code>true</code>如果映射到指定的值的一个或多个键。</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td><td><code>entrySet()</code>  返回一个 <a href="../../java/util/Set.html"><code>Set</code></a>视图的映射包含在这个Map。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此映射的相等性进行比较。</td></tr><tr><td><code>default void</code></td><td><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>  在该映射中的每个条目执行给定的操作，直到所有的条目被处理或操作抛出异常。</td></tr><tr><td><code>V</code></td><td><code>get(Object key)</code>  返回指定的键映射的值，或 <code>null</code>如果这个Map不包含的键映射。</td></tr><tr><td><code>default V</code></td><td><code>getOrDefault(Object key, V defaultValue)</code>  返回指定的键映射的值，或  <code>defaultValue</code>如果这个Map不包含的键映射。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此映射的哈希代码值。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果这个Map不包含键值的映射。</td></tr><tr><td><code>Set&lt;K&gt;</code></td><td><code>keySet()</code>  返回一个 <a href="../../java/util/Set.html"><code>Set</code></a>的关键视图包含在这个Map。</td></tr><tr><td><code>default V</code></td><td><code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>  如果指定的键已与值相关联的值或与空值相关联的，则将其与给定的非空值关联。</td></tr><tr><td><code>V</code></td><td><code>put(K key, V value)</code>  将指定的值与此映射中的指定键关联（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>putAll(Map&lt;?  extends K,?  extends V&gt; m)</code>  从指定的映射到这个Map（可选操作）复制所有的映射。</td></tr><tr><td><code>default V</code></td><td><code>putIfAbsent(K key, V value)</code>  如果指定的键是不是已经与价值相关的（或映射到  <code>null</code>）将其与给定的值并返回 <code>null</code>，否则返回当前值。</td></tr><tr><td><code>V</code></td><td><code>remove(Object key)</code>  如果存在（可选操作），则从该Map中移除一个键的映射。</td></tr><tr><td><code>default boolean</code></td><td><code>remove(Object key, Object value)</code>  仅当它当前映射到指定的值时，为指定的键移除条目。</td></tr><tr><td><code>default V</code></td><td><code>replace(K key, V value)</code>  仅当它当前映射到某一值时，替换指定的键的条目。</td></tr><tr><td><code>default boolean</code></td><td><code>replace(K key, V oldValue, V newValue)</code>  仅当当前映射到指定的值时，替换指定的键的条目。</td></tr><tr><td><code>default void</code></td><td><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>  将每个条目的值替换为在该项上调用给定函数的结果，直到所有的条目都被处理或函数抛出异常。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回这个映射中的键值映射的数目。</td></tr><tr><td><code>Collection&lt;V&gt;</code></td><td><code>values()</code>  返回一个 <a href="../../java/util/Collection.html"><code>Collection</code></a>视图的值包含在这个Map。</td></tr></tbody></table><p><strong>Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)</strong></p><ul><li><p>HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</p><ul><li><pre><code>         LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</code></pre></li><li><pre><code>               原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</code></pre></li><li><pre><code>               对于频繁的遍历操作，此类执行效率高于HashMap。</code></pre></li></ul></li><li><p>TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</p><p>底层使用红黑树</p></li><li><p>Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p><ul><li><pre><code>  Properties:常用来处理配置文件。key和value都是String类型</code></pre></li></ul></li><li><p>HashMap的底层：数组+链表  （jdk7及之前)</p></li></ul><p>  <strong>数组+链表+红黑树 （jdk 8)</strong></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么有数组了，还要提供集合？</p><p><strong>数组的优点：</strong></p><ul><li>数组的效率高于集合类</li><li>数组能存放基本数据类型和对象；集合中只能放对象</li></ul><p><strong>数组的缺点：</strong></p><ul><li>不是面向对象的，存在明显的缺陷</li><li>数组长度固定且无法动态改变；集合类容量动态改变</li><li>数组无法判断其中实际存了多少元素，只能通过length属性获取数组的申明的长度</li><li>数组存储的特点是顺序的连续内存；集合的数据结构更丰富</li></ul><p><strong>JDK 提供集合的意义：</strong></p><ul><li>集合以类的形式存在，符合面向对象，通过简单的方法和属性调用可实现各种复杂操作</li><li>集合有多种数据结构，不同类型的集合可适用于不同场合</li><li>弥补了数组的一些缺点，比数组更灵活、实用，可开发效率</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java集合-1-–java集合分类&quot;&gt;&lt;a href=&quot;#Java集合-1-–java集合分类&quot; class=&quot;headerlink&quot; title=&quot;Java集合[1]–java集合分类&quot;&gt;&lt;/a&gt;Java集合[1]–java集合分类&lt;/h1&gt;&lt;p&gt;之前大概分为</summary>
      
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法（Java实现）</title>
    <link href="https://leslieaibin.github.io/2020/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89/</id>
    <published>2020-12-05T16:15:42.000Z</published>
    <updated>2020-12-06T15:26:53.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法概述"><a href="#排序算法概述" class="headerlink" title="排序算法概述"></a>排序算法概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将杂乱无章的数据元素，通过一定的方法按关键字顺序排列的过程叫做排序。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>非线性时间比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li><li><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-df96f14c5802a123.png" alt="img"></p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-fe7ee389e47ba067.png" alt="img"></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><strong>稳定：</strong>如果a原本在b前面且a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定：</strong>如果a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度：</strong>对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li><li><strong>内部排序：</strong>所有排序操作都在内存中完成。本文主要介绍的是内部排序。</li><li><strong>外部排序：</strong>待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。</li></ul><h2 id="各算法原理及实现"><a href="#各算法原理及实现" class="headerlink" title="各算法原理及实现"></a>各算法原理及实现</h2><p>下面我们来逐一分析十大经典排序算法，主要围绕下列问题展开：<br> 1、算法的基本思想是什么？<br> 2、算法的代码实现？<br> 3、算法的时间复杂度是多少？（平均、最好、最坏）什么情况下最好？什么情况下最坏？<br> 4、算法的空间复杂度是多少？<br> 5、算法的稳定性如何？</p><h3 id="直接插入排序（Insertion-Sort）"><a href="#直接插入排序（Insertion-Sort）" class="headerlink" title="直接插入排序（Insertion Sort）"></a>直接插入排序（Insertion Sort）</h3><p><strong>基本思想</strong></p><p>直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述</strong></p><p>一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：</p><ul><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>将新元素插入到该位置后；</p></li><li><p>重复步骤2~5。</p></li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-07e08e0588d54869.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertioSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        current = nums[i];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (current &gt;= <span class="number">0</span> &amp;&amp; current &lt; nums[preIndex])&#123;</span><br><span class="line">            nums[preIndex + <span class="number">1</span>] = nums[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>直接插入排序平均时间复杂度为O(n<sup>2</sup>)，最好时间复杂度为O(n)，最坏时间复杂度为O(n<sup>2</sup>)。</p><p><strong>最好情况：</strong></p><p>如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。</p><p><strong>最坏情况：</strong>如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n * (n - 1) / 2和 n * (n - 1) / 2。因此最坏情况下的时间复杂度为O(n<sup>2</sup>)。</p><p><strong>空间复杂度</strong></p><p>直接插入排序使用了常数空间，空间复杂度为O（1）</p><p><strong>稳定性</strong></p><p>直接插入属于稳定的</p><p><strong>算法扩展</strong></p><p>在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即<strong>二分插入排序</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binaryInsertioSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = nums[i];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; right)&#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; --j)&#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p><strong>基本思想</strong></p><p> 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><strong>算法描述</strong></p><ul><li>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-641d29be81792220.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="comment">// 设置标识，检测是否交换过，如果没有交换过则表示已经有序，无需排序</span></span><br><span class="line">    <span class="keyword">int</span> numPairs = nums.length;</span><br><span class="line">    <span class="keyword">boolean</span> = isSwap = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (isSwap)&#123;</span><br><span class="line">        isSwap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPairs - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i + <span class="number">1</span>];</span><br><span class="line">                nums[i + <span class="number">1</span>]  = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                isSwap = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numPairs--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>冒泡排序平均时间复杂度为O(n<sup>2</sup>)，最好时间复杂度为O(n)，最坏时间复杂度为O(n<sup>2</sup>)。</p><p> <strong>最好情况：</strong></p><p>如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。</p><p> <strong>最坏情况：</strong>如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n * (n - 1) / 2和 3 * n * (n-1) / 2。因此最坏情况下的时间复杂度为O(n<sup>2</sup>)。</p><p><strong>空间复杂度</strong></p><p>冒泡排序使用了常数空间，空间复杂度为O(1)</p><p><strong>稳定性</strong></p><p>当 array[j] == array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以冒泡排序是稳定的。</p><p><strong>算法扩展</strong></p><p><strong>鸡尾酒排序，又称定向冒泡排序、搅拌排序等，是对冒泡排序的改进。</strong>在把最大的数往后面冒泡的同时，把最小的数也往前面冒泡，同时收缩无序区的左右边界，有序区在序列左右逐渐累积。</p><p>动图如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-81626da2174262f3.gif" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] cocktailSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i + <span class="number">1</span>];</span><br><span class="line">                nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸡尾酒排序是稳定的。它的平均时间复杂度为O(n<sup>2</sup>)，最好情况是待排序列原先就是正序的，时间复杂度为O(n)，最坏情况是待排序列原先是逆序的，时间复杂度为O(n<sup>2</sup>。空间复杂度为O(1)。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p><strong>基本思想</strong></p><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><strong>算法描述</strong></p><p> 快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；</li><li>递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-d1a29d77c2e60116.gif" alt="img"></p><p><strong>代码实现</strong></p><p><strong>快速排序最核心的步骤就是partition操作</strong>，即从待排序的数列中选出一个数作为基准，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。partition函数返回基准的位置，然后就可以对基准位置的左右子序列递归地进行同样的快排操作，从而使整个序列有序。</p><p>下面我们来介绍partition操作的两种实现方法：<strong>左右指针法</strong> 和 <strong>挖坑法</strong>。</p><p><strong>方法一：左右指针法</strong></p><p><strong>基本思路：</strong></p><ul><li>将数组的最后一个数 right 作为基准数 key。</li><li>分区过程：从数组的首元素 begin 开始向后找比 key 大的数（begin 找大）；end 开始向前找比 key 小的数（end 找小）；找到后交换两者（swap），直到 begin &gt;= end 终止遍历。最后将 begin（此时begin == end）和最后一个数交换（ 这个时候 end 不是最后一个位置），即 key 作为中间数（左区间都是比key小的数，右区间都是比key大的数）</li><li>再对左右区间重复第二步，直到各区间只有一个数。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-1aa5092187a082d0.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(nums, left, right);</span><br><span class="line">        Quicksort(nums, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(nums, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left;</span><br><span class="line">    <span class="keyword">int</span> end = right;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end)&#123;</span><br><span class="line">        <span class="comment">// begin找大</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; nums[begin] &lt;= nums[right]) begin++;</span><br><span class="line">        <span class="comment">// end找小</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; nums[end] &gt;= nums[right]) end--;</span><br><span class="line">        swap(nums, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, begin, right);</span><br><span class="line">    <span class="keyword">return</span> begin;       <span class="comment">//返回基准</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组内两个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：挖坑法</strong></p><p><strong>基本思路：</strong></p><ul><li>定义两个指针 left 指向起始位置，right 指向最后一个元素的位置，然后指定一个基准 key（right），作为坑。</li><li>left 寻找比基准（key）大的数字，找到后将 left 的数据赋给 right，left 成为一个坑，然后 right 寻找比基数（key）小的数字，找到将 right 的数据赋给 left，right 成为一个新坑，循环这个过程，直到 begin 指针与 end指针相遇，然后将 key 填入那个坑（最终：key的左边都是比key小的数，key的右边都是比key大的数），然后进行递归操作。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-c3fad33b4cab91ba.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = nums[right]; <span class="comment">// 初始坑</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// left 找大</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= key) left++;</span><br><span class="line">        nums[right] = nums[left]; <span class="comment">// 赋值，然后left作为新坑</span></span><br><span class="line">        <span class="comment">// right找小</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= key) right--;</span><br><span class="line">        nums[left] = nums[right]; <span class="comment">// right作为新坑</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = key;</span><br><span class="line">    <span class="comment">// 将key赋值给left和right的相遇点</span></span><br><span class="line">    <span class="comment">// 保持key的左边都是比key小的数，key的右边都是比key大的数</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(array, left, right);</span><br><span class="line">        Quicksort(array, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(array, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码优化</strong></p><p>我们之前选择基准的策略都是<strong>固定基准</strong>，即固定地选择序列的右边界值作为基准，但如果在待排序列几乎有序的情况下，选择的固定基准将是序列的最大（小）值，快排的性能不好（因为每趟排序后，左右两个子序列规模相差悬殊，大的那部分最后时间复杂度很可能会达到O(n<sup>2</sup>）</p><p>下面提供几种常用的快排优化：</p><p> <strong>优化一：随机基准</strong></p><p>每次随机选取基准值，而不是固定选取左或右边界值。将随机选取的基准值和右边界值进行交换，然后就回到了之前的解法。只需要在 partition 函数前增加如下操作即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> random = (<span class="keyword">int</span>) (left + Math.random() * (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//随机选择 left ~ right 之间的一个位置作为基准</span></span><br><span class="line">swap(array, random, right);</span><br><span class="line"><span class="comment">//把基准值交换到右边界</span></span><br></pre></td></tr></table></figure><p><strong>优化二：三数取中法</strong></p><p> <strong>基本思想：</strong></p><p>取第一个数，最后一个数，第（N/2）个数即中间数，三个数中数值中间的那个数作为基准值。</p><p>举个例子，对于int[] array = { 2，5，4，9，3，6，8，7，1，0}，2、3、0分别是第一个数，第（N/2）个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。 实现getMid函数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三数取中，返回array[left]、array[mid]、array[right]三者的中间者下标作为基准</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMid</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> a = array[left];</span><br><span class="line">    <span class="keyword">int</span> b = array[mid];</span><br><span class="line">    <span class="keyword">int</span> c = array[right];</span><br><span class="line">    <span class="keyword">if</span> ((b &lt;= a &amp;&amp; a &lt;= c) || (c &lt;= a &amp;&amp; a &lt;= b)) &#123; <span class="comment">//a为中间值</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a &lt;= b &amp;&amp; b &lt;= c) || (c &lt;= b &amp;&amp; b &lt;= a)) &#123; <span class="comment">//b为中间值</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a &lt;= c &amp;&amp; c &lt;= b) || (b &lt;= c &amp;&amp; c &lt;= a)) &#123; <span class="comment">//c为中间值</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化三：当待排序序列的长度分割到一定大小后，使用插入排序</strong></p><p>在子序列比较小的时候，直接插入排序性能较好，因为对于有序的序列，插排可以达到O(n)的复杂度，如果序列比较小，使用插排效率要比快排高。</p><p> 实现方式也很简单，快排是在子序列元素个数为 1 时才停止递归，我们可以设置一个阈值n，假设为5，则大于5个元素，子序列继续递归，否则选用插排。<br> 此时QuickSort()函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left &gt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(array, left, right);</span><br><span class="line">        Quicksort(array, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(array, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insertionSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化四：三路划分</strong></p><p>如果待排序列中重复元素过多，也会大大影响排序的性能，这是因为大量相同元素参与快排时，左右序列规模相差极大，快排将退化为冒泡排序，时间复杂度接近O(n2)。这时候，如果采用三路划分，则会很好的避免这个问题。</p><p> 三路划分的思想是利用 partition 函数将待排序列划分为三部分：<strong>第一部分小于基准v，第二部分等于基准v，第三部分大于基准v。</strong>这样在递归排序区间的时候，<strong>我们就不必再对第二部分元素均相等的区间进行快排了</strong>，这在待排序列存在大量相同元素的情况下能大大提高快排效率。</p><p>来看下面的三路划分示意图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-dab14d648daa9ef1.png" alt="img"></p><p><strong>说明：</strong>红色部分为小于基准v的序列，绿色部分为等于基准v的序列，白色部分由于还未被 cur 指针遍历到，属于大小未知的部分，蓝色部分为大于基准v的序列。<br> left 指针为整个待排区间的左边界，right 指针为整个待排区间的右边界。less 指针指向红色部分的最后一个数（即小于v的最右位置），more 指针指向蓝色部分的第一个数（即大于v的最左位置）。cur 指针指向白色部分（未知部分）的第一个数，即下一个要判断大小的位置。</p><p><strong>算法思路：</strong></p><ul><li>由于最初红色和蓝色区域没有元素，初始化 less = left - 1，more = right + 1，cur = left。整个区间为未知部分（白色）。</li><li>如果当前 array[cur] &lt; v，则 swap(array,++less,cur++)，即把红色区域向右扩大一格（less指针后移），把 array[cur] 交换到该位置，cur 指针前移判断下一个数。</li><li>如果当前 array[cur] = v，则不必交换，直接 cur++</li><li>如果当前 array[cur] &gt; v，则 swap(array,–more,cur)，即把蓝色区域向左扩大一格（more指针前移），把 array[cur] 交换到该位置。<strong>特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。</strong></li></ul><p><strong>利用三路划分，我们就可以递归地进行三路快排了！并且可以愉快地避开所有重复元素区间。</strong></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[right]; <span class="comment">//选择右边界为基准</span></span><br><span class="line">        <span class="keyword">int</span> less = left - <span class="number">1</span>; <span class="comment">// &lt; v 部分的最后一个数</span></span><br><span class="line">        <span class="keyword">int</span> more = right + <span class="number">1</span>; <span class="comment">// &gt; v 部分的第一个数</span></span><br><span class="line">        <span class="keyword">int</span> cur = left;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; <span class="number">7</span>more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[cur] &lt; v)&#123;</span><br><span class="line">                swap(array,++less,cur++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[cur] &gt; v)&#123;</span><br><span class="line">                swap(array,--more,cur);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>,more - <span class="number">1</span>&#125;;  <span class="comment">//返回的是 = v 区域的左右下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] p = partition(array,left,right);</span><br><span class="line">            Quicksort(array,left,p[<span class="number">0</span>] - <span class="number">1</span>); <span class="comment">//避开重复元素区间</span></span><br><span class="line">            Quicksort(array,p[<span class="number">1</span>] + <span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p><strong>基本思想</strong></p><p> 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将<strong>已有序</strong>的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p><strong>算法描述</strong></p><ul><li>把长度为 n 的输入序列分成两个长度为 n / 2 的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-0d061316be55799a.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(nums, mid, nums.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序--将两段有序数组结合成一个有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[]  right)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j  = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">            result[k++] = left[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[k++] = right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length)&#123;</span><br><span class="line">        result[k++] = left[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; right.length)&#123;</span><br><span class="line">        result[k++] = right[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p> 归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。</p><p> 归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</p><p><strong>空间复杂度</strong></p><p>归并排序空间复杂度为O(n)</p><p><strong>稳定性</strong></p><p>归并排序是稳定的。</p><p><strong>算法应用</strong></p><p> 归并排序可以用于求解逆序对数量问题，具体见：<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer - 数组中的逆序对</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">        <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将两段有序数组结合成一个有序数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">             <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">             <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">                    result[k++] = left[i++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result[k++] = right[j++];</span><br><span class="line">                     <span class="comment">/*归并同时统计逆序对数量，因为归并的两个子序列都已有序，故当left[i] &gt;  </span></span><br><span class="line"><span class="comment">                     right[j]，有left[i...left.length - 1]均大于right[j]*/</span></span><br><span class="line">                    <span class="keyword">this</span>.cnt = (<span class="keyword">this</span>.cnt % MOD + (left.length - i) % MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">while</span> (i &lt; left.length) &#123;</span><br><span class="line">                result[k++] = left[i++];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">while</span> (j &lt; right.length) &#123;</span><br><span class="line">                result[k++] = right[j++];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        MergeSort(array);</span><br><span class="line">        <span class="keyword">return</span> cnt % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p><strong>基本思想</strong></p><p>堆排序是一种树形选择排序方法，它利用了<strong>堆</strong>这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗<strong>完全二叉树</strong>的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。</p><p><strong>概念</strong></p><p> <strong>堆：</strong>堆是一种<strong>完全二叉树</strong>，且满足所有父节点的值均大于等于（或小于等于）其子节点的值。</p><p> <strong>大根堆（最大堆）：</strong>满足所有父节点的值均大于等于其子节点的值的堆称为大根堆，堆顶元素是堆中元素的最大值。</p><p> <strong>小根堆（最小堆）：</strong>满足所有父节点的值均小于等于其子节点的值的堆称为小根堆，堆顶元素是堆中元素的最小值。</p><p> <strong>堆的顺序存储结构：</strong>使用顺序数据结构（数组）存储堆，表示方法为：</p><ul><li>数组按层序遍历的顺序存放完全二叉树的结点，下标为 0 处为堆顶，下标为 len - 1 处为堆尾。</li><li>结点 i 如果存在左孩子（下标不超过 len - 1 就存在），左孩子的下标为（2 * i + 1）；如果存在右孩子，右孩子的下标为（2 * i + 2）。结点 i 的父结点下标为 (i - 1) / 2 (下标为 0 的结点除外，它没有父结点)。<strong>最后一个非叶子结点即为堆尾元素的父结点，下标为 (len - 1 - 1) / 2 = (len - 2) / 2。</strong></li></ul><p><strong>算法描述</strong></p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-671151d1fa2211f6.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量 用于记录nums的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="comment">// 1.构建大顶堆</span></span><br><span class="line">    buildMaxHeap(nums);</span><br><span class="line">    <span class="comment">// 2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重现调整大顶堆</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        len--; <span class="comment">// 原先的堆尾进入有序区，删除堆尾元素</span></span><br><span class="line">        adjustHeap(nums, <span class="number">0</span>); <span class="comment">// 重新调整大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自顶向下调整以i为根的堆为大顶堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">    <span class="comment">// 如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; len &amp;&amp; nums[<span class="number">2</span> * i + <span class="number">1</span>] &gt; nums[maxIndex]) maxIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果有右子树， 且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt; len &amp;&amp; nums[<span class="number">2</span> * i + <span class="number">2</span>] &gt; nums[maxIndex]) maxIndex = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i)&#123;</span><br><span class="line">        swap(nums, maxIndex, i);</span><br><span class="line">        adjustHeap(nums, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自底向上构建初始大根堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始自底向上构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (len - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        adjustHeap(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组的两个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[len];</span><br><span class="line">    arr[len] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>扩展</strong></p><p><strong>插入元素：</strong>只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。</p><p><strong>删除堆顶元素：</strong>只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可。</p><p><strong>时间复杂度</strong></p><p> 堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。</p><p> 堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</p><p><strong>空间复杂度</strong></p><p> 堆排序使用了常数空间，空间复杂度为O(1)。</p><p><strong>稳定性</strong></p><p> 堆排序是不稳定的。</p><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p> <strong>基本思想</strong></p><p>1959年Shell发明，第一个突破O(n<sup>2</sup>)的排序算法，是直接插入排序的改进版。它与直接插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p><strong>算法描述</strong></p><p>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。<strong>gap初始值一般取 len / 2。</strong></p><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-89239b577fa8a299.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 希尔排序</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">     <span class="keyword">int</span> len = nums.length;</span><br><span class="line">     <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">     <span class="keyword">int</span> current, gap = len / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; ++i)&#123;</span><br><span class="line">             current = nums[i];</span><br><span class="line">             <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">             <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; nums[preIndex] &gt; current)&#123;</span><br><span class="line">                 nums[preIndex + gap] = nums[preIndex];</span><br><span class="line">                 preIndex -= gap;</span><br><span class="line">             &#125;</span><br><span class="line">             nums[preIndex + gap] = current;</span><br><span class="line">         &#125;</span><br><span class="line">         gap /= <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> nums;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p> 希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog2n)，最坏时间复杂度为O(nlog2n)。希尔排序的时间复杂度与增量序列的选取有关。</p><p><strong>空间复杂度</strong></p><p>希尔排序使用了常数空间，空间复杂度为O(1)</p><p><strong>稳定性</strong></p><p> 由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的。</p><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p><strong>基本思想</strong></p><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p> <strong>算法描述</strong></p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-79b756f0ac7b932f.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计数排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">       <span class="keyword">int</span> bias, min = Integer.MIN_VALUE, max = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">           min = Math.min(min, nums[i]);</span><br><span class="line">           max = Math.max(max, nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 计算偏移量，将 min ~ max 映射到 bucket 数组的 0 ~ (max - min) 位置上</span></span><br><span class="line">       bias = -min;</span><br><span class="line">       <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">       Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">           bucket[bucket[i] + bias]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(index &lt; nums.length)&#123;</span><br><span class="line">           <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>)&#123;</span><br><span class="line">               nums[index] = i - bias;</span><br><span class="line">               bucket[i]--;</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</p><p><strong>空间复杂度</strong></p><p> 计数排序空间复杂度为O(k)，k为桶数组的长度。</p><p><strong>稳定性</strong></p><p>计数排序是稳定的。</p><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p> <strong>基本思想</strong></p><p> 桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。按照映射函数将数据分配到不同的桶里，每个桶内元素再分别排序（可能使用别的排序算法），最后拼接各个桶中排好序的数据。<strong>映射函数人为设计，但要保证桶 i 中的数均小于桶 j （i &lt; j）中的数，即必须桶间必须有序，桶内可以无序，可以考虑按照数的区间范围划分桶。下面代码的桶映射函数为：(i - min) / arr.length。</strong></p><p> <strong>算法描述</strong></p><ul><li><p>设置一个定量的数组当作空桶；</p></li><li><p>遍历输入数据，并且把数据一个一个放到对应的桶里去；</p></li><li><p>对每个不是空的桶的桶内元素进行排序（可以使用直接插入排序等）；</p></li><li><p>从不是空的桶里把排好序的数据拼接起来。</p></li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-580b859fbe994d10.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">        min = Math.min(min, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*桶映射函数：自己设计，要保证桶 i 的数均小于桶 j （i &lt; j）的数，</span></span><br><span class="line"><span class="comment">      即必须桶间必须有序，桶内可以无序。这里桶映射函数为：(i - min) / arr.length*/</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / array.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (array[i] - min) / (array.length);</span><br><span class="line">        bucketArr.get(num).add(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; bucketArr.get(i).size();j++) &#123;</span><br><span class="line">           array[k++] = bucketArr.get(i).get(j);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>桶排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n2)。</p><p><strong>空间复杂度</strong></p><p>桶排序空间复杂度为O(n + k)。</p><p><strong>稳定性</strong></p><p>桶排序是稳定的。</p><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p><strong>基本思想</strong></p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><strong>算法描述</strong></p><ul><li>取得数组中的最大数，并取得位数；</li><li>array 为原始数组，从最低位开始取每个位组成 radix 数组；</li></ul><p>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</p><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-d4feaca47e97eaec.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">     <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="comment">//2.进行maxDigit趟分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++,div *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (array[j] / div) % <span class="number">10</span>;</span><br><span class="line">                bucketList.get(num).add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//3.收集</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                    array[index++] = bucketList.get(j).get(k);</span><br><span class="line">                bucketList.get(j).clear();</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>基数排序平均时间复杂度为O(n * k)，最好时间复杂度为O(n * k)，最坏时间复杂度为O(n * k)。</p><p><strong>空间复杂度</strong></p><p>基数排序空间复杂度为O(n + k)。</p><p><strong>稳定性</strong></p><p> 基数排序是稳定的。</p><h3 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h3><p><strong>基本思想</strong></p><p> 简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p><strong>算法描述</strong></p><p>n个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>(n-1)趟结束，数组有序化了。</li></ul><p><strong>动图演示</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2510824-b373a01a7e32ea97.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) <span class="comment">//找到最小的数</span></span><br><span class="line">                    minIndex = j; <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[minIndex]; <span class="comment">//将最小数和无序区的第一个数交换</span></span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>简单选择排序平均时间复杂度为O(n2)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n2)。</p><p><strong>最好情况：</strong>如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n * (n - 1) / 2 次比较。</p><p><strong>最坏情况：</strong>如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n * (n - 1) / 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n - 1)次。<strong>需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。</strong></p><p><strong>空间复杂度</strong><br> 简单选择排序使用了常数空间，空间复杂度为O(1)</p><p><strong>稳定性</strong><br> 简单选择排序不稳定，比如序列 2、4、2、1，我们知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.jianshu.com/p/47170b1ced23">一文搞定十大经典排序算法（Java实现）</a></p><p><a href="https://www.cnblogs.com/mobin/p/5374217.html">堆排序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序算法概述&quot;&gt;&lt;a href=&quot;#排序算法概述&quot; class=&quot;headerlink&quot; title=&quot;排序算法概述&quot;&gt;&lt;/a&gt;排序算法概述&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>2.操作系统-进程管理</title>
    <link href="https://leslieaibin.github.io/2020/11/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2020/11/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2020-11-29T16:15:42.000Z</published>
    <updated>2021-04-28T07:14:31.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h3><p>进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数据）的真正运行实例。</p><p>进程结构一般由3部分组成：<strong>代码段、数据段和堆栈段</strong>。代码段用于存放程序代码数据，数个进程可以共享同一个代码段。数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数的参数，它存放着函数的参数，函数内部定义的局部变量。堆栈段还包括了进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序及数据在处理机执行时所发生的活动</li><li>进程时系统进行资源分配和调度的独立单位。进程的独立运行由进程控制块PCB控制和管理。进程映像时静态的进程。程序段、相关数据、PCB三部分构成了进程映像。</li><li>进程具有动态性（创建、活动、暂停、和终止、具有生命周期），并发性（多个进程在<strong>一段时间</strong>内同时运行），独立性（进程是一个独立运行、获得资源和接受调度的基本单位）、异步性（进程按照独自不可预知的速度前进）、结构性（每个进程都有一个PCB描述）</li></ul><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129200001614.png" alt="image-20201129200001614"></p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p><strong>三种基本状态</strong></p><ul><li><strong>运行态</strong>  占有CPU，并在CPU上运行。单核处理机环境下，每一时刻最多只有一个进程处于运行态。双核环境下可以同时又两个进程处于运行态</li><li><strong>就绪态</strong>  已经具备 运行条件，但由于没有哦空闲CPU，而暂时不能运行。进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。</li><li>**阻塞态 ** 又称等待态，因等待某一时间而暂时不能运行。如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</li></ul><p><strong>另外两种状态</strong></p><ul><li><strong>创建态</strong>  进程正在被创建，操作系统为进程分配资源 初始化PCB</li><li>**终止态 **  进程正在从系统中撤销，操纵系统会回收进程拥有的资源，撤下PCB</li></ul><h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129202447277.png" alt="image-20201129202447277"></p><h3 id="原语实现对进程的控制"><a href="#原语实现对进程的控制" class="headerlink" title="原语实现对进程的控制"></a>原语实现对进程的控制</h3><p><strong>进程控制：</strong> 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简化理解：反正进程控制就是要实现进程状态转换</p><p>用原语实现进程控制。源于的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即云子操作。原语采用“关中断指令”和”开中断指令”实现</p><p>显然，关/开中断指令的权限非常大，必然只允许在核心态执行的特权指令</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129203151073.png" alt="image-20201129203151073"></p><h3 id="进程控制的五种原语"><a href="#进程控制的五种原语" class="headerlink" title="进程控制的五种原语"></a>进程控制的五种原语</h3><p>学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</p><ul><li><p>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）</p><ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复期运行环境</li></ul></li><li><p>将PCB插入合适的队列</p></li><li><p>分配/回收资源</p></li></ul><p><strong>进程的创建原语</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20200315163724449.png" alt="在这里插入图片描述"></p><p><strong>进程的终止原语</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129204154402.png" alt="image-20201129204154402"></p><p><strong>进程的阻塞和唤醒</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129204332368.png" alt="image-20201129204332368"></p><p><strong>进程切换原语</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129204418402.png" alt="image-20201129204418402"></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>顾名思义，进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法</p><p><strong>共享存储</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129205215962.png" alt="image-20201129205215962"></p><p><strong>管道通信</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129205333396.png" alt="image-20201129205333396"></p><p><strong>消息传递</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129205444441.png" alt="image-20201129205444441"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129210311586.png" alt="image-20201129210311586"></p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>可以把线程理解为“轻量级进程线程” 是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。线程则作为处理机的分配单元。</p><h3 id="线程带来的变化"><a href="#线程带来的变化" class="headerlink" title="线程带来的变化"></a>线程带来的变化</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129211655148.png" alt="image-20201129211655148"></p><h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（PCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><h4 id="用户级线程与多对一模型"><a href="#用户级线程与多对一模型" class="headerlink" title="用户级线程与多对一模型"></a>用户级线程与多对一模型</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129212738423.png" alt="image-20201129212738423"></p><p>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户线程对用户不透明，对操作系统透明）可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”</p><p><strong>多对一模型：</strong></p><p>多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><p><strong>优点：</strong>用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p><strong>缺点：</strong>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><h4 id="内核级线程与一对一模型"><a href="#内核级线程与一对一模型" class="headerlink" title="内核级线程与一对一模型"></a>内核级线程与一对一模型</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129213319676.png" alt="image-20201129213319676"></p><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”</p><p><strong>一对一模型：</strong></p><p>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p><strong>优点：</strong>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p><strong>缺点：</strong>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><h4 id="特殊的组合方式与多对多模型"><a href="#特殊的组合方式与多对多模型" class="headerlink" title="特殊的组合方式与多对多模型"></a>特殊的组合方式与多对多模型</h4><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129213712898.png" alt="image-20201129213712898"></p><p>重点重点重点：</p><p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><p>例如：左边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</p><p><strong>多对多模型：</strong>n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><h1 id="处理机的调度"><a href="#处理机的调度" class="headerlink" title="处理机的调度"></a>处理机的调度</h1><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><h2 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h2><h3 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220048583.png" alt="image-20201129220048583"></p><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p><p><strong>高级调度（作业调度）</strong>。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</p><p>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p><h3 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220512620.png" alt="image-20201129220512620"></p><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p><p>这么做的目的是为了提高内存利用率和系统吞吐量。暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。<br>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p><h3 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220656794.png" alt="image-20201129220656794"></p><p>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><h3 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220739706.png" alt="image-20201129220739706"></p><h3 id="三层调度的联系与对比"><a href="#三层调度的联系与对比" class="headerlink" title="三层调度的联系与对比"></a>三层调度的联系与对比</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220929694.png" alt="image-20201129220929694"></p><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129221959790.png" alt="image-20201129221959790"></p><h3 id="进程的切换和过程"><a href="#进程的切换和过程" class="headerlink" title="进程的切换和过程"></a>进程的切换和过程</h3><p><strong>“狭义的进程调度”与“进程切换”的区别：</strong></p><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p><p>进程切换的过程主要完成了：</p><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复<br>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ul><p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="先来先服务——FCFS"><a href="#先来先服务——FCFS" class="headerlink" title="先来先服务——FCFS"></a>先来先服务——FCFS</h3><ul><li>FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度</li><li>FCFS是不可剥夺算法，长作业会使后到的短作业长期等待</li><li>算法简单，效率低，对长作业有利，有利于CPU繁忙性工作</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129223227492.png" alt="image-20201129223227492"></p><h3 id="短作业优先——SJF"><a href="#短作业优先——SJF" class="headerlink" title="短作业优先——SJF"></a>短作业优先——SJF</h3><ul><li>从后备队列中选择一个或若干个估计运行时间最短的作业掉入内存运行</li><li>对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129223802686.png" alt="image-20201129223802686"></p><h3 id="高响应比优先—HRRN"><a href="#高响应比优先—HRRN" class="headerlink" title="高响应比优先—HRRN"></a>高响应比优先—HRRN</h3><ul><li>该算法是对FCFS和SJF算法的一种平衡，计算每个作业的响应比</li><li>响应比的计算为（等待时间 + 要求服务时间）/要求服务时间</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129223954712.png" alt="image-20201129223954712"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130195616108.png" alt="image-20201130195616108"></p><h3 id="时间片轮转调度算法（RR）"><a href="#时间片轮转调度算法（RR）" class="headerlink" title="时间片轮转调度算法（RR）"></a>时间片轮转调度算法（RR）</h3><ul><li><p>时间片轮转算法适用于分时系统，系统讲所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms</p></li><li><p>受系统响应时间影响，队列进程数目，进程长短影响较大</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130195840641.png" alt="image-20201130195840641"></p><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><ul><li>优先级调度算法每次从后备队列中选取优先级最高的一个或几个作业</li><li>优先级调度可以剥夺时占有，也可以非剥夺式占有</li></ul><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><ul><li>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展</li></ul><ol><li>设置多个就绪队列，为各个队列赋予优先级，1，2，3等</li><li>赋予各个队列中时间片大小不同，优先级高时间片越小</li><li>一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入耳机队列的末尾，依次向下执行。</li><li>仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推</li></ol><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130200117865.png" alt="image-20201130200117865"></p><h1 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h1><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ul><li><code>同步也称为直接制约关系。</code></li><li>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。</li><li>一个简单的例子来理解这个概念。</li><li>例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有<code>异步性</code>,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</li></ul><h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><ul><li><code>互斥，亦称间接制约关系</code>。<code>进程互斥</code>指当一个进程访问某临界资源时，另一个想要访问该<code>临界资源</code>的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li><li>在这里需复习一下<code>临界资源</code>的概念。</li><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。</li></ul><p><strong>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</strong></p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个整形变量，可以被定义为两个标准的原语wait(S),signal(S)即P，V操作</p><ul><li>P操作 如果信号量大于0， 执行-1操作，如果等于0，执行等待信号量大于0</li><li>V操作 对信号量完成加1操作，唤醒睡眠的进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore mutex &#x3D; 1 </span><br><span class="line">void P1()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">void P2()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块</p><ul><li>使用信号量机制时，进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。</li><li>管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用</li><li>引入管程的目的：1. 把分散在各进程中的临界区集中起来进行管理；2. 防止进程有意无意的违反同步操作;3. 便于高级语言程序书写和验证。</li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品</p><p>由于缓冲区输入临界资源，需要一个互斥量mutex来完成缓冲区的互斥访问</p><p>为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># define N 100</span><br><span class="line">typedef int semahpore</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">semaphore empty &#x3D; N;</span><br><span class="line">semaphore full &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void producer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        int item &#x3D; produceItem();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Item.push(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        int item &#x3D; Item.top();</span><br><span class="line">        Item.pop();</span><br><span class="line">        consume(item);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(&amp;empty())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行</p><p>用一个count表示读进程数量，分别用read_mutex 和write_mutex 作为读锁和写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore count &#x3D; 0;</span><br><span class="line">semaphore read_mutex &#x3D; 1;</span><br><span class="line">semaphore write_mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void read()&#123;</span><br><span class="line">    P(&amp;read_mutex);</span><br><span class="line">    count++;</span><br><span class="line">    if(count&#x3D;&#x3D;1) P(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">    read();</span><br><span class="line">    p(&amp;read_mutex);</span><br><span class="line">    count--;</span><br><span class="line">    if(count&#x3D;&#x3D;0) V(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write()&#123;</span><br><span class="line">    P(&amp;write_mutex);</span><br><span class="line">    write();</span><br><span class="line">    V(&amp;write_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根</p><p>如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore chop[5] &#x3D; &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void process()&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        P(chop[i]);</span><br><span class="line">        P(chop[(i+1)%5]);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chop[i]);</span><br><span class="line">        V(chop[(i+1)%5]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是<strong>死锁</strong>，发生死锁后若无外力干涉，这些进程都将无法向前推进。</p><h2 id="死锁、饥饿、死循环区别"><a href="#死锁、饥饿、死循环区别" class="headerlink" title="死锁、饥饿、死循环区别"></a>死锁、饥饿、死循环区别</h2><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130202012613.png" alt="image-20201130202012613"></p><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><strong>互斥条件：</strong>只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件：</strong>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件：</strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件：</strong>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><h2 id="什么时候发生死锁"><a href="#什么时候发生死锁" class="headerlink" title="什么时候发生死锁"></a>什么时候发生死锁</h2><ul><li><p>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</p></li><li><p>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁例如，并发执行的进程P1<br>P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程2又申请资源1两者会因为申请的资源被对方占有而阻塞，从而发生死锁</p></li><li><p>信号量的使用不当也会造成死锁如生产者消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p></li></ul><p>总之，对不可剥夺资源的不合理分配，可能导致死锁</p><h2 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h2><ul><li><p>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</p></li><li><p>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</p></li><li><p>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p></li></ul><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130203852543.png" alt="image-20201130203852543"></p><h4 id="不剥夺条件"><a href="#不剥夺条件" class="headerlink" title="不剥夺条件"></a>不剥夺条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130203808687.png" alt="image-20201130203808687"></p><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130211744625.png" alt="image-20201130211744625"></p><h4 id="破坏循环条件"><a href="#破坏循环条件" class="headerlink" title="破坏循环条件"></a>破坏循环条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130211807469.png" alt="image-20201130211807469"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p><p>下面我们通过“破坏”第四个死锁条件，来解决第一个小节中的死锁示例并证明我们的结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程a获取到integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取Integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程b获取到Integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">线程a获取到integer.class</span><br><span class="line">线程b尝试获取Integer.class</span><br><span class="line">线程b获取到Integer.class</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于已经不存在线程a持有线程b需要的锁，而线程b持有线程a需要的锁的逻辑了，所以Demo顺利执行完毕。</p><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130212101903.png" alt="image-20201130212101903"></p><h4 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130212121587.png" alt="image-20201130212121587"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Video Analysis 相关领域</title>
    <link href="https://leslieaibin.github.io/2020/11/24/Video%20Analysis%20%E7%9B%B8%E5%85%B3%E9%A2%86%E5%9F%9F/CV%E4%BB%BB%E5%8A%A1/"/>
    <id>https://leslieaibin.github.io/2020/11/24/Video%20Analysis%20%E7%9B%B8%E5%85%B3%E9%A2%86%E5%9F%9F/CV%E4%BB%BB%E5%8A%A1/</id>
    <published>2020-11-23T16:15:42.000Z</published>
    <updated>2020-11-24T07:46:05.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Action-Recognition-行为识别"><a href="#Action-Recognition-行为识别" class="headerlink" title="Action Recognition(行为识别)"></a>Action Recognition(行为识别)</h1><p>也可以叫  <strong>Action Classification</strong> </p><h2 id="任务目的"><a href="#任务目的" class="headerlink" title="任务目的"></a>任务目的</h2><p>给一个视频片段进行分类，类别通常是各类人的动作</p><h2 id="任务特点"><a href="#任务特点" class="headerlink" title="任务特点"></a>任务特点</h2><p>简化了问题，一般使用的数据库都先将动作分割好了，一个视频片断中包含一段明确的动作，时间较短（几秒钟）且有唯一确定的label。所以也可以看作是输入为视频，输出为动作标签的多分类问题。此外，动作识别数据库中的动作一般都比较明确，周围的干扰也相对较少（不那么real-world）。有点像图像分析中的Image Classification任务。</p><h2 id="难点-关键点"><a href="#难点-关键点" class="headerlink" title="难点/关键点"></a>难点/关键点</h2><ul><li>强有力的特征：即如何在视频中提取出能更好的描述视频判断的特征。特征越强，模型的效果通常较好。</li><li>特征的编码（encode）/融合（fusion）：这一部分包括两个方面，第一个方面是非时序的，在使用多种特征的时候如何编码/融合这些特征以获得更好的效果；另外一个方面是时序上的，由于视频很重要的一个特性就是其时序信息，一些动作看单帧的图像是无法判断的，只能通过时序上的变化判断，所以需要将时序上的特征进行编码或者融合，获得对于视频整体的描述。</li><li>算法速度：虽然在发论文刷数据库的时候算法的速度并不是第一位的。但高效的算法更有可能应用到实际场景中去。</li></ul><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>行为识别的数据库比较多，这里主要介绍两个最常用的数据库，也是近年这个方向的论文必做的数据库。</p><ul><li>UCF101:来源为YouTube视频，共计101类动作，13320段视频。共有5个大类的动作：1)人-物交互；2)肢体运动；3)人-人交互；4)弹奏乐器；5)运动。数据库主页为：<a href="https://www.crcv.ucf.edu/data/UCF101.php">UCF101</a>。文章的题图为UCF各类视频的示意图。</li><li>HMDB51:来源为YouTube视频，共计51类动作，约7000段视频。数据库主页为：<a href="https://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/">HMDB51</a></li></ul><p>在Actioin Recognition中，实际上还有一类骨架数据库，比如MSR Action 3D，HDM05，SBU Kinect Interaction Dataset等。这些数据库已经提取了每帧视频中人的骨架信息，基于骨架信息判断运动类型。不做详细介绍</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><a href="https://github.com/jinwchoi/awesome-action-recognition">Action Recognition方法</a></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124105621642.png" alt="image-20201124105621642"></p><h1 id="Temporal-Action-Proposals（时间行动建议）"><a href="#Temporal-Action-Proposals（时间行动建议）" class="headerlink" title="Temporal Action Proposals（时间行动建议）"></a>Temporal Action Proposals（时间行动建议）</h1><h2 id="任务目的-1"><a href="#任务目的-1" class="headerlink" title="任务目的"></a>任务目的</h2><p>Temporal Action Proposal任务不需要对活动分类，只需要找出proposals,主要目的是将长视频根据语义分割成多个segment。所以判断找的temporal proposals全不全就可以测评方法好坏，常用average recall (AR) ，Average Recall vs. Average Number of Proposals per Video (AR-AN) 即曲线下的面积(ActivityNet Challenge 2017就用这个测评此项任务)。如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/uniform_random_proposal_performance.png" alt="img"></p><h2 id="任务特点-1"><a href="#任务特点-1" class="headerlink" title="任务特点"></a>任务特点</h2><p>为了适应视频数据集的特点，好的action proposal应该具有如下的特点：</p><ol><li>能够高效地表示一个视频间隔（temporal segment），计算开销小。</li><li>将可能具有action的视频间隔（temporal segment）找出来。</li><li>初步识别出视频间隔中的动作是否为我们感兴趣的动作类别之一。</li></ol><h2 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h2><p>目前使用比较广泛的数据集为ActivityNet-1.3（2016年发布）以及早些年的一个相对较小的数据集THUMOS14。</p><p>THUMOS14是一个包含action recognition和action localization任务的比赛，其中训练集是trimmed UCF101，所以训练集不能被用来训练action proposal网络。验证集集有1010个视频，测试集有1574个视频。但是验证集中只有200个视频有temporal label，测试集中只有212个。一般情况下，大家使用验证集来训练action proposal网络，然后在测试集上查看效果。</p><p>用于训练的验证集上每个类别平均有150个动作时序标注，每个动作平均的持续时间为4.04秒。一共有3007个动作时序标注，标注了的动作共持续12159.8秒。测试集上的每个类别平均有167.9个动作时序标注，每个动作平均的持续时间为4.47秒，标注了的动作共持续15040。3秒。验证集上不同类别的标注个数及平均动作持续时间如下图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-d323e3a24d32ee79dcb862f39740f1ea_720w.jpg" alt="img"></p><p>ActivityNet-1.3共有200个类别，训练集有10024个视频，验证集有4926个视频，测试集有5044个视频。官方提供的视频分辨率为320x240，除了视频之外还提供了按照5FPS 使用的代码，以及使用ResNet-152在抽好的帧上提取的feature。一般来说对于Action Proposal需要在提供的帧上进行实验，或者为了更好地利用标注也可以自己进行密集抽帧。</p><p>就标注来看，共有23065个动作时序标注，平均每个视频有1.15个时序标注。视频的平均时长为128秒，标注的平均时长为49.2秒。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-ab716c73c416fdfc9fe84ad3219bab28_720w.jpg" alt="img">时序动作标注长度分布图</p><p>就类别分布来看，平均每个类别有115个标注，平均每个类别的动作持续时间为51.3秒。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-62bd5ac0bf060e9bed1fe6ef92cf4212_720w.jpg" alt="img">类别动作持续时间图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201123211330471.png" alt="image-20201123211330471"></p><p><strong>ActivityNet 任务的提交格式</strong></p><h1 id="Temporal-Action-Localization-（时序动作定位）"><a href="#Temporal-Action-Localization-（时序动作定位）" class="headerlink" title="Temporal Action Localization （时序动作定位）"></a>Temporal Action Localization （时序动作定位）</h1><p>也可以叫 <strong>Temporal Action Detection （时序行为检测）</strong> </p><h2 id="任务目的-2"><a href="#任务目的-2" class="headerlink" title="任务目的"></a>任务目的</h2><p>给定一段未分割的长视频，算法需要检测视频中的行为片段（action instance），包括其<strong>开始时间、结束时间以及类别</strong>。一段视频中可能包含一个或多个行为片段。</p><p>(1) temporal action proposal generation: 即进行时序动作提名，产生候选的视频时序片段，即相当于Faster-RCNN中的RPN网络的作用；</p><p>(2) action classification: 即判断候选视频时序片段的动作类别。两个部分结合在一起，即实现了视频中的时序动作检测。目前视频分类算法的精度其实以及比较高了，然而时序检测的效果依旧比较低，主要的性能瓶颈在于时序提名环节。</p><h2 id="任务特点-2"><a href="#任务特点-2" class="headerlink" title="任务特点"></a>任务特点</h2><ul><li><p><strong>特点1</strong></p><p><strong>action recognition</strong>与<strong>temporal action detection</strong>之间的关系同 <strong>image classfication</strong>与 <strong>object detection</strong>之间的关系非常像。基于image classification问题，发展出了许多强大的网络模型（比如ResNet,VGGNet等），这些模型在object detection的方法中起到了很大的作用。同样，action recognition的相关模型（如2stream，C3D, iDT等)也被广泛的用在temporal action detection的方法中。</p></li><li><p><strong>特点2</strong></p><p>由于temporal action detection和object detection之间存在一定的相似性，所以很多temporal action detection方法都采用了与一些object detection方法相似的框架（最常见的就是参考R-CNN系列方法）。具体的会在后面的论文介绍中讲到。</p></li></ul><h2 id="难点-关键点-1"><a href="#难点-关键点-1" class="headerlink" title="难点/关键点"></a>难点/关键点</h2><ul><li><p><strong>难点1</strong></p><p>在目标检测中，物体目标的边界通常都是非常明确的，所以可以标注出较为明确的边界框。但时序行为的边界很多时候并不是很明确，什么时候一个行为算开始，什么时候行为算结束常常无法给出一个准确的边界（指精确的第几帧）。</p></li><li><p><strong>难点2</strong></p><p>只使用静态图像的信息，而不结合时序信息在行为识别中是可以的（虽然结合时序信息效果会更好）。但在时序行为检测中，是无法只使用静态图像信息的。必须结合时序的信息，比如使用RNN读入每帧图像上用CNN提取的特征，或是用时序卷积等。</p></li><li><p><strong>难点3</strong></p><p>时序行为片段的时间跨度变化可能非常大。比如在ActivityNet中，最短的行为片段大概1s左右，最长的行为片段则超过了200s。巨大的时长跨度，也使得检测时序动作非常难。</p></li></ul><p><strong>任务关键点</strong></p><p>我认为设计一个好的时序行为检测方法的关键主要在于以下两点：</p><ul><li><p>高质量的时序片段（<strong>Proposals</strong>）：很多方法都是使用<strong>Proposal + classification</strong>的框架。对于这类方法，重要的是较高的proposal质量（即在保证平均召回率的情况下，尽可能减少proposal的数量）。此外，对于所有方法，获取准确的时序行为边界都是非常重要的。</p></li><li><p>准确的分类（<strong>Classification</strong>）：即能准确的得到时序行为片段的类别信息。这里通常都会使用行为识别中的一些方法与模型。</p></li></ul><h2 id="数据集-2"><a href="#数据集-2" class="headerlink" title="数据集"></a>数据集</h2><p>时序行为检测的数据库也有很多，下面主要介绍几个常用的主流数据库：</p><ul><li><strong>THUMOS 2014</strong>：该数据集即为THUMOS Challenge 2014，地址为<a href="http://crcv.ucf.edu/THUMOS14/">THUMOS 2014</a>。该数据集包括行为识别和时序行为检测两个任务。它的训练集为UCF101数据集，包括101类动作，共计13320段分割好的视频片段。THUMOS2014的验证集和测试集则分别包括1010和1574个未分割过的视频。在时序行为检测任务中，只有20类动作的未分割视频是有时序行为片段标注的，包括200个验证集视频（包含3007个行为片段）和213个测试集视频（包含3358个行为片段）。这些经过标注的未分割视频可以被用于训练和测试时序行为检测模型。实际上之后还有THUMOS Challenge 2015,包括更多的动作类别和视频数，但由于上面可以比较的方法不是很多，所以目前看到的文章基本上还是在THUMOS14上进行实验。</li><li><strong>MEXaction2</strong>：MEXaction2数据集中包含两类动作：骑马和斗牛。该数据集由三个部分组成：YouTube视频，UCF101中的骑马视频以及INA视频，数据集地址为<a href="http://mexculture.cnam.fr/xwiki/bin/view/Datasets/Mex+action+dataset">MEXaction2</a> 。其中YouTube视频片段和UCF101中的骑马视频是分割好的短视频片段，被用于训练集。而INA视频为多段长的未分割的视频，时长共计77小时，且被分为训练，验证和测试集三部分。训练集中共有1336个行为片段，验证集中有310个行为片段，测试集中有329个行为片断。且MEXaction2数据集的特点是其中的未分割视频长度都非常长，被标注的行为片段仅占视频总长的很低比例</li><li><strong>ActivityNet</strong>: 目前最大的数据库，同样包含分类和检测两个任务。数据集地址为<a href="http://activity-net.org/">Activity Net</a> ，这个数据集仅提供视频的youtube链接，而不能直接下载视频，所以还需要用python中的youtube下载工具来自动下载。该数据集包含200个动作类别，20000（训练+验证+测试集）左右的视频，视频时长共计约700小时。由于这个数据集实在太大了，我的实验条件下很难完成对其的实验，所以我之前主要还是在THUMOS14和MEXaction2上进行实验。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201123203536610.png" alt="image-20201123203536610"></p><p><strong>ActivityNet 任务的提交格式</strong></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124110351933.png" alt="image-20201124110351933"></p><h1 id="Temporal-Action-Parsing-TAP-时态动作解析"><a href="#Temporal-Action-Parsing-TAP-时态动作解析" class="headerlink" title="Temporal Action Parsing (TAP) (时态动作解析)"></a>Temporal Action Parsing (TAP) (时态动作解析)</h1><p>相关论文《Intra- and Inter-Action Understanding via Temporal Action Parsing》</p><h2 id="相关数据集Datasets"><a href="#相关数据集Datasets" class="headerlink" title="相关数据集Datasets"></a>相关数据集Datasets</h2><ol><li>only class labels：<ul><li>KTH, Weizmann, UCFSports, Olympic</li><li>UCF101, HMDB51, Sports1M, Kinetics</li></ul></li><li>boundaries of actions in untrimmed video:<ul><li>THUMOS’15, ActivityNet, Charades, HACS, AVA</li></ul></li><li>finegrained annotations for action instances(author’s): 动作实例的细粒度注释<ul><li>Salads, Breakfast, <strong>MPIICooking, JIGSAWS</strong></li></ul></li></ol><p>为2020年CVPR 商汤等新提出的任务，在一段动作视频中，定义一连串子动作（sub-action），动作解析即定位这些子动作的开始帧。该任务可更好的进行动作间和动作内部的视频理解。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul><li>对动作实例的内部结构的详细了解，特别是在时间维度上（TAP/TAS）<ul><li>TAP仅提供了子动作之间的边界，而这些边界的监督作用却明显较弱</li><li>TAS的目标是在一组预定义的子动作中标记动作实例的每一个框架，这些子动作可以在一个监督下完成</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201123213225627.png" alt="image-20201123213225627"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124102457517.png" alt="image-20201124102457517"></p><p>特点：  每个未剪辑的视频类别是一样的，子动作的边界给出，但是没有给出子动作的类比</p><h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124104217442.png" alt="image-20201124104217442"></p><p>动作边界检测。我们借助于序列模型，特别是时间卷积网络(TCN)，来估计动作状态变化的出现。给定一个T帧片段，在顶部构建一个两层时间卷积网络来密集预测每个帧的标量。接下来，带注释的时间边界及其k个相邻帧被标记为1，其余的被设置为0。由于正样本(即子动作变化点)和负样本之间的不平衡，使用加权二进制交叉熵损失来优化网络。在推断期间，一旦输出超过某个阈值θc，例如0.5，就检测到子动作。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124104510876.png" alt="image-20201124104510876">\</p><p>弱监督时间动作分割。时间动作分割旨在用一组预定义的子动作来标记动作实例的每个帧。在弱监督设置中，仅提供按发生顺序排列的子动作列表，而没有精确的时间位置。我们通过迭代软边界分配(ISBA)  [6]和连接主义时间建模(CTM) [18]选择了两个有代表性的方法。对于ISBA，我们通过提取帧级特征{ fi } N i =  1并将它们预分组为K个簇来生成伪标签。对CTM来说，最初的训练目标是最大化预定义目标标记的对数似然性。在我们的例子中，损失被改变为所有可能标签的对数似然的和，因为所有k个有区别的随机抽样子动作可能是一个可能的解决方案。在推断过程中，我们使用简单的最佳路径解码，即在每个时间戳连接最活跃的输出。</p><h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124103739413.png" alt="image-20201124103739413"></p><p>输出的是每个子动作的开始帧  用于评测的是召回率，精确率，f1分数</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/26603387">Video Analysis</a></p><p><a href="https://zhuanlan.zhihu.com/p/32265681">视频分析入门之 Action Proposal</a></p><p><a href="https://zhuanlan.zhihu.com/p/80333569">Action Proposal &amp; Boundary系列</a></p><p><a href="https://pianshen.com/article/36421969810/">TAPOS论文分享</a></p><p><a href="https://zhuanlan.zhihu.com/p/75444151">边界匹配网络详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/39327364">用于时序动作提名生成的边界敏感网络</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Action-Recognition-行为识别&quot;&gt;&lt;a href=&quot;#Action-Recognition-行为识别&quot; class=&quot;headerlink&quot; title=&quot;Action Recognition(行为识别)&quot;&gt;&lt;/a&gt;Action Recogniti</summary>
      
    
    
    
    <category term="Video Analysis" scheme="https://leslieaibin.github.io/categories/Video-Analysis/"/>
    
    
    <category term="Video Analysis" scheme="https://leslieaibin.github.io/tags/Video-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>1.操作系统-操作系统概述</title>
    <link href="https://leslieaibin.github.io/2020/11/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://leslieaibin.github.io/2020/11/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-11-21T16:15:42.000Z</published>
    <updated>2021-04-28T07:14:20.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统举例"><a href="#操作系统举例" class="headerlink" title="操作系统举例"></a>操作系统举例</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2020022012313767.png" alt="在这里插入图片描述"></p><h2 id="操作系统的层次结构"><a href="#操作系统的层次结构" class="headerlink" title="操作系统的层次结构"></a>操作系统的层次结构</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121211023859.png" alt="image-20201121211023859"></p><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><ul><li>是系统最基本最核心的软件，属于系统软件</li><li>控制和管理整个计算机的硬件和软件资源</li><li>合理的组织、调度计算机的工作与资源分配</li><li>为用户和其他软件提供方便的接口和环境</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121212138580.png" alt="image-20201121212138580"></p><h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121212425015.png" alt="image-20201121212425015"></p><h3 id="计算机系统资源的管理者"><a href="#计算机系统资源的管理者" class="headerlink" title="计算机系统资源的管理者"></a>计算机系统资源的管理者</h3><ul><li><p>处理机管理（进程管理）</p></li><li><p>存储器管理（内存）</p></li><li><p>文件管理（文件系统）</p></li><li><p>设备管理（I/O）</p></li></ul><h4 id="处理机管理-进程管理"><a href="#处理机管理-进程管理" class="headerlink" title="处理机管理(进程管理)"></a>处理机管理(进程管理)</h4><p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归纳为进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁通信、处理机调度等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121214558742.png" alt="image-20201121214558742"></p><h4 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h4><p>为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存的<strong>分配与回收、地址映射、内存保护与共享和内存扩充</strong>等功能。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121230607457.png" alt="image-20201121230607457"></p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>计算机中所有的信息都是以文件的形式存在的，操作票系统中负责文件管理的部分称为文件系统，文件管理包括<strong>文件存储空间的管理、目录管理及文件读写管理和保护</strong>等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121230956206.png" alt="image-20201121230956206"></p><h4 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h4><p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓<strong>存管理、设备分配、设备处理和虚拟设备</strong>等功能。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121231235672.png" alt="image-20201121231235672"></p><p><strong>以上4种管理功能都由“工人”负责，“雇主”无序关注。</strong></p><h3 id="用户与计算机硬件系统之间的接口"><a href="#用户与计算机硬件系统之间的接口" class="headerlink" title="用户与计算机硬件系统之间的接口"></a>用户与计算机硬件系统之间的接口</h3><ul><li><p>为了让用户方便、快捷、可靠的操作计算机硬件并执行自己的程序，操作系统提供了用户接口</p></li><li><p>操作系统提供的接口分为两类：<code>命令接口和程序接口</code></p><ul><li><strong>命令接口</strong>：用户可以<strong>直接</strong>使用的，利用这些操作命令来组织和控制作业的执行</li><li><strong>程序接口</strong>：用户通过程序<strong>间接</strong>使用的，编程人员可以使用它们来请求操作系统服务</li></ul></li></ul><h4 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h4><p>用户利用这些命令来组织和控制作业的运行</p><ul><li><p>联机命令接口： 又称交互式命令接口，适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121232243498.png" alt="image-20201121232243498"></p></li><li><p>脱机命令接口： 又称批处理命令接口，使用于批处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令。在操作系统运行这些命令时用户不可干预。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121232546065.png" alt="image-20201121232546065"></p></li></ul><h4 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h4><p>由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用请求操作系统为其提供服务，只能通过用户程序间接调用，如使用各种外部设备、申请分配和回收内存及其他各种要求</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121233121560.png" alt="image-20201121233121560"></p><h3 id="作为扩充机器（虚拟机）"><a href="#作为扩充机器（虚拟机）" class="headerlink" title="作为扩充机器（虚拟机）"></a>作为扩充机器（虚拟机）</h3><p>没有任何软件支持的计算机称为<strong>裸机</strong>，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器：因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p><h1 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h1><p>操作系统是一种系统软件，但与其它系统软件和应用软件有很大的不同，它有自己的特殊性，及基本特征。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121234036988.png" alt="image-20201121234036988"></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>并发</strong>：两个或多个时间在同一时间间隔内发生，这些时间在宏观上是同时发生的，在微观上是交替发生的，操作系统的并发性指系统中同时存在着多个运行的程序。</p><p><strong>并行</strong>：两个或多个时间在同一时刻发生</p><ul><li>一个单核(CPU)同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</li><li>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的</li><li>在如今的计算机中，一般都是多核cpu的，即在同一<strong>时刻</strong>可以并行执行多个程序，比如我的计算机是8核的，我的计算机可以在同一时刻并行执行8个程序，但是事实上我们计算机执行的程序并不止8个，因此并发技术是必须存在的，并发性必不可少。</li></ul><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>资源共享即共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用，共享分为两类：<strong>互斥共享和同时共享</strong></p><h3 id="互斥共享"><a href="#互斥共享" class="headerlink" title="互斥共享"></a>互斥共享</h3><ul><li>计算机中的某个资源在一段时间内只能允许<code>一个进程</code>访问，别的进程没有使用权</li><li>临界资源(独占资源)：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享</li><li>举个例子：比如QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li></ul><h3 id="同时共享"><a href="#同时共享" class="headerlink" title="同时共享"></a>同时共享</h3><ul><li>计算机中的某个资源在在一段时间内可以<code>同时</code>允许<code>多个</code>进程访问</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，<strong>分时共享</strong></li><li>这里的<code>同时</code>指在宏观上是同时的，在微观上是交替进行访问的，只是cpu处理速度很快，我们感觉不到，在宏观上感觉是在同时进行</li><li>举个例子：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行访问磁盘的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li><strong>注意</strong>：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul><h3 id="并发性和共享性互为存在条件"><a href="#并发性和共享性互为存在条件" class="headerlink" title="并发性和共享性互为存在条件"></a>并发性和共享性互为存在条件</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122000214611.png" alt="image-20201122000214611"></p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。 物理实体（前者） 是实际存在的， 而逻辑上<br>对应物（后者） 是用户感受到的。  </p><p>多道程序设计：是指在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。</p><ul><li>虚拟是把一个物理上的实体变为若干逻辑上的对应物。</li><li>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</li><li>虚拟技术：用于实现虚拟的技术</li><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的</li><li>操作系统的虚拟技术科归纳为：<ul><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟存储器</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122000457368.png" alt="image-20201122000457368"></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步是指， 在多道程序环境下， 允许多个程序并发执行， 但由于资源有限， 进程的执行不是一贯到底的，<br>而是走走停停， 以不可预知的速度向前推进， 这就是进程的异步性。  </p><ul><li>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</li></ul><p>如果失去了并发性， 即系统只能串行地运行各个程序， 那么每个程序的执行会一贯到底。 只有系统拥有并发性， 才有可能导致异步性。  </p><h1 id="操作系统分类和发展"><a href="#操作系统分类和发展" class="headerlink" title="操作系统分类和发展"></a>操作系统分类和发展</h1><h2 id="操作系统的分类及其特征优劣"><a href="#操作系统的分类及其特征优劣" class="headerlink" title="操作系统的分类及其特征优劣"></a>操作系统的分类及其特征优劣</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20200222160313682.png" alt="在这里插入图片描述"></p><h2 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122003006007.png" alt="image-20201122003006007"></p><h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><h2 id="两种命令"><a href="#两种命令" class="headerlink" title="两种命令"></a>两种命令</h2><ul><li><p>特权指令</p><p>不允许用户直接使用的命令，比如：I/O令、置中断指令、存取用于内存保护的寄存器、送程序状态字到程序状态寄存器，内存清零等的指令</p></li><li><p>非特权指令</p><p>加减乘除等普通运算指令</p></li></ul><h2 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h2><ul><li><p>核心态(管态)</p><p>特权指令和非特权指令都可执行</p></li><li><p>用户态(目态)</p><p>只能执行非特权指令</p></li></ul><h2 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h2><ul><li><p>内核程序（管理程序）</p><p>操作系统内核程序是系统管理，特权指令和非特权指令都可执行，运行在核心态</p></li><li><p>用户持续（应用程序）</p><p>为了保证系统能够安全运行，用户只能执行非特权指令，运行在用户态</p></li></ul><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122172717616.png" alt="image-20201122172717616"></p><p>内核是计算机配置在底层的软件，是操作系统最基本最核心的部分；实现操作系统内核功能的程序是内核程序</p><ul><li><strong>时钟管理</strong><ul><li>计时  操作系统需要通过时钟管理，向用户提供标准的系统时间</li><li>切换进程 在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度</li></ul></li><li><strong>中断机制</strong><ul><li>初衷是提高多道程序运行环境中CPU的利用率，主要针对外部设备</li><li>后来逐步得到发展形成了多种类型，成为操作系统各项操作的基础</li></ul></li><li><strong>原语</strong><ul><li>处于操作系统的最低层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性，其操作只能一气呵成（主要从系统安全性和便于管理考虑）</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul></li><li><strong>资源管理</strong><ul><li>进程管理  进程状态管理、进程调度和分派、创建与撤销进程控制块</li><li>存储器管理 存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li><li>设备管理 缓冲区管理、设备分配和回收等</li></ul></li></ul><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="中断技术的诞生"><a href="#中断技术的诞生" class="headerlink" title="中断技术的诞生"></a>中断技术的诞生</h2><p>为了实现多道程序并发执行的一种技术为了提高资源利用率</p><h2 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h2><p>发生中断，就意味着需要操作系统介入开展管理工作，cpu会立即进入核心态作用：</p><p>“中断”是CPU从用户进入核心态的<strong>唯一途径</strong></p><h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>陷入（有意而为之的异常，如系统调用）、故障（由错误条件引起的，可能被故障处理程序修复，如缺页）、终止（不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除以0），<strong>信号来源CPU内部，与当前执行的指令有关</strong></p><ul><li><p>资源中断</p><ul><li>指令中断：系统调用时使用的访管指令（又叫陷入指令，trap指令）</li></ul></li><li><p>强迫中断</p><ul><li>硬件故障： 缺页</li><li>软件中断： 整数除以0</li></ul></li></ul><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p><strong>信号来源于CPU外部，与当前执行的指令无关</strong></p><ul><li>外设要求    如：/操作完成发出的中断信号</li><li>人为干预    如：用户强行终止一个进程</li></ul><h2 id="中断（外中断）处理过程"><a href="#中断（外中断）处理过程" class="headerlink" title="中断（外中断）处理过程"></a>中断（外中断）处理过程</h2><ul><li><p>关中断    CPU响应中所后，应该拒绝响应更高级的中源的中断请求件完成</p></li><li><p>保存断点    完成为了之后能重新恢复执行这个程序，需要将原来的程序的断点（即程序计数器PC）保存起来</p></li><li><p>中断服务程序寻址    取出中断服务程序的入口地址送到程序计数器PC</p></li><li><p>保存现场和屏蔽字    中断程序完成进入程序中所服务程序后，首先要保护现场，现场信息一般是指程序状态字寄存器PSWR和某些通用寄存器的内容</p></li><li><p>开中断 允许更高级中断请求得到响应，想象一下多道程序设计的并发执行，CPU交替执行内存里面的各个程序</p></li><li><p>执行中断 服务程序这是中断请求的目的，完成某些中断后的操作</p></li><li><p>关中断    保证在恢复现场和屏蔽字时不被中断，完成中断后的操作之后，需要恢复现场，不希望被打扰</p></li><li><p>恢复现场和屏蔽字    将现场和屏蔽字恢复到原来的状态</p></li><li><p>开中断    中断返回中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122172302086.png" alt="image-20201122172302086"></p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是操作系统提供给应用程序的接口</p><p>作用：应用程序可以通过系统调用（程序接口）请求获得操作系统的服务</p><p>系统调用会使处理器从用户态切换到核心态</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>设备管理     完成设备的请求、释放启动等功能</li><li>文件管理    完成文件的读，写、创删除等功能</li><li>进程控制    完成进程的创建、撒销、阻塞、唤醒等功能</li><li>进程通信    完成进程之间的消息传递、信号传递等功能</li><li>内存管理    完成内存的分配、回收、获取作业占用内存区大小及始址等功能</li></ul><h2 id="系统调用和库函数区别"><a href="#系统调用和库函数区别" class="headerlink" title="系统调用和库函数区别"></a>系统调用和库函数区别</h2><p>系统用时操作系统向上提供的接口</p><p>有的库函数是对系统调用的进一步封装</p><p>当今编写的应用程序大多是通过高级语言提供的库数接的进行系统调用</p><h2 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a>系统调用背后的过程</h2><ul><li>用户程序执行陷入指令（又称访问指令/Trap指令），请求操作系统服务</li><li>操作系统内核程序对系统调用进行相应处理</li><li>处理完成后，操作系统内核程序将CPU使用权还给用户</li></ul><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><ul><li><p>大内核</p><p>操作系统的主要功能模块都作为一个紧密联系的整体运行在和心态，为应用提供高性能的系统服务。但随着体系结构和应用需求的发展，需要操作系统提供的服务越来越多，接口越来越复杂，设计规模急剧增长。</p><p>优点： 高性能</p><p>缺点： 内核代码庞大、结构混乱、难以维护</p></li><li><p>微内核</p><ul><li><p>将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。</p></li><li><p>被移出的代码根据分层的原则被划分为若干服务程序，执行相互独立，交互借助于微内核进行通信。</p></li><li><p>微内核结构有效的分离了内核与服务、服务与服务，使得接口更加清晰，维护代价大大降低，各部分可以独立的优化和演进，从而保证操作系统的可靠性。</p></li><li><p>客户服务器模式：将进行划分为两类，服务器用来提供服务，客户端使用这些服务。</p></li></ul><p>优点： 内核功能少、结构清晰、方便维护</p><p>缺点：需要频繁在用户态和核心态之间切换，性能低</p></li></ul><p><strong>内核态→用户态</strong>：执行一条特权指令一一修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</p><p><strong>用户态→内核态</strong>：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122162253358.png" alt="image-20201122162253358"></p><h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><h2 id="CPU-（Central-Processing-Unit）"><a href="#CPU-（Central-Processing-Unit）" class="headerlink" title="CPU （Central Processing Unit）"></a>CPU （Central Processing Unit）</h2><ul><li>CPU从系统的RAM中提取指令，然后解码该指令的实际内容，然后由CPU的相关部分执行该指令（提取、解码和执行）</li><li>CPU从功能上看主要由两部分构成<ol><li>控制单元： 从内存中提取指令并解码执行</li><li>算数逻辑单元（ALU）： 处理算数和逻辑运算</li></ol></li><li>内部结构：<ol><li>寄存器：中央处理器内的组成部分。用来暂存指令、数据和地址。可以将其看作是内存的一中，根据种类的不同，一个CPU内部会有20-100个寄存器。</li><li>控制器：负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机</li><li>运算器： 负责运算从内存中读入寄存器的数据</li><li>时钟：负责发出CPU开始计时的时钟信号</li></ol></li></ul><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>累加寄存器</td><td>存储运行的数据和运算后的数据</td></tr><tr><td>标志寄存器</td><td>用于反应处理器的状态和运算结果的某些特征以及控制指令的执行</td></tr><tr><td>程序计数器</td><td>程序计数器是用于存放下一条指令所在单元的地址的地方</td></tr><tr><td>基址寄存器</td><td>存储数据内存的起始位置</td></tr><tr><td>变址寄存器</td><td>存储基址寄存器的相对地址</td></tr><tr><td>通用寄存器</td><td>存储任意数据</td></tr><tr><td>指令寄存器</td><td>储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td></tr><tr><td>栈寄存器</td><td>存储栈区域的起始位置</td></tr></tbody></table><ul><li>CPU指令执行过程<ol><li>取指令</li><li>指令译码</li><li>执行指令</li><li>访问取数</li><li>结果写回</li></ol></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的。</li><li>又称为主存，作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据</li><li>只要计算机在运行中，CPU就会把需要运算的数据调到主存中进行运算，当运算完成后CPU再将结构传送回来</li><li>内存的内部是有各种IC（Integrated Circuit，集成电路）电路组成的，它的种类很庞大，但是主要分为三种存储器：<ol><li>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</li><li>只读存储器（ROM）：ROM一般只能用于数据的读取，不能写入数据，但是当机器停电时，数据不会丢失</li><li>高速缓存（Cache）：分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache），它位于内存和CPU之间，是一个读写速度比内存更快的存储器。当CPU向内存写入数据时，这些数据会被写入高速缓存中，需要读取数据时，会直接从高速缓存中读取。如果需要的数据在Cache中没有，会再去读取内存中的数据</li></ol></li></ul><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><ul><li>磁盘中存储的程序必须加载到内存中才能运行，在磁盘中保存的程序是无法直接运行的。这是因为负责解析和运行程序内容的CPU是需要通过程序计数器来指定内存地址从而读出程序指令的。</li><li>磁盘缓存和虚拟内存</li></ul><h2 id="BIOS和引导"><a href="#BIOS和引导" class="headerlink" title="BIOS和引导"></a>BIOS和引导</h2><p>程序的运行环境，存在着名为BIOS（Basic Input/Output System）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘和显卡等基本控制外，还有引导程序的功能，引导程序是存储在启动驱动器启示区域的小程序。</p><p>电脑开机后，BIOS会确认硬件是否正常运行，没有异常的话会直接启动引导程序。引导程序的功能是吧在硬盘等记录的OS加载到内存中运行。虽然启动应用是OS的功能，但是OS不能启动自己，是通过引导程序启动的。</p><h2 id="DMA（Direct-Memory-Access）"><a href="#DMA（Direct-Memory-Access）" class="headerlink" title="DMA（Direct Memory Access）"></a>DMA（Direct Memory Access）</h2><p>DMA是指在不通过CPU的情况下，外围设备直接和主存进行数据传输。通过DMA大量数据可以在短时间内实现传输，因为CPU作为中介的事件被节省了。</p><p>参考: 王道考研 <a href="https://www.bilibili.com/video/BV1YE411D7nH">计算机操作系统</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;操作系统举例&quot;&gt;&lt;a href=&quot;#操作系统举例&quot; class=&quot;headerlink&quot; title=&quot;操作系统举</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch7.6.1 入门到实战</title>
    <link href="https://leslieaibin.github.io/2020/11/20/Java/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://leslieaibin.github.io/2020/11/20/Java/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2020-11-19T16:15:42.000Z</published>
    <updated>2020-11-20T13:30:03.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ElasticSearch</strong> ，简称为es，是一个开源的、高拓展的分布式全文检索引擎，它可以近乎实时的存储、检索数据。本身拓展性很好，可以拓展到上百台服务器，处理PB级别的数据。ElasticSearch使用java开发并且使用Lucene作为其核心来实现所有索引和搜索的功能，但是他的目的是通过简单的RestFul API来隐藏Lucene的复杂性，从而让全文检索变得简单。</p><h2 id="ElasticSearch和Solr的比较"><a href="#ElasticSearch和Solr的比较" class="headerlink" title="ElasticSearch和Solr的比较"></a>ElasticSearch和Solr的比较</h2><ul><li>es基本上是开箱即用，非常简单，Solr安装略麻烦；</li><li>Solr利用Zookeeper进行分布式管理，而elasticsearch自身就带有分布式协调管理功能；</li><li>Solr支持更多格式的数据，例如：json，xml，csv，而ElasticSearch仅仅支持json文件格式；</li><li>Solr官方提供的功能更多，而ElasticSearch本身更注重核心功能，高级功能多由第三方插件提供，例如图形化界面需要kibana友好支持；</li><li>Solr查询快，但更新索引时慢（即插入删除慢），用于电商的查询多的应用；<ul><li>ElasticSearch建立索引快（即查询慢），即实时性查询快，用于新浪的搜索；</li><li>Solr是传统搜索应用的解决方案，但ElasticSearch更适用于新兴的实时搜索应用。</li></ul></li><li>Solr比较成熟，有一个更大、更成熟的用户、开发和贡献者社区，而ElasticSearch相对开发维护者较少，更新太快，学习使用成本较高。</li></ul><h2 id="ElasticSearch安装及启动"><a href="#ElasticSearch安装及启动" class="headerlink" title="ElasticSearch安装及启动"></a>ElasticSearch安装及启动</h2><p>声明：ElasticSearch要求安装环境必须是要jdk1.8以上才行。</p><p><strong>1、下载安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f873770589" alt="在这里插入图片描述"></p><p><strong>2、解压安装包完成解压</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f87e35e972" alt="在这里插入图片描述"></p><p>解压完成即安装完成。</p><p><strong>3、ElasticSearch目录环境说明</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204157257.png" alt="image-20201120204157257"></p><ul><li>bin：可执行文件</li><li>config：配置文件<ul><li>elasticsearch.yml：项目配置文件</li><li>jvm.options：jvm相关的配置文件</li><li>log4j2.properties：日志相关配置文件</li></ul></li><li>jdk：相关的jdk环境</li><li>lib：项目所使用的相关jar包</li><li>logs：日志信息</li><li>modules：模块信息</li><li>plugins：插件信息</li></ul><p><strong>4、启动ElasticSearch</strong> 双击elasticsearch.bat运行。</p><p><strong>5、访问</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204350146.png" alt="image-20201120204350146"></p><p>访问成功！</p><h2 id="可视化界面的安装"><a href="#可视化界面的安装" class="headerlink" title="可视化界面的安装"></a>可视化界面的安装</h2><p>声明：可视化界面的安装必须基于node.js的环境</p><p><strong>1、下载可视化界面的项目压缩包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f882073b44" alt="在这里插入图片描述"></p><p><strong>2、解压</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204504275.png" alt="image-20201120204504275"></p><p><strong>3、启动可视化页面</strong></p><p>因为是基于node.js的前端项目，所以我们先要进入到项目文件，在cmd窗口中使用<code>npm install</code>命令安装相关环境，然后使用<code>npm run start</code>运行项目：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204553147.png" alt="image-20201120204553147"></p><p>启动完成，访问端口是9100。</p><h3 id="解决可视化界面访问ElasticSearch产生的跨域问题"><a href="#解决可视化界面访问ElasticSearch产生的跨域问题" class="headerlink" title="解决可视化界面访问ElasticSearch产生的跨域问题"></a>解决可视化界面访问ElasticSearch产生的跨域问题</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f89b18c48e" alt="在这里插入图片描述"></p><p>可视化界面的端口是9100，通过可视化界面去访问9200的ElasticSearch会产生跨域问题。</p><p><strong>修改ElasticSearch.yml文件让其支持跨域请求</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a5a5264d" alt="在这里插入图片描述"></p><p>在yml文件的最后加上允许跨域的配置，并重启ElasticSearch。</p><p>重启之后再使用可视化界面进行访问：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a538bc03" alt="在这里插入图片描述"></p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Kibana是一个针对ElasticSearch的开源分析及可视化平台，用于搜索、查看交互存储在ElasticSearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解，它操作简单，基于浏览器的用户界面可以快速创建仪表板实时显示ElasticSearch查询动态。设置Kibana非常简单，无需编码或者额外的基础架构，几分钟就可以完成安装并启动索引监测。</p><p><strong>注意事项</strong>：Kibana的版本必须要与安装的es版本一致。</p><p>我们可以将es理解为一个处理海量数据的数据库，Kibana可以监测并分析数据库中的数据信息。</p><h3 id="Kibana的安装和启动"><a href="#Kibana的安装和启动" class="headerlink" title="Kibana的安装和启动"></a>Kibana的安装和启动</h3><p><strong>1、下载安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a95bfccc" alt="在这里插入图片描述"></p><p><strong>2、解压安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204800373.png" alt="image-20201120204800373"></p><p><strong>3、启动Kibana</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204914227.png" alt="image-20201120204914227"></p><p><strong>4、访问</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204935828.png" alt="image-20201120204935828"></p><p>访问成功！</p><h3 id="Kibana的汉化"><a href="#Kibana的汉化" class="headerlink" title="Kibana的汉化"></a>Kibana的汉化</h3><p>Kibana是支持汉化的，我们只需要在他的项目yml文件中进行相关配置即可：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8c8bc988d" alt="在这里插入图片描述"></p><p>配置保存之后重启Kibana：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8ca016c3f" alt="在这里插入图片描述"></p><p>汉化完成！</p><h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><p>ElasticSearch是一个面向文档的数据库，其中的所有数据都是json，以下是各种专用名词和关系型数据库的对比：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8d088a633" alt="在这里插入图片描述"></p><p>ElasticSearch中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档，每个文档中又包含多个字段。</p><p><strong>物理设计：</strong></p><p>ElasticSearch在后台把每个索引划分为多个分片，每份分片可以在集群的不同服务器间迁移。ElasticSearch一启动就是一个集群，哪怕只有一个，默认的集群名称为：elasticsearch。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120205122140.png" alt="image-20201120205122140"></p><p><strong>逻辑设计</strong></p><p>在ES中，一个索引中包含多个文档，当我们索引一篇文档时，可以通过这样的顺序找到它：索引&gt;类型&gt;文档ID。通过这个组合我们就能索引到某个具体的文档。</p><blockquote><p>文档</p></blockquote><p>文档的概念换算到关系型数据库中就类似于一条数据。</p><p>ES是面向文档的，也就意味着索引和搜索数据的最小单位是文档，在ElasticSearch中，文档有几个重要属性：</p><ul><li>自我包含：一片文档同时包含字段和对应的值，也就是同时包含key-value；</li><li>可以是层次型的：一个文档包含另一个文档；</li><li>灵活的结构：文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用。在ElasticSearch中，对于字段是非常灵活的，有时候我们可以忽略该字段，或者动态的添加一个新的字段。</li></ul><blockquote><p>类型</p></blockquote><p>类型是文档的逻辑容器，就像关系型数据库中表格是行的容器一样，类型对于字段的定义称之为映射，比如说<code>name</code>映射为字符串类型。</p><p>我们说文档是无模式的，我们不需要对我们新增的每一个字段的类型进行映射，在没有进行映射的时候Elasticsearch会对数据的类型进行猜测，但是也有可能会猜不对，所以最安全的方式提前定义好所需要的映射，这一部分就跟关系型数据库差不多了。</p><blockquote><p>索引</p></blockquote><p>索引就类似于关系型数据库中的数据库。</p><p>索引是映射类型的容器，ElasticSearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置，然后他们被保存到了各个分片上。</p><blockquote><p>物理设计：节点和分片如何工作</p></blockquote><p>一个集群至少有一个节点，就是最基本的elasticsearch进程，每个节点可以有多个索引，如果你创建索引，则，默认会创建5个分片（又称主分片），每一个分片都会有一个副本（又称复制分片）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8e4abf4d5" alt="在这里插入图片描述"></p><p>例如上图是一个有三个节点的集群，可以看到主分片对应的复制分片都不会在同一个节点内，这样就有利于如果某个节点挂掉了，数据也不至于丢失，</p><p>实际上，一个分片是一个lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使得ElasticSearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。</p><p>等等，倒排索引是什么？？？？</p><blockquote><p>倒排索引</p></blockquote><p>Lucene采用倒排索引作为底层，这种设计适用于快速的全文搜索。</p><p>在ElasticSearch中，倒排索引的做法是对索引中的每个单词都进行重构为一个索引列表， 这样就可以清楚的反应每个单词在文档中的位置，当我们想要查找某个数据的时候，根据倒排索引生成的索引列表就可以最大限度的避免不符合数据的重复查询，只会在包含该数据的文档中进行查询。</p><p>例如下图数据：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8e661322b" alt="在这里插入图片描述"></p><p>在以上数据中可以得知：python这个词条，在1，2，3号文档中都有出现，linux这个词条在3，4号文档中出现，当我们想要查询linux这个词条的时候，根据倒排索引生成的索引列表，就不会再去查询1，2这两个文档，最大限度的避免了无用数据的查询。</p><p><strong>ElasticSearch索引和Lucene索引的关系</strong></p><p>在ElasticSearch中，每创建一个索引就会生成多个分片，其实每个分片就是一个Lucene索引，所以一个ElasticSearch索引本质就是用多个Lucene索引构成的。</p><h2 id="ik分词器插件"><a href="#ik分词器插件" class="headerlink" title="ik分词器插件"></a>ik分词器插件</h2><blockquote><p>什么是分词器？</p></blockquote><p>分词的意思就是把一段文字分成一个个的关键字，我们在搜索的时候会把自己的信息进行分词，会把数据库中的数据进行分词，然后进行一个匹配操作。</p><p>例如，我搜索”奥特曼打小怪兽“，在搜索结果中你可能看到只包含”奥特曼“的信息，也有可能看到只包含”小怪兽”的信息，这就是程序对我们的搜索信息进行了分词。</p><p>而默认的中文分词器是将每一个字分成一个词，例如：”奥特曼“分解成”奥“”特“”曼“。这种粒度的分词显然是不太方便的，所以在此我们使用ik分词器插件。</p><p>ik分词器提供了两个分词算法：ik_smart和ik_max_word，其中ik_smart为最少切分，ik_max_word为最细粒度切分。</p><h3 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h3><p><strong>1、下载</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8ee6df28f" alt="在这里插入图片描述"></p><p><strong>2、将压缩包解压到ElsticSearch的插件包中</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8eef02040" alt="在这里插入图片描述"></p><p><strong>3、重启ElasticSearch</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8f1893256" alt="在这里插入图片描述"></p><p>重启可以在日志中观察到ik分词器插件被加载。</p><p><strong>4、使用ElasticSearch的命令查看插件是否安装成功</strong></p><p>在ElasticSearch的bin目录中打开cmd窗口，输入命令<code>elasticsearch-plugin list</code>即可查看安装的插件列表：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f906288fc5" alt="在这里插入图片描述"></p><h3 id="使用Kibana发送请求展示ik分词器效果"><a href="#使用Kibana发送请求展示ik分词器效果" class="headerlink" title="使用Kibana发送请求展示ik分词器效果"></a>使用Kibana发送请求展示ik分词器效果</h3><p><strong>json代码：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET _analyze   //请求分词器</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,   <span class="comment">//选择分词算法</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;大连理工大学信息检索与文本挖掘&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>分词效果：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120205327514.png" alt="image-20201120205327514"></p><p>由上可以看到，分词器会根据语句中的词语进行分割，但是他们怎么认使什么字连起来是一个词呢？这是因为在分词器的内部有一个自己的字典，可以识别常用的正常词语，当我们输入一个人名或者自己捏造的词语的时候就无法达到想要的效果。</p><h2 id="ElasticSearch基本操作"><a href="#ElasticSearch基本操作" class="headerlink" title="ElasticSearch基本操作"></a>ElasticSearch基本操作</h2><p>操作ElasticSearch的命令都是通过RestFul风格的请求命令去完成的，大致如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9645bb539" alt="在这里插入图片描述"></p><blockquote><p>使用Kibana演示基础操作</p></blockquote><h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><p>语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引名/类型名/文档id</span><br><span class="line">&#123;</span><br><span class="line">    请求体</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f92a72cc2f" alt="在这里插入图片描述"></p><p>在head页面上查看数据：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9436bf43b" alt="在这里插入图片描述"></p><p>由以上示例可知，我们通过put命令创建了一个索引并添加了文档数据，但是我们并没有给这个索引映射类型，在ElasticSearch中数据有多少的数据类型呢？</p><p>ElasticSearch相关的数据类型：</p><ul><li>字符串类型：text、keyword</li><li>数值类型：long、integer、short、byte、doule、float、half float、scaled float</li><li>日期类型：date</li><li>布尔值类型：boolean</li><li>二进制类型：binary</li><li>等等……</li></ul><h3 id="创建一个索引不赋值并指定类型"><a href="#创建一个索引不赋值并指定类型" class="headerlink" title="创建一个索引不赋值并指定类型"></a>创建一个索引不赋值并指定类型</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f936aa0804" alt="在这里插入图片描述"></p><p>以上json命令只创建了一个test2索引并映射类型</p><h3 id="查看索引信息"><a href="#查看索引信息" class="headerlink" title="查看索引信息"></a>查看索引信息</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9321042df" alt="在这里插入图片描述"></p><p>通过<code>GET</code>命令就可以查看到索引的信息，后面的目标准确到索引就查看索引信息，准确到文档就查看文档信息。</p><h3 id="修改文档信息"><a href="#修改文档信息" class="headerlink" title="修改文档信息"></a>修改文档信息</h3><p>修改文档信息有两种方式，第一种是通过PUT命令在原来的文档上添加数据进行覆盖，第二种是通过POST进行修改。</p><p>1）PUT覆盖修改</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f98191b029" alt="在这里插入图片描述"></p><p>使用PUT进行修改有一个弊端，就是他会将所有的数据都进行覆盖，如果你修改的字段有缺漏，则缺漏的部分会被覆盖为空，造成数据的丢失。</p><p>2)POST方式修改</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9450e430e" alt="img"></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除索引信息通过DELETE命令来完成。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f946619a01" alt="在这里插入图片描述"></p><p>DELETE操作和GET操作一样，后面的目标精确到文档就删除文档信息，精确到索引就删除索引信息。</p><h2 id="复杂查询操作"><a href="#复杂查询操作" class="headerlink" title="复杂查询操作"></a>复杂查询操作</h2><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名&#x2F;类型名&#x2F;_search?q&#x3D;字段名:字段值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9488dfd73" alt="在这里插入图片描述">关于基础条件查询语句的解析： 其中_search后面的q的意思是query，在语法中是一个对象，完整的写法应该如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9590bc229" alt="在这里插入图片描述"></p><p>如上图所示，我们可以在query对象中设置很多的参数来完成各种情况下的查询方式。查询的结果中包含一个hits对象，这个对象的参数就包含了所有具体的查询结果。</p><h3 id="条件查询-只显示某几个字段"><a href="#条件查询-只显示某几个字段" class="headerlink" title="条件查询_只显示某几个字段"></a>条件查询_只显示某几个字段</h3><p>默认情况下的条件查询会将文档的所有字段都查询出来，但是我们可以通过一个_source属性去指定想要查询出来的字段：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f95acc765b" alt="在这里插入图片描述"></p><p>由上图可以看到，当我们指定了只查询”name”字段的时候，后面查询出来的信息中就只包含了”name”字段信息。</p><h3 id="根据指定字段排序查询"><a href="#根据指定字段排序查询" class="headerlink" title="根据指定字段排序查询"></a>根据指定字段排序查询</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9674eeaa8" alt="在这里插入图片描述"></p><p>如上图所示，按照age字段进行降序排列，因为我们自定义了按照某种规则进行排序吗，所以之前的排序规则分数就会为Null。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9682f7fbd" alt="在这里插入图片描述"></p><p>我们可以通过设置”from”和”size”参数来设置分页查询的相关信息。</p><h3 id="布尔值查询"><a href="#布尔值查询" class="headerlink" title="布尔值查询"></a>布尔值查询</h3><p>通过布尔值查询的方式我们可以实现类似于数据库的多条件查询：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9686da4ea" alt="在这里插入图片描述"></p><p>例如通过这个must指令就可以实现多条件查询，在上图中，只有同时满足name中包含张三，并且年龄为18的数据才会被查询出。</p><p>简单的来说满足这两个条件就会返回true的布尔值然后被查询出来，所以被叫做布尔值查询，相当于sql语句中的where and条件语句。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f97b3bba44" alt="在这里插入图片描述"></p><p>而should命令则表示后方的两个条件只需要满足其中之一即可，就类似于sql语句中的where or条件语句。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9846bacda" alt="在这里插入图片描述"></p><p>同理，must_not表示查询出不满足条件的数据，例如上图查询出年龄不为18的信息，相当于sql中的not条件语句。</p><h3 id="过滤查询操作"><a href="#过滤查询操作" class="headerlink" title="过滤查询操作"></a>过滤查询操作</h3><p>在满足多种条件查询的同时，es也支持我们对查询的数据进行进一步的筛选过滤。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f987f687fc" alt="在这里插入图片描述"></p><p>通过上图的配置可以实现按照年龄大小进行进一步过滤的操作，gte是大于等于操作，lte是小于等于操作，gt只表示大于操作，lt只表示小于操作。</p><p>同时，也可以同时设置大于和小于来进行值的区间搜索操作，相当于sql中的between and条件。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9a430a6c0" alt="在这里插入图片描述"></p><h3 id="匹配多个条件查询"><a href="#匹配多个条件查询" class="headerlink" title="匹配多个条件查询"></a>匹配多个条件查询</h3><p>匹配多个条件查询就有点类似于sql中的in关键字。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9a77edf10" alt="在这里插入图片描述"></p><p>如图所示，tags是兴趣标签，在数据中是以数组的形式存在的，也就是说有多个值，通过这种方式就可以进行多个值的随意匹配。</p><h3 id="精确匹配term"><a href="#精确匹配term" class="headerlink" title="精确匹配term"></a>精确匹配term</h3><p><strong>term精确匹配和match的不同：</strong></p><p>term会将条件依据倒排索引进行精确匹配，而match则会将查询条件进行分词然后再匹配。简单的来说，match会产生类似与模糊查询的效果，而term不会，条件匹配不上即使数据包含查询条件也不会被查询出来。</p><p><strong>关于text和keyword类型：</strong></p><p>text类型和keyword的不同之处在于，text会被分词器进行分词，而keyword不会被分词器分词。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9ac0d8885" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9b6e25f4f" alt="在这里插入图片描述"></p><h3 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h3><p>ElasticSearch同时也支持高亮查询，他会将查询结果中的查询条件关键字进行自动的高亮显示。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9be9b79bf" alt="在这里插入图片描述"></p><h2 id="SpringBoot集成ElasticSearch"><a href="#SpringBoot集成ElasticSearch" class="headerlink" title="SpringBoot集成ElasticSearch"></a>SpringBoot集成ElasticSearch</h2><p>此次SpringBoot集成ElasticSearch采用SpringBoot脚手架来进行学习。</p><p><strong>1、勾选引入ElasticSearch依赖</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9d015dd3a" alt="在这里插入图片描述"></p><p>勾选之后需要注意的是，我们在此使用的SpringBoot版本为2.3.1，此版本的ES客户端并不是本地安装的7.6.1版本：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120210008727.png" alt="image-20201120210008727"></p><p>因此，我们需要在pom.xml进行ES客户端版本的自定义配置：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120210127576.png" alt="image-20201120210127576"></p><p>版本依赖导入完成！</p><p><strong>2、书写配置类将ES对象注入到Spring容器之中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/16 21:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//ES集群的相关信息，如果有多个就配置多个</span></span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，SpringBoot集成ElasticSearch就完成了。</p><h2 id="关于java操作ES索引的API"><a href="#关于java操作ES索引的API" class="headerlink" title="关于java操作ES索引的API"></a>关于java操作ES索引的API</h2><p>关于java API的学习都会在测试类中进行完成。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parse</span><span class="params">(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.parseContent(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span>String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span><span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span><span class="keyword">int</span> pageSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.searchPageHighlightBuilder(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建成功!</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9df034b64" alt="在这里插入图片描述"></p><h3 id="判断索引是否存在"><a href="#判断索引是否存在" class="headerlink" title="判断索引是否存在"></a>判断索引是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据放入es搜索中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">parseContent</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Content&gt; contents = <span class="keyword">new</span> HtmlParseUtil().parseJD(keywords);</span><br><span class="line">    <span class="comment">// 把查询到的数据放入es中</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contents.size(); i++) &#123;</span><br><span class="line">        bulkRequest.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;jd_goods&quot;</span>)</span><br><span class="line">                        .source(JSON.toJSONString(contents.get(i)),XContentType.JSON));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> !bulk.hasFailures();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9e05854a9" alt="在这里插入图片描述"></p><h3 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试删除索引</span><br><span class="line">    @Test</span><br><span class="line">    void deleteIndex() throws IOException &#123;</span><br><span class="line">        DeleteIndexRequest java_index &#x3D; new DeleteIndexRequest(&quot;java_index&quot;);</span><br><span class="line">        AcknowledgedResponse delete &#x3D; restHighLevelClient.indices().delete(java_index, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(delete.isAcknowledged());  &#x2F;&#x2F;获取删除成功与否的提示信息</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码效果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9e8afbaad" alt="在这里插入图片描述"></p><p>删除成功！</p><h2 id="关于java操作ES文档的API"><a href="#关于java操作ES文档的API" class="headerlink" title="关于java操作ES文档的API"></a>关于java操作ES文档的API</h2><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试添加文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//创建请求</span></span><br><span class="line">        IndexRequest java_index = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;java_index&quot;</span>);</span><br><span class="line">        <span class="comment">//填充规则</span></span><br><span class="line">        java_index.id(<span class="string">&quot;1&quot;</span>);  <span class="comment">//文档编号</span></span><br><span class="line">        <span class="comment">//将对象放入请求中</span></span><br><span class="line">        java_index.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">        <span class="comment">//客户端发送请求，接收响应结果</span></span><br><span class="line">        IndexResponse index = restHighLevelClient.index(java_index, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//打印响应结果</span></span><br><span class="line">        System.out.println(index.toString());  <span class="comment">//查看返回的具体json信息</span></span><br><span class="line">        System.out.println(index.status());  <span class="comment">//查看操作的状态</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因为ES只支持json格式的数据流通，所以在将对象放入请求的过程中需要将对象序列化为josn字符串，在此需要阿里巴巴的fastjson支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看添加文档结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9ffc955bd" alt="在这里插入图片描述"></p><p>添加成功！</p><h3 id="判断文档是否存在"><a href="#判断文档是否存在" class="headerlink" title="判断文档是否存在"></a>判断文档是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试判断文档是否存在</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExistDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">GetRequest java_index = <span class="keyword">new</span> GetRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> exists = restHighLevelClient.exists(java_index, RequestOptions.DEFAULT);</span><br><span class="line">System.out.println(exists);  <span class="comment">//返回布尔值表示是否存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa092d0cdf" alt="在这里插入图片描述"></p><p>一号文档存在！</p><h3 id="获取文档信息"><a href="#获取文档信息" class="headerlink" title="获取文档信息"></a>获取文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试获取文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetRequest java_index = <span class="keyword">new</span> GetRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    GetResponse getResponse = restHighLevelClient.get(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(getResponse.getSourceAsString());  <span class="comment">//打印文档的内容</span></span><br><span class="line">    System.out.println(getResponse);  <span class="comment">//getResponse对象就包含ES的所有查询信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码效果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa03154a2d" alt="在这里插入图片描述"></p><h3 id="修改文档记录"><a href="#修改文档记录" class="headerlink" title="修改文档记录"></a>修改文档记录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试修改文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UpdateRequest java_index = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;法外狂徒张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    java_index.doc(JSON.toJSONString(user),XContentType.JSON);</span><br><span class="line">    UpdateResponse update = restHighLevelClient.update(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(update.status());  <span class="comment">//查看更新状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa22459d38" alt="在这里插入图片描述"></p><p>修改成功！</p><h3 id="删除文档信息"><a href="#删除文档信息" class="headerlink" title="删除文档信息"></a>删除文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteRequest java_index = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    DeleteResponse delete = restHighLevelClient.delete(java_index,RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.status());  <span class="comment">//查看删除状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa2230fc5d" alt="在这里插入图片描述"></p><p>删除成功！</p><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>ES同时也支持批量增删改的操作，在此只演示批量添加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试批量添加文档下信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bulkDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建批量操作对象</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    ArrayList&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三1&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三2&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三3&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三4&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三5&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        bulkRequest.add(</span><br><span class="line">                <span class="keyword">new</span> IndexRequest(<span class="string">&quot;java_index&quot;</span>).id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>))</span><br><span class="line">                        .source(JSON.toJSONString(list.get(i)),XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(bulk.hasFailures());  <span class="comment">//查看状态，是否失败，返回false代表成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa23f07bfa" alt="在这里插入图片描述"></p><h3 id="查询文档信息"><a href="#查询文档信息" class="headerlink" title="查询文档信息"></a>查询文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试查询文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建请求对象</span></span><br><span class="line">    SearchRequest java_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;java_index&quot;</span>);</span><br><span class="line">    <span class="comment">//构造搜索条件</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//使用工具类构造搜索信息</span></span><br><span class="line">    MatchQueryBuilder query = QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三1&quot;</span>);</span><br><span class="line">    searchSourceBuilder.query(query);</span><br><span class="line">    java_index.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    SearchResponse search = restHighLevelClient.search(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(JSON.toJSONString(search.getHits()));  <span class="comment">//Hits对象就包含查询的各种信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa2895e40e" alt="在这里插入图片描述"></p><p>Hits对象中包含的是所有的查询结果信息，我们可以通过遍历想要的参数获得具体的信息。</p><p>对于复杂查询的各种操作都可以在searchSourceBuilder对象的方法中找到对应的方法：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa23f5904f" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa37d4fde0" alt="在这里插入图片描述"></p><h2 id="ElasticSeatch项目实战：京东搜索"><a href="#ElasticSeatch项目实战：京东搜索" class="headerlink" title="ElasticSeatch项目实战：京东搜索"></a>ElasticSeatch项目实战：京东搜索</h2><p>此次项目实战采用java爬虫爬取京东的数据放在es数据源中，然后通过页面来模拟京东搜索。</p><h3 id="1、项目搭建"><a href="#1、项目搭建" class="headerlink" title="1、项目搭建"></a>1、项目搭建</h3><p><strong>创建项目并引入相关pom依赖</strong></p><p>相关pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xsh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>es_jdsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>es_jdsearch<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>yml相关配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">  <span class="comment">#关闭thymeleaf缓存</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>引入静态资源</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211525026.png" alt="image-20201120211525026"></p><p><strong>编写控制器访问index.html页面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xsh.es_jdsearch.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>访问页面</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa567c20bf" alt="在这里插入图片描述"></p><h3 id="2、使用jsoup爬取京东相关的数据"><a href="#2、使用jsoup爬取京东相关的数据" class="headerlink" title="2、使用jsoup爬取京东相关的数据"></a>2、使用jsoup爬取京东相关的数据</h3><p><strong>引入jsoup依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编写工具类解析网页爬取数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhangaibin.pojo.Content;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/19 15:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlParseUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HtmlParseUtil().parseJD(<span class="string">&quot;大连理工&quot;</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Content&gt; <span class="title">parseJD</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求</span></span><br><span class="line">        <span class="comment">// String url = &quot;https://search.jd.com/Search?keyword=&quot; + keywords+&quot;&amp;enc=utf-8&quot;;</span></span><br><span class="line">        <span class="comment">// 指定编码集，防止中文乱码</span></span><br><span class="line">        Document document = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            document = Jsoup.parse(<span class="keyword">new</span> URL(<span class="string">&quot;https://search.jd.com/Search?keyword=&quot;</span> + keywords + <span class="string">&quot;&amp;enc=utf-8&quot;</span>), <span class="number">30000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---JDSearchHtmlParser.parse()失败---&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析网页（jsoup返回的document就是浏览器返回的Document对象）</span></span><br><span class="line">        <span class="comment">//Document document = Jsoup.parse(new URL(url), 30000);</span></span><br><span class="line">        <span class="comment">// 所有在js中的方法，都可以使用</span></span><br><span class="line">        Element element = document.getElementById(<span class="string">&quot;J_goodsList&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有的li元素</span></span><br><span class="line">        Elements elements = element.getElementsByTag(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        List&lt;Content&gt; goodList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取元素内容,每个li标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element el : elements) &#123;</span><br><span class="line">            String img = el.getElementsByTag(<span class="string">&quot;img&quot;</span>).eq(<span class="number">0</span>).attr(<span class="string">&quot;data-lazy-img&quot;</span>);</span><br><span class="line">            String price = el.getElementsByClass(<span class="string">&quot;p-price&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            String title = el.getElementsByClass(<span class="string">&quot;p-name&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            Content content = <span class="keyword">new</span> Content();</span><br><span class="line">            content.setImg(img);</span><br><span class="line">            content.setPrice(price);</span><br><span class="line">            content.setTitle(title);</span><br><span class="line">            goodList.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：该类可以通过jsoup爬取页面上的相关信息，在爬取图片的时候狂神使用的是source-data-lazy-img属性，但是我在写的时候这个属性是无效的，还是使用的src属性才获取到的图片地址。</p><h3 id="3、书写接口使用工具类将解析到的数据插入到ElasticSearch中"><a href="#3、书写接口使用工具类将解析到的数据插入到ElasticSearch中" class="headerlink" title="3、书写接口使用工具类将解析到的数据插入到ElasticSearch中"></a>3、书写接口使用工具类将解析到的数据插入到ElasticSearch中</h3><p><strong>创建jd_goods索引</strong></p><p>在此通过图形化界面快速创建索引：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211807101.png" alt="image-20201120211807101"></p><p><strong>注入ElasticSearch客户端对象</strong></p><p>要实现对ES数据进行操作，首先肯定要通过配置类来注入客户端对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/16 21:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//ES集群的相关信息，如果有多个就配置多个</span></span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Controller代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhangaibin.service.ContentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/19 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parse</span><span class="params">(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.parseContent(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span>String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span><span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span><span class="keyword">int</span> pageSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.searchPageHighlightBuilder(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据放入es搜索中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">parseContent</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Content&gt; contents = <span class="keyword">new</span> HtmlParseUtil().parseJD(keywords);</span><br><span class="line">    <span class="comment">// 把查询到的数据放入es中</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contents.size(); i++) &#123;</span><br><span class="line">        bulkRequest.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;jd_goods&quot;</span>)</span><br><span class="line">        .source(JSON.toJSONString(contents.get(i)),XContentType.JSON));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> !bulk.hasFailures();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问接口就可以调用jsoup工具类将解析到的网页数据插入到es索引中，结果如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211945140.png" alt="image-20201120211945140"></p><h3 id="4、书写接口分页带条件查询信息"><a href="#4、书写接口分页带条件查询信息" class="headerlink" title="4、书写接口分页带条件查询信息"></a>4、书写接口分页带条件查询信息</h3><p>数据有了之后，就是做数据展示，在此接口接收查询的关键字和分页的信息进行分页并带条件的查询：</p><p><strong>Controller接口代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询数据接口</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span> <span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span> <span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> jdService.search(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="number">0</span>)&#123;</span><br><span class="line">            pageNo=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建搜索对象</span></span><br><span class="line">        SearchRequest jd_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_goods&quot;</span>);</span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置分页信息</span></span><br><span class="line">        sourceBuilder.from(pageNo);</span><br><span class="line">        sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        TermQueryBuilder query = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">        <span class="comment">//封装搜索条件</span></span><br><span class="line">        sourceBuilder.query(query);</span><br><span class="line">        <span class="comment">//封装搜索对象</span></span><br><span class="line">        jd_index.source(sourceBuilder);</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        SearchResponse response = restHighLevelClient.search(jd_index, RequestOptions.DEFAULT);</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            list.add(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5、采用Vue-axios进行前后端分离数据展示"><a href="#5、采用Vue-axios进行前后端分离数据展示" class="headerlink" title="5、采用Vue+axios进行前后端分离数据展示"></a>5、采用Vue+axios进行前后端分离数据展示</h3><p><strong>使用npm下载vue.js和axios.js的相关文件</strong></p><p>首先我们随便创建一个英文名称的文件夹，在其中使用cmd命令行<code>npm init</code>来初始化，使用<code>npm install vue</code>和<code>npm install axios</code>来下载依赖。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa70f8d7eb" alt="在这里插入图片描述"></p><p>下载结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa69d12f5a" alt="在这里插入图片描述"></p><p>在项目中引入vue.min.js和axios.min.js文件：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa84b0d7b6" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa79343ca1" alt="在这里插入图片描述"></p><p>修改页面信息，动态绑定搜索框的数据和搜索按钮的单击事件，实现单击搜索按钮就发送请求进行ES库的查询，并且使用v-for将查询结果进行遍历显示，以下仅展示vue对象的相关代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--前端使用vue，实现前后端分离--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            keyword: <span class="string">&#x27;&#x27;</span>,<span class="comment">//搜索的关键字</span></span></span><br><span class="line"><span class="javascript">            results: []<span class="comment">//搜索的结果</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">searchKey</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> keyword = <span class="built_in">this</span>.keyword;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(keyword);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 对接后端的接口</span></span></span><br><span class="line"><span class="javascript">                axios.get(<span class="string">&#x27;search/&#x27;</span>+keyword+<span class="string">&quot;/1/20&quot;</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//对接后端代码</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.results = response.data;<span class="comment">// 绑定数据</span></span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>查看页面查询效果</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120212100093.png" alt="image-20201120212100093"></p><p>以上，我们就通过代码完成了es数据库的查询操作，可以用来做页面的搜索功能。</p><p>但是如上图所示，我们不仅实现了搜索功能，还实现了关键字结果的高亮，这是因为接口的不同：</p><h3 id="6、分页待条件且关键字高亮查询"><a href="#6、分页待条件且关键字高亮查询" class="headerlink" title="6、分页待条件且关键字高亮查询"></a>6、分页待条件且关键字高亮查询</h3><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高亮分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; searchHighLight(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="number">0</span>)&#123;</span><br><span class="line">            pageNo=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建搜索对象</span></span><br><span class="line">        SearchRequest jd_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_index&quot;</span>);</span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置分页信息</span></span><br><span class="line">        sourceBuilder.from(pageNo);</span><br><span class="line">        sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装高亮显示条件</span></span><br><span class="line">        HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">        highlightBuilder.field(<span class="string">&quot;title&quot;</span>);  <span class="comment">//对哪个字段进行高亮</span></span><br><span class="line">        highlightBuilder.preTags(<span class="string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>);  <span class="comment">//设置高亮前缀</span></span><br><span class="line">        highlightBuilder.postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);  <span class="comment">//高亮后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        TermQueryBuilder query = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">        <span class="comment">//封装搜索条件</span></span><br><span class="line">        sourceBuilder.query(query);</span><br><span class="line">        sourceBuilder.highlighter(highlightBuilder);  <span class="comment">//封装高亮搜索条件</span></span><br><span class="line">        <span class="comment">//封装搜索对象</span></span><br><span class="line">        jd_index.source(sourceBuilder);</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        SearchResponse response = restHighLevelClient.search(jd_index, RequestOptions.DEFAULT);</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">            HighlightField title = highlightFields.get(<span class="string">&quot;title&quot;</span>);  <span class="comment">//高亮之后的title</span></span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();  <span class="comment">//未高亮之前的结果集</span></span><br><span class="line">            <span class="comment">//接下来就是将高亮的title与结果集中未高亮的title进行替换</span></span><br><span class="line">            <span class="keyword">if</span>(title!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Text[] fragments = title.fragments();</span><br><span class="line">                String newTitle=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (Text text : fragments) &#123;</span><br><span class="line">                    newTitle+=text;</span><br><span class="line">                &#125;</span><br><span class="line">                sourceAsMap.put(<span class="string">&quot;title&quot;</span>,newTitle);  <span class="comment">//替换掉未高亮的title</span></span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sourceAsMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7-运行"><a href="#7-运行" class="headerlink" title="7. 运行"></a>7. 运行</h3><ol><li>启动ElasticSear</li><li>启动ElasticSearch-head</li><li>运行主启动类EsJdApplication.class</li><li>浏览器输入<a href="http://localhost:9090/parse/java">http://localhost:9090/parse/java</a> (要爬取的书籍)(将爬取结果放入es)</li><li><a href="http://localhost:9090/">http://localhost:9090</a> ，在搜索栏中输入java，就得到结果了，不过要先执行第4步，在es中有相应的东西才能有结果，目前中文不支持(即可以放进es，但得不到搜索结果)</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV17a4y1x7zq">狂神说</a> 他公众号有相应资源<br>         <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">nodejs安装</a><br>         <a href="https://blog.csdn.net/wjnf012/article/details/80422313">cnpm安装</a><br>         <a href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&O=D">ElasticSearch</a><br>         <a href="https://mirrors.huaweicloud.com/logstash/?C=N&O=D">logstash</a><br>         <a href="https://mirrors.huaweicloud.com/kibana/?C=N&O=D">kibana</a></p><p><a href="https://juejin.cn/post/6844904168835006477#heading-46">小白必看_从入门到实战的ElasticSearch7.6.1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt; ，简称为es，是一个开源的、高拓展的分布式全文检索引擎，它可以近乎实时的存储、</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="ElasticSearch" scheme="https://leslieaibin.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>100的阶乘是0？</title>
    <link href="https://leslieaibin.github.io/2020/11/18/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/100%E9%98%B6%E4%B9%98/"/>
    <id>https://leslieaibin.github.io/2020/11/18/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/100%E9%98%B6%E4%B9%98/</id>
    <published>2020-11-17T16:15:42.000Z</published>
    <updated>2020-11-17T16:26:26.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="100的阶乘的0？"><a href="#100的阶乘的0？" class="headerlink" title="100的阶乘的0？"></a>100的阶乘的0？</h2><h3 id="有趣的疑问"><a href="#有趣的疑问" class="headerlink" title="有趣的疑问"></a>有趣的疑问</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/86735519.jpg" alt="img"></p><p>超出数据类型取值范围 会输出什么数字：</p><p> 数据类型：int</p><p> 取值范围：-2^31–2^31-1</p><p> 测试1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">34</span>;i++)&#123;</span><br><span class="line">i3=i3*<span class="number">2</span>;</span><br><span class="line">System.out.println(i3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">512</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">2048</span></span><br><span class="line"><span class="number">4096</span></span><br><span class="line"><span class="number">8192</span></span><br><span class="line"><span class="number">16384</span></span><br><span class="line"><span class="number">32768</span></span><br><span class="line"><span class="number">65536</span></span><br><span class="line"><span class="number">131072</span></span><br><span class="line"><span class="number">262144</span></span><br><span class="line"><span class="number">524288</span></span><br><span class="line"><span class="number">1048576</span></span><br><span class="line"><span class="number">2097152</span></span><br><span class="line"><span class="number">4194304</span></span><br><span class="line"><span class="number">8388608</span></span><br><span class="line"><span class="number">16777216</span></span><br><span class="line"><span class="number">33554432</span></span><br><span class="line"><span class="number">67108864</span></span><br><span class="line"><span class="number">134217728</span></span><br><span class="line"><span class="number">268435456</span></span><br><span class="line"><span class="number">536870912</span></span><br><span class="line"><span class="number">1073741824</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>为了更详细的看出其变化，将在临界值前后输出更多值，测试2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i3=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">31</span>;i++)&#123;</span><br><span class="line">i3=i3*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=(i3-<span class="number">3</span>)*<span class="number">2</span>;k&lt;<span class="number">15</span>;j++,k++)&#123;</span><br><span class="line">System.out.println(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">测试结果</span><br><span class="line"></span><br><span class="line"><span class="number">2147483642</span></span><br><span class="line"><span class="number">2147483643</span></span><br><span class="line"><span class="number">2147483644</span></span><br><span class="line"><span class="number">2147483645</span></span><br><span class="line"><span class="number">2147483646</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line">-<span class="number">2147483647</span></span><br><span class="line">-<span class="number">2147483646</span></span><br><span class="line">-<span class="number">2147483645</span></span><br><span class="line">-<span class="number">2147483644</span></span><br><span class="line">-<span class="number">2147483643</span></span><br><span class="line">-<span class="number">2147483642</span></span><br><span class="line">-<span class="number">2147483641</span></span><br><span class="line">-<span class="number">2147483640</span></span><br></pre></td></tr></table></figure><p>分析：当前int型数据达到最大值2147483647时，是第一位为0，其余31位为全1，01111111111111111111111111111111；再加1则进1，第一位为1，其余全零，10000000000000000000000000000000。系统把第一位判断为负号，而且同时代表值，所以是-2147483648，当再继续相加时，系统会把之前的数当做负数，再加上正数1，则为-2147483647，10000000000000000000000000000001，后面以此类推。结合测试1，当为10000000000000000000000000000000时，即-2147483648，再乘以2将溢出，溢出位娶不到，全0，即为00000000000000000000000000000000，此时为0（-2147483648再乘以2为什么是0的理解） . 再乘以2依然为0.</p><p>为了解决这样大数的问题 引入了BigInteger 和 BigDecimal</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi &#x3D; new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">System.out.println(bi.pow(5)); &#x2F;&#x2F; 2867971860299718107233761438093672048294900000</span><br></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 &#x3D; new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">BigInteger i2 &#x3D; new BigInteger(&quot;12345678901234567890&quot;);</span><br><span class="line">BigInteger sum &#x3D; i1.add(i2); &#x2F;&#x2F; 12345678902469135780</span><br></pre></td></tr></table></figure><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i &#x3D; new BigInteger(&quot;123456789000&quot;);</span><br><span class="line">System.out.println(i.longValue()); &#x2F;&#x2F; 123456789000</span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); &#x2F;&#x2F; java.lang.ArithmeticException: BigInteger out of long range</span><br></pre></td></tr></table></figure><p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure><p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比较BigDecimal</strong></p><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 &#x3D; new BigDecimal(&quot;123.456&quot;);</span><br><span class="line">BigDecimal d2 &#x3D; new BigDecimal(&quot;123.45600&quot;);</span><br><span class="line">System.out.println(d1.equals(d2)); &#x2F;&#x2F; false,因为scale不同</span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); &#x2F;&#x2F; true,因为d2去除尾部0后scale变为2</span><br><span class="line">System.out.println(d1.compareTo(d2)); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p> 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h3 id="100的阶乘实现"><a href="#100的阶乘实现" class="headerlink" title="100的阶乘实现"></a>100的阶乘实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JieCheng</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法int</span></span><br><span class="line">        jichengint();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法biginteger</span></span><br><span class="line">        jiechengbiginteger();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法bigdecimal</span></span><br><span class="line">        jiechengbigdecimal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jichengint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘Int:  &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiechengbiginteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger result = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1&quot;</span>);<span class="comment">//为result赋初始值，为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            BigInteger num = <span class="keyword">new</span> BigInteger(String.valueOf(i));</span><br><span class="line">            result = result.multiply(num);<span class="comment">//调用自乘方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘BigInTeger  &quot;</span>+result);<span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;位数： &quot;</span>+String.valueOf(result).length());<span class="comment">//输出长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiechengbigdecimal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//求一百的阶乘之和</span></span><br><span class="line">        <span class="comment">//只能用math里边的BigDecimal来存储数据</span></span><br><span class="line">        <span class="comment">//定义变量保存阶乘的和</span></span><br><span class="line">        BigDecimal result = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>);<span class="comment">//为result赋初始值，为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            BigDecimal num = <span class="keyword">new</span> BigDecimal(String.valueOf(i));</span><br><span class="line">            result = result.multiply(num);<span class="comment">//调用自乘方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘BigDecimal  &quot;</span>+result);<span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;位数： &quot;</span>+String.valueOf(result).length());<span class="comment">//输出长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">阶乘Int:  <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">阶乘BigInTeger <span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br><span class="line">位数： <span class="number">158</span></span><br><span class="line">    </span><br><span class="line">阶乘BigDecimal  <span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br><span class="line">位数： <span class="number">158</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;100的阶乘的0？&quot;&gt;&lt;a href=&quot;#100的阶乘的0？&quot; class=&quot;headerlink&quot; title=&quot;100的阶乘的0？&quot;&gt;&lt;/a&gt;100的阶乘的0？&lt;/h2&gt;&lt;h3 id=&quot;有趣的疑问&quot;&gt;&lt;a href=&quot;#有趣的疑问&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM(三） —— 类文件结构</title>
    <link href="https://leslieaibin.github.io/2020/11/15/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://leslieaibin.github.io/2020/11/15/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2020-11-14T16:15:42.000Z</published>
    <updated>2021-03-26T11:20:51.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。<code>.class</code>文件的二进制格式可以使用 <a href="https://www.x-ways.net/winhex/">WinHex</a> 查看。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115230551749.png" alt="image-20201115230551749"></p><p><strong>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</strong></p><h2 id="Class-文件结构总结"><a href="#Class-文件结构总结" class="headerlink" title="Class 文件结构总结"></a>Class 文件结构总结</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><p><strong>Class文件字节码结构组织示意图</strong> （之前在网上保存的，非常不错，原出处不明）：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115230948289.png" alt="image-20201115230948289"></p><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>每个 Class 文件的头四个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p><p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p><h3 id="Class-文件版本"><a href="#Class-文件版本" class="headerlink" title="Class 文件版本"></a>Class 文件版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><table><thead><tr><th>类型</th><th>标志（tag）</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>５</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>６</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>７</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>８</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>９</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MothodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v  class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p><p>类访问和属性修饰符:</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231234370.png" alt="image-20201115231234370"></p><p>我们定义了一个 Employee 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231213318.png" alt="image-20201115231213318"></p><h3 id="当前类索引-父类索引与接口索引集合"><a href="#当前类索引-父类索引与接口索引集合" class="headerlink" title="当前类索引,父类索引与接口索引集合"></a>当前类索引,父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p><p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值:</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231147414.png" alt="image-20201115231147414"></p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231123298.png" alt="image-20201115231123298"></p><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 Java 中，JVM 可以理解的代码就叫做&lt;code&gt;字节码&lt;/code&gt;（即扩展名为 &lt;code&gt;.class&lt;/code&gt; 的文件）</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM(二） —— 垃圾回收</title>
    <link href="https://leslieaibin.github.io/2020/11/13/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://leslieaibin.github.io/2020/11/13/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-11-12T16:15:42.000Z</published>
    <updated>2020-11-15T15:13:51.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111225928785.png" alt="image-20201111225928785"></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="JVM内存分配与回收"><a href="#JVM内存分配与回收" class="headerlink" title="JVM内存分配与回收"></a>JVM内存分配与回收</h2><p>Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java自动内存管理最核心的功能是堆内存中对象的分配与回收。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被称作为GC堆（Garbage Collected Heap）. 从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：</p><ul><li>新生代： Eden空间、From Survivor、To Survivor空间</li><li>老年代：Old Memory</li></ul><p><strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111231314990.png" alt="image-20201111231314990"></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。</p><p><strong>动态年龄计算的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">size_t desired_survivor_size = (size_t)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">size_t total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"> total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"> <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line"> age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111232843231.png" alt="image-20201111232843231"></p><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] alocation1,alloction2;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方式运行：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111234604025.png" alt="image-20201111234604025"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111234626646.png" alt="image-20201111234626646"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111234844467.png" alt="image-20201111234844467"></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，永久代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111235001934.png" alt="image-20201111235001934"></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）</p><p>原因：</p><p>为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><p><strong>内存分配担保机制：</strong> 当在新生代无法分配内存的时候，把新生代的对象转移到老生代，然后把新生代，然后把新对象放入腾空的新生代。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"> total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"> <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line"> age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></blockquote><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。</strong> 如果你去Oracle的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.</strong></p><h3 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h3><p>针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="对象已经死亡？"><a href="#对象已经死亡？" class="headerlink" title="对象已经死亡？"></a>对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201112232337258.png" alt="image-20201112232337258"></p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。所谓对象之间的像话引用，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc;</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201112233246468.png" alt="image-20201112233246468"></p><p>可作为GC Roots的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="不可达的对象并非“非死不可”"><a href="#不可达的对象并非“非死不可”" class="headerlink" title="不可达的对象并非“非死不可”"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_24-%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%9D%9E%E9%9D%9E%E6%AD%BB%E4%B8%8D%E5%8F%AF">不可达的对象并非“非死不可”</a></h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title=" 如何判断一个常量是废弃常量？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_25-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F%EF%BC%9F"> 如何判断一个常量是废弃常量？</a></h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><ul><li><p><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></p></li><li><p><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</p></li><li><p><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p></li></ul><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_26-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB">如何判断一个类是无用的类</a></h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（Mark-Sweep"><a href="#标记-清除算法（Mark-Sweep" class="headerlink" title="标记-清除算法（Mark-Sweep)"></a>标记-清除算法（Mark-Sweep)</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155330cfb489a9" alt="标记-清除算法"></p><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p><p><strong>优点：</strong>简单</p><p><strong>缺点：</strong></p><ul><li>效率问题 执行时间不稳定，如果Java堆中包含大量对象，某一次回收时无用的对象非常多，这时候会花费很多时间进行内存的清理</li><li>空间问题 标记清除后产生大量不连续的碎片  上图只是一个理想的删除过程，正好没有内存碎片产生，而实际上在内存中待清除的内存有可能不是连续的，导致会产生许多内存碎片，如果某个大对象无法找到一块连续的内存进行存放时，会误以为堆内存不足，提前触发<code>Full GC</code></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552725604fc95" alt="放入内存失败"></p><p>所以为了<strong>解决内存碎片问题</strong>，科学家们研制出了一种新的算法：标记-复制算法</p><h3 id="标记-复制算法（Mark-Copying）"><a href="#标记-复制算法（Mark-Copying）" class="headerlink" title="标记-复制算法（Mark-Copying）"></a>标记-复制算法（Mark-Copying）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1715531a50e73a3a" alt="标记-复制"></p><p>由上面的动图可以看出，标记-复制算法将原本的<strong>堆内存划分了两个区域</strong>，采用了“半区复制”算法，将一半的内存省出来，当发生垃圾收集行为时，将存活的对象复制到另外一半保留区域中<strong>连续存放</strong>。</p><p>标记-复制算法的优点是解决了<strong>大对象</strong>分配内存的<code>内存碎片问题</code>，也解决了标记-清除算法中大量垃圾对象导致的<code>清除效率问题</code>。</p><p>缺点也非常的明显，那就是<strong>可分配的内存空间少了整整一半</strong>，而且如果某次存活的对象较多，甚至<strong>全部存活</strong>，那么复制的效率将会非常低。</p><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）<img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1715532188455c17" alt="标记-整理"></h3><p>为了提升内存的利用率，科学家提出了标记-整理算法，该算法的起始过程和<code>标记-清除</code>算法相同，先标记处待回收对象的内存区域，但是在清除时不是对所有可回收对象清除，而是<strong>让所有存活对象往内存空间的一边移动</strong>，把存活对象边界外的内存直接清空掉。</p><p>标记-整理算法<strong>提高了内存的利用率</strong>、解决了<strong>大对象分配时的内存碎片问题</strong>，看似完美的垃圾收集算法，也有它的弊端。在移动存活对象的过程中，需要全程暂停用户程序的执行，被设计者称为“<strong>Stop The World</strong>”。</p><h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h3><p>新生代垃圾收集及内存分配</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1715531245ade622" alt="分代收集"></p><p>分代收集算法本质上<strong>标记-复制算法</strong>，它把堆内存中较大的一块区域作为<strong>新生代区域</strong>，新生代区域中分为一个Eden区域和两个Survivor区域，Eden和Survivor的比例默认是<strong>8:1</strong>，因为在Eden区域，绝大数对象都熬不过第一轮GC（98%），所以每个Survivor区域只需要10%的空间就足矣了，每一次触发<code>Minor GC</code>时，就会将Eden区和Survivor区存活的对象复制到另外一个Survivor区域中，然后清除掉被回收的对象，每次都依据这样的步骤进行垃圾收集。</p><p>不知道你有没有注意到每个对象有一个数字的标记，这个标记是<strong>对象的年龄</strong>，当对象到了<strong>15岁以后</strong>（默认情况）就会被晋升为<strong>老年代</strong></p><h4 id="晋升老年代"><a href="#晋升老年代" class="headerlink" title="晋升老年代"></a>晋升老年代</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171553164b071572" alt="晋升老年代"></p><p>如图所示，当对象在Survivor区存活了15次以后，就会晋升为老年代对象。</p><p>还有以下情况会晋升为老年代对象：</p><blockquote><p><strong>大对象</strong>。当对象所占连续内存非常大时，不会分配在Eden区，如果分配在Eden区，那么对象存活时产生的复制操作将导致效率大大降低。</p><p>如果在Survivor区，相同年龄的<strong>对象总大小</strong>大于<strong>Survivor区空间的一半</strong>时，也会将这些年龄相同的对象直接晋升到老年代，原因也是防止对象的复制操作导致的效率问题。</p></blockquote><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在对象无法分配到Eden区时，会触发一次<code>Minor GC</code>，JVM会首先检查<strong>老年代最大的可用连续空间</strong>是否大于<strong>新生代所有对象的总和</strong>，如果大于，那么这次<code>Minor GC</code>是安全的，如果<strong>不大于</strong>的话，JVM就需要判断<code>HandlePromotionFailure</code>是否允许空间分配担保。</p><p>如果允许担保，则证明老年代的连续可用内存空间大于历次晋升到老年代对象的平均大小，此时触发一次<code>Minor GC</code>，如果小于，那么证明老年代并没有把握放得下Survivor区有可能晋升的对象，此时发生一次<code>Full GC</code>。</p><h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><p>发生<code>GC</code>(MinorGC或者FullGC)时，都会将用户线程停顿并进行垃圾收集，在<code>Minor GC</code>中，<code>STW</code>的时间较短，只涉及<code>Eden</code>和<code>survivor</code>区域的对象清除和复制操作，而<code>Full GC</code>则是对整个堆内存进行垃圾收集，对象的扫描、标记和清除操作工作量大大提高，所以<code>Full GC</code>会导致用户线程停顿较长时间，如果频繁地发生<code>Full GC</code>，那么用户线程将无法正常执行。</p><p>或者通俗的理解：</p><blockquote><p>你给你妈妈打扫房间时，你是希望她坐在一旁静静等你扫完地再继续活动，还是想你一边扫地，她一边丢垃圾呢？</p></blockquote><h4 id="Safe-Points"><a href="#Safe-Points" class="headerlink" title="Safe Points"></a>Safe Points</h4><p>既然要<strong>用户线程停顿下来</strong>，那么要在什么地方停顿呢？JVM采用<strong>主动式中断方式</strong>告诉Java线程需要停顿了，JVM在特定的位置设置了这些安全点（Safe point），让线程可以在这些安全点主动挂起。</p><blockquote><p>方法调用、循环跳转、异常跳转</p></blockquote><p>这些安全点的特征是<strong>令程序有可能进行某一段长时间执行的特征</strong>。</p><p>在这些安全点上存有对象引用信息的<code>OopMap</code>数据结构，这种数据结构你可以理解为<code>HashMap</code>这种数据结构，它内部存储了什么位置上存储了对象引用信息，这些信息在类加载完成时就确定下来了。所以JVM在垃圾收集时不需要从一个个方法的<code>GC Roots</code>去扫描，从<code>OopMap</code>中可以快速准确地定位到这些<code>GC Roots</code>。</p><blockquote><p>如果用户线程本身处于停顿状态，例如阻塞（Blocked）、睡觉（Sleep），那么此时触发GC时，用户线程无法响应JVM的中断（我听不见你喊我，我睡着了~），用户线程无法主动地跑去安全点中断挂起，此时该怎么办呢？</p></blockquote><p>对于这种情况，必须引入<strong>Safe Region</strong>来解决。</p><h4 id="Safe-Region"><a href="#Safe-Region" class="headerlink" title="Safe Region"></a>Safe Region</h4><p>安全区域是指，用户线程进入某一段代码区域中时，引用关系不会发生变化，那么在这片代码区域的任何地方开始GC都不会受到影响。实现的方式是，用户线程进入安全区域时<strong>会标识自己已经进入安全区域</strong>，在JVM发起GC时<strong>不必理会那些已经标识为进入安全区域的线程</strong>，当用户线程<strong>需要离开安全区域时</strong>，会主动检查JVM是否已经完成了<strong>需要停顿线程的工作</strong>，如果已完成则可以离开，如果未完成则<strong>必须一直等待</strong>，直到JVM发送可以离开安全区域的信号为止。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集器分为新生代收集器与老年代收集器，各种不同的收集器之间如果符合标准则可以相互搭配使用。</p><h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552728c19c34d" alt="Serial/Serial Old收集器"></p><p>Serial收集器是一款单线程的垃圾收集器，“单线程”的<strong>意义</strong>不仅仅是指它只能用一条线程或占用一个处理器去完成垃圾收集操作，更重要的是它进行垃圾收集时，<strong>需要暂停其它所有线程，直到垃圾收集结束。</strong>它身为最古老的一款垃圾收集器，在当今依旧广泛受用，它有以下优点：</p><ul><li><p>对于内存受限的环境，它是所有收集器里额外内存消耗最小的</p></li><li><p>没有线程交互的开销，Serial收集器可以很好地专注于收集垃圾，把用户线程都停掉</p></li></ul><p>在用户桌面的应用场景和近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般不会特别大，收集几十兆、一两百兆的新生代（桌面应用的新生代甚至少于这个容量），垃圾收集完全可以控制在十几、几十毫秒，最多一百毫秒，这点停顿时间对用户来说是十分友好的。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272bc663994" alt="parNew收集器"></p><p>ParNew是一款<strong>并行新生代收集器</strong>，parNew收集器除了支持多线程并行收集以外，<strong>其余的行为与Serial收集器完全一致</strong>，包括收集算法、STW（Stop The World）、对象分配规则、回收策略等等。</p><p>parNew是不少运行在服务器端模式下的HotSpot虚拟机中首选的新生代收集器，其中一个与性能、功能无关但很重要的原因是：<strong>除了Serial收集器，只有ParNew能够与CMS收集器配合工作。</strong></p><p>CMS收集器与Parallel Scavenge收集器不能配合工作的一个原因是：Parallel Scavenge收集器内部并<strong>没有按照分代收集的框架进行设计垃圾回收</strong>，在之后的<strong>G1收集器</strong>也同样没有按照分代回收的框架设计。</p><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201113001642889.png" alt="image-20201113001642889"></p><p>Parallel Scavenge收集器同样是基于标记-复制算法实现的收集器，也是能够并行收集的一款新生代收集器，那它与ParNew收集器的<strong>差别在哪里呢？</strong></p><p>Parallel Scavenge收集器的特别之处在于它与其它收集器的关注点不一样，其它垃圾收集器关注如何<strong>最大限度地减少STW的时间</strong>，而Parrel Scavenge关注的是<strong>如何达到一个可控制的吞吐量（Throughput）</strong>，由于与吞吐量关系密切，所以也被称作“吞吐量优先收集器”。</p><p>Parallel Scavenge收集器可以实现<strong>自适应策略</strong>，这是另外一个与ParNew收集器的差别，可以通过指定<code>-XX:UseAdaptiveSizePolicy</code>参数，虚拟机就会根据系统当前的运行情况收集监控信息，并且<strong>自动调整系统的相关JVM参数以提供最高的吞吐量和最合适的停顿时间</strong>。</p><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552728c19c34d" alt="Serial/Serial Old收集器"></p><p>使用<code>标记-整理</code>算法，是一个单线程收集器，它有另外两个用途：</p><blockquote><p>它作为CMS收集器发生失败后的后备预案，在CMS收集器并发收集发生Concurrent Mode Failure使用</p><p>作为Parallel Scavenge的老年代收集器</p></blockquote><p>这个时候就有疑惑了，<code>Parallel Scavenge</code>收集器不是没有按分代收集框架实现吗，为什么能够搭配<code>Serial Old</code>收集器使用</p><p>《深入理解Java虚拟机》：<code>Parallel Scavenge</code>收集器架构中含有<code>PS MarkSweep</code>收集器进行老年代收集，并非直接调用<code>Serial Old</code>收集器，但是<code>PS MarkSweep</code>与<code>Serial Old</code>的实现几乎是一样的，所以官方很多地方用<code>Serial Old</code>代替它进行讲解。</p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272c2e877cc" alt="Parallel Scavenge/Parallel Old"></p><p><code>Parallel Old</code>是<code>Parallel Scavenge</code>的老年代版本，支持多线程并发收集，基于<code>标记-整理</code>算法设计，自从JDK6以后，<code>Parallel Old</code>和<code>Parallel Scavenge</code>成为了最好的搭档，在<strong>注重吞吐量或者处理器资源比较紧缺</strong>的情况下，都可以采用这个组合。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是基于获取<strong>最短回收停顿时间</strong>为目标的收集器，CMS收集器适合追求服务的响应速度的应用，例如基于浏览器的B/S系统的服务端上。</p><p>CMS是基于<code>标记-清除</code>算法设计的，它支持用户线程与GC线程并发执行，如下图所示</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272c6924308" alt="CMS收集器"></p><p>运作过程分为4个阶段：</p><blockquote><p>初始标记、并发标记、重新标记、并发清除</p></blockquote><p>初始标记的过程就是扫描GC Roots；</p><p>并发标记是扫描GC Roots链上所有的对象，此时会出现一些对象标记的变动，因为用户线程仍然在执行；</p><p>重新标记的过程是修正并发标记期间产生引用变动的那一部分对象的标记记录</p><p>并发清除是删除掉标记阶段判断已经死亡的对象，由于不用移动存活对象，此时也是可以并发执行的。</p><p>CMS收集器有三个缺点：</p><ol><li>对处理器资源特别敏感，由于是并发执行，所以CMS收集器工作时会占用一部分CPU资源而导致用户程序变慢，降低总吞吐量，建议具有四核处理器以上的服务器使用CMS收集器</li><li>CMS无法清除浮动垃圾，有可能出现<code>Concurrent Mode Failure</code>失败而导致另一次<code>STW</code>的<code>Full GC</code>产生。由于并发清理过程中用户线程与GC线程并发执行，就一定会产生新的垃圾对象，但是无法在本次GC中处理这些垃圾对象，不得不推迟到下一次GC中处理，这些垃圾对象就称为“浮动垃圾”，到JDK6的时候，CMS收集器启动阈值达到<code>92%</code>，也就是老年代占了<code>92%</code>的空间后会触发GC，但是如果剩余的内存<code>8%</code>不足以分配新对象时，就会发生“并发失败”，进而冻结用户线程，使用<code>Serial Old</code>收集器进行一次<code>Full GC</code>，所以触发CMS收集器的阈值还是根据实际场景来设置，参数为<code>-XX:CMSInitiatingOccu-pancyFraction</code>。</li><li>基于<code>标记-清除</code>算法会导致内存碎片不断增多，在分配大对象时有可能会提前触发一次<code>Full GC</code>。所以CMS提供两个参数可供开发者指定在每次<code>Full GC</code>时进行<strong>碎片整理</strong>，由于碎片整理需要移动对象，所以是无法并发收集的，<code>-XX:+UseCMSCompactAtFullCollection</code>(JDK9开始废弃)，<code>-XX:CMSFullGCsBeforeCompaction</code>(JDK9开始废弃，默认值是0，每次Full GC都进行碎片整理)。</li></ol><h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>这是一个在垃圾收集器技术发展历史上的里程碑式的成果，它取代了<code>Parallel Scavenge + Parallel Old</code>的组合，并取代了<code>CMS</code>，作为它们的继承者和替代者，G1到底有什么魔力呢？</p><blockquote><p>G1是一种“<strong>停顿时间模型</strong>”收集器，也就是说可以指定在时间片段为<code>M</code>毫秒时，垃圾收集所占用的时间不会超过<code>N</code>毫秒。</p><p>G1颠覆了之前的所有垃圾收集器的垃圾收集行为：要么新生代收集（Minor GC）、要么老年代收集（Major GC）、要么整堆收集（Full GC），而G1可以面向<strong>堆内存任何部分组成回收集</strong>（Collection Set , CSet），衡量标准不再是它属于哪个分代，而是<strong>哪块内存存放的垃圾数量较多</strong>，这就是G1所特有的Mixed GC模式。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272c785ce97" alt="G1堆内存布局"></p><p>可以看到上图中每一个方块就是一个Region，每个Region可以存放1~32MB大小的对象，使用参数<code>-XX:G1HeapRegionSize</code>指定，Region中可以存放<code>Eden</code>/<code>Survivor</code>/<code>Humongous</code>/<code>Old</code>，G1中新生代和老年代并不是连续存放的，而是一个动态的集合。</p><p>注意在G1中专门用<code>Region</code>存放一个<code>Humongous</code>大对象，当对象容量大于Region的一半时就认为它是大对象，按照“大对象优先在老年代中分配”，<code>Humongous</code>也是老年代的一部分对象。</p><p>G1收集器将<code>Region</code>单元看出是最小的内存回收单元，每次发生GC时，G1收集器都会评估各个<code>Region</code>的<strong>价值大小</strong>，根据用户所指定的收集停顿时间来优先处理那些回收价值最大的<code>Region</code>，这也是<code>Garbage First</code>的由来。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552abf5ed5ea5" alt="G1收集器垃圾收集"></p><p>G1收集器的运作过程可以分为4个步骤：</p><blockquote><p><strong>初始标记</strong>：仅记录GC Roots对象，需要停顿用户线程，但时间很短，借助<code>Minor GC</code>同步完成。</p><p><strong>并发标记</strong>：从GC Roots开始遍历扫描所有的对象进行可达性分析，找出要回收的对象，由于是并发标记，有可能在扫描过程中出现引用变动。</p><p><strong>最终标记</strong>：将并发标记过程中出现变动的对象引用给纠正过来。</p><p><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户所希望的停顿时间来制定回收计划，选取任意多个Region区域进行回收，把回收的Region区域中的存活对象复制到空的Region区域中，然后清空掉原来的Region区域，涉及对象的移动，所以需要暂停用户线程，由多条GC线程并行完成。</p></blockquote><p>如何设置G1的停顿时间？<code>-XX:MaxGCPauseMillis</code></p><p>G1的停顿时间不能过短，如果停顿时间过短，那么每次GC收集都只会回收占用Region内存区域很小的一部分，而随着内存不断分配，堆上的垃圾越来越多，GC的速度低于分配的速度，就会触发<code>Full GC</code>，所以，只要我们把停顿时间设置后的效果为<strong>垃圾回收的速度与内存分配的速度大致相同</strong>，那么在理论上来说就永远不会发生<code>Full GC</code>，<strong>这也是G1被称为很牛逼的一个地方。</strong></p><h3 id="G1和CMS的比较"><a href="#G1和CMS的比较" class="headerlink" title="G1和CMS的比较"></a>G1和CMS的比较</h3><blockquote><p>G1从整体上看是“标记-整理”算法，从局部（两个Region之间）上看是“标记-复制”算法，不会产生内存碎片，而CMS基于“标记-清除”算法会产生内存碎片。</p><p>G1在垃圾收集时产生的内存占用和程勋运行时的额外负载都比CMS高</p><p>G1支持动态指定停顿时间，而CMS无法指定</p><p>两者都利用了并发标记这个技术</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本文导火索&quot;&gt;&lt;a href=&quot;#本文导火索&quot; class=&quot;headerlink&quot; title=&quot;本文导火索&quot;&gt;&lt;/a&gt;本文导火索&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://test-1874253.oss-cn-beijing.aliyuncs.com/</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>1.线程、进程、协程</title>
    <link href="https://leslieaibin.github.io/2020/11/11/Java/Thread/1.%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https://leslieaibin.github.io/2020/11/11/Java/Thread/1.%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-11T15:40:42.000Z</published>
    <updated>2021-04-28T06:35:40.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p><p>直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p><p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><p>线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。线程拥有自己的栈空间。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110233822293.png" alt="image-20201110233822293"></p><p>有人给出了很好的归纳：</p><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong>无论进程还是线程，都是由操作系统所管理的。Java中线程具有五种状态：</p><p><strong>初始化 可运行 运行中 阻塞 销毁</strong></p><p>这五种状态的转化关系如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110234003671.png" alt="image-20201110234003671"></p><p>但是，线程不同状态之间的转化是谁来实现的呢？是JVM吗？</p><p>并不是。JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p><p><strong>进程和线程的痛点</strong></p><p>线程之间是如何进行协作的呢？</p><p>最经典的例子就是<strong>生产者/消费者模式</strong>：</p><p>若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110234117470.png" alt="image-20201110234117470"></p><p>如何用java语言实现生产者/消费者模式呢？</p><p>让我们来看一看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="keyword">private</span> <span class="keyword">final</span> Queue sharedQueue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码做了下面几件事：</p><ul><li><p>定义了一个生产者类，一个消费者类。</p></li><li><p>生产者类循环100次，向同步队列当中插入数据。</p></li><li><p>消费者循环监听同步队列，当队列有数据时拉取数据。</p></li><li><p>如果队列满了（达到5个元素），生产者阻塞。</p></li><li><p>如果队列空了，消费者阻塞。</p></li></ul><p>上面的代码正确地实现了生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：</p><ul><li><p>涉及到同步锁。</p></li><li><p>涉及到线程阻塞状态和可运行状态之间的切换。</p></li><li><p>涉及到线程上下文的切换。</p></li></ul><p>以上涉及到的任何一点，都是非常耗费性能的操作。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110234418452.png" alt="image-20201110234418452"></p><p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p><p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM(一） —— 内存区域简介</title>
    <link href="https://leslieaibin.github.io/2020/11/10/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/"/>
    <id>https://leslieaibin.github.io/2020/11/10/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-09T16:15:42.000Z</published>
    <updated>2020-11-15T15:13:52.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域</p><p><strong>JDK 1.8 之前：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110143215274.png" alt="image-20201110143215274"></p><p><strong>JDK 1.8 ：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110143245341.png" alt="image-20201110143245341"></p><p>线程私有：</p><ul><li>程序计时器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享：</p><ul><li>堆</li><li>方法区</li><li>直接内存</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值，我们通过下面这段程序可以测试一下这个结果：</p><p>栈溢出测试源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorMock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index++;</span><br><span class="line">        call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackErrorMock mock = <span class="keyword">new</span> StackErrorMock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mock.call();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stack deep : &quot;</span>+index);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110150002504.png" alt="image-20201110150002504"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110150018247.png" alt="image-20201110150018247"></p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：</p><ul><li><p>return 语句。</p></li><li><p>抛出异常。</p></li></ul><p>不管哪种返回方式都会导致栈帧被弹出。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永生代(Permanent Generation)</li></ol><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110151449540.png" alt="image-20201110151449540"></p><p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110151457988.png" alt="image-20201110151457988"></p><p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p><p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">  uint age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ul><li><p><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p></li><li><p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p></li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>方法区也被称为永久代。</p><h4 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h4><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h4 id="为什么要将永久代（PermGen）替换为元空间（Meta-Space）呢？"><a href="#为什么要将永久代（PermGen）替换为元空间（Meta-Space）呢？" class="headerlink" title="为什么要将永久代（PermGen）替换为元空间（Meta Space）呢？"></a>为什么要将永久代（PermGen）替换为元空间（Meta Space）呢？</h4><p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><ul><li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li><li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li></ul><h3 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><ul><li><p>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</p></li><li><p>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 。</p></li><li><p>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</p></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110161814048.png" alt="image-20201110161814048"></p><h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：指针碰撞、空闲列表</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><ul><li><p><strong>指针碰撞</strong>：用过的内存全部放到一边，没用的内存放在另一边，中间有分界值指针，分配地址时只需要将指针向没用的内存移动对象内存大小位置即可(GC收集器：ParNew,Serial)</p></li><li><p><strong>空闲列表：</strong>虚拟机维护一个列表，该列表记录那些内存块是可用的，在分配内存时找一块足够大的内存分配给对象实例，然后更新列表记录；（GC收集器：cms）</p></li></ul><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110163702065.png" alt="image-20201110163702065"></p><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110163723635.png" alt="image-20201110163723635"></p><p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>; <span class="comment">//先检查字符串常量池中有没有“abcd&quot;, </span></span><br><span class="line"><span class="comment">//如果字符串常量池中没有，则创建一个,然后str1指向字符串常量池中的对象，</span></span><br><span class="line"><span class="comment">//如果有，则直接将str1指向“abcd&quot;</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>); <span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>); <span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这两种不同的创建方法是有差别的。</p><ul><li>第一种方式是在常量池中拿对象；</li><li>第二种方式是直接在堆内存空间创建一个新的对象。</li></ul><p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110164736482.png" alt="image-20201110164736482"></p><p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象      </span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110165340549.png" alt="image-20201110165340549"></p><p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p><h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><h3 id="8-种基本类型的包装类和常量池"><a href="#8-种基本类型的包装类和常量池" class="headerlink" title="8 种基本类型的包装类和常量池"></a>8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;         </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">static</span> &#123;             </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)                 </span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);         </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 缓存源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><ul><li><p>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</p></li><li><p>Integer i1 = new Integer(40);这种情况下会创建新的对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 比较更丰富的一个例子:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));<span class="comment">//true </span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));   <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构简介</title>
    <link href="https://leslieaibin.github.io/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    <id>https://leslieaibin.github.io/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-07T16:15:42.000Z</published>
    <updated>2020-11-08T14:17:41.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><p>数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率。</p><p>如下图所示，常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1599638810-SZDwfK-Picture1.png" alt="Picture1.png"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1599587176-JAxwpf-Picture2.png" alt="Picture2.png"></p><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>为了在程序中使用一个数组，必须声明一个引用该数组的变量，并指明整个变量可以引用的数组类型。声明一维数组的语法格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName; <span class="comment">//数据类型[] 数组名;</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">type arrayName[]; <span class="comment">//数据类型 数组名[];</span></span><br></pre></td></tr></table></figure><p>数组的声明有两种形式：一种是中括号”[]“跟在元素数据类型之后，另一种是中括号”[]“跟在变量名之后。</p><p>对于以上两种语法格式而言，Java 更推荐采用第一种声明格式，因为第一种格式不仅具有更好的语意，而且具有更好的可读性。其中的数据类型既可以是基本数据类型，也可以是引用数据类型。数组名可以是任意合法的变量名。声明数组就是要告诉计算机该数组中数据的类型是什么。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] score;<span class="comment">//存储学生的成绩，类型是整型</span></span><br><span class="line"><span class="keyword">double</span>[] price;<span class="comment">//存储商品的价格，类型是浮点型</span></span><br><span class="line">String[] name;<span class="comment">//存储商品名称，类型为字符串型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明数组时不需要规定数组的长度，例如：</span></span><br><span class="line"><span class="keyword">int</span> score[<span class="number">10</span>];<span class="comment">//这是错误的</span></span><br></pre></td></tr></table></figure><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>声明了数组，只是得到了一个存放数组的变量，并没有为数组元素分配内存空间，不能使用。因此要为数组分配内存空间，这样数组的每一个元素才有一个空间进行存储。</p><p>简单地说，分配空间就是要告诉计算机在内存中为它分配几个连续的位置来存储数据。在 Java 中可以使用 new 关键字来给数组分配空间。分配空间的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[size];<span class="comment">//数组名 = new 数据类型[数组长度]</span></span><br></pre></td></tr></table></figure><p>其中，数组长度就是数组中能存放的元素个数，显然应该为大于 0 的整数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">price = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br><span class="line">name = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>这里的 score 是已经声明过的 int[] 类型的变量，当然也可以在声明数组时就给它分配空间，语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> type[size];    <span class="comment">// 数据类型[] 数组名 = new 数据类型[数组长度];</span></span><br></pre></td></tr></table></figure><p>例如，声明并分配一个长度为 5 的 int 类型数组 arr，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/3-1Q016111945238.jpg" alt="img"></p><p>在图  中 arr 为数组名称，方括号“[]”中的值为数组的下标。数组通过下标来区分数组中不同的元素，并且下标是从 0 开始的。因此这里包含 5 个元素的 arr 数组最大下标为 4。</p><p>注意：一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。</p><h4 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h4><p>Java 语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。</p><p>能不能只分配内存空间，不赋初始值呢？</p><p>不行，一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容为空，这个空也是一个值（null）。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种形式，一种由系统自动分配，另一种由程序员指定。</p><p>数组在初始化数组的同时，可以指定数组的大小，也可以分别初始化数组中的每一个元素。在 Java 语言中，初始化数组有以下 3 种方式。</p><ul><li><strong>使用new指定数组大小后进行初始化</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br></pre></td></tr></table></figure><p>创建数组后元素是不确定的，需要对数组的元素进行赋值，其下标从0开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">number[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">number[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">number[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">number[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>如果程序员只指定了数组的长度，那么系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值。</p><p>数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的值是 0。</p><p>数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是 0.0。</p><p>数组元素的类型是基本类型中的字符类型（char），则数组元素的值是‘\u0000’。</p><p>数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是 false。</p><p>数组元素的类型是引用类型（类、接口和数组），则数组元素的值是 null。</p><ul><li><strong>使用 new 指定数组元素的值</strong></li></ul><p>使用上述方式初始化数组时，只有在为元素赋值时才确定值。可以不使用上述方式，而是在初始化时就已经确定值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> type[]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,值 <span class="number">4</span>,• • •,值 n&#125;;</span><br></pre></td></tr></table></figure><p>指定数组元素的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p>上述代码的效果等价于第一种的效果。</p><p>注意：不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值，这样会造成代码错误。例如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">5</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">//这样是错误的</span></span><br></pre></td></tr></table></figure><ul><li>直接指定数组元素的值</li></ul><p>在上述两种方式的语法中，type 可以省略，如果已经声明数组变量，那么直接使用这两种方式进行初始化。如果不想使用上述两种方式，那么可以不使用 new 直接指定数组元素的值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = &#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,...,值 n&#125;;</span><br></pre></td></tr></table></figure><p>在前面例子的基础上更改代码，直接使用上述语法实现 number 数组的初始化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p>使用这种方式时，数组的声明和初始化操作要同步，即不能省略数组变量的类型。如下的代码就是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number;</span><br><span class="line">number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="获取单个元素"><a href="#获取单个元素" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>获取单个元素是指获取数组中的一个元素，如第一个元素或最后一个元素。获取单个元素的方法非常简单，指定元素所在数组的下标即可。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[index];</span><br></pre></td></tr></table></figure><p>其中，arrayName 表示数组变量，index 表示下标，下标为 0 表示获取第一个元素，下标为 array.length-1 表示获取最后一个元素。当指定的下标值超出数组的总长度时，会拋出 ArraylndexOutOfBoundsException 异常。</p><p>获取 number 数组中的第一个元素、最后一个元素和第六个元素，并将元素的值输出。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;获取第一个元素：&quot;</span>+number[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取最后一个元素：&quot;</span>+number[number.length-<span class="number">1</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取第6个元素：&quot;</span>+number[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>执行上述代码，输出结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第一个元素：1</span></span><br><span class="line"><span class="comment">//获取最后一个元素：8</span></span><br><span class="line"><span class="comment">//java.lang.ArrayIndexOutOfBoundsException: 5</span></span><br></pre></td></tr></table></figure><h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h3><h4 id="声明数组-1"><a href="#声明数组-1" class="headerlink" title="声明数组"></a>声明数组</h4><p>在 Java 中二维数组被看作数组的数组，即二维数组为一个特殊的一维数组，其每个元素又是一个一维数组。Java 并不直接支持二维数组，但是允许定义数组元素是一维数组的一维数组，以达到同样的效果。声明二维数组的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[][];    <span class="comment">// 数据类型 数组名[][];</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type[][] arrayName;    <span class="comment">// 数据类型[][] 数组名;</span></span><br></pre></td></tr></table></figure><p>其中，type 表示二维数组的类型，arrayName 表示数组名称，第一个中括号表示行，第二个中括号表示列。</p><p>下面分别声明 int 类型和 char 类型的数组，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] age;</span><br><span class="line"><span class="keyword">char</span>[][] sex;</span><br></pre></td></tr></table></figure><h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p>二维数组可以初始化，和一维数组一样，可以通过 3 种方式来指定元素的初始值。这 3 种方式的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[][] arrayName = <span class="keyword">new</span> type[][]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,…,值 n&#125;;    <span class="comment">// 在定义时初始化</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> type[size1][size2];    <span class="comment">// 给定空间，在赋值</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> type[size][];    <span class="comment">// 数组第二维长度为空，可变化</span></span><br></pre></td></tr></table></figure><p>使用第一种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>使用第二种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>使用第三种方式声明 int 类型的二维数组，并且初始化数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure><h4 id="获取单个元素-1"><a href="#获取单个元素-1" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>在上部分使用的前 2 种方式创建并初始化了一个二行二列的 int 类型数组 temp。当需要获取二维数组中元素的值时，也可以使用下标来表示。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>其中，arrayName 表示数组名称，i 表示数组的行数，j 表示数组的列数。例如，要获取第二行第二列元素的值，应该使用 temp[1][1]来表示。这是由于数组的下标起始值为 0，因此行和列的下标需要减 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123;&#123;<span class="number">10.0</span>,<span class="number">99</span>,<span class="number">99</span>&#125;,&#123;<span class="number">100</span>,<span class="number">98</span>,<span class="number">97</span>&#125;,&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">99.5</span>&#125;,&#123;<span class="number">99.5</span>,<span class="number">99</span>,<span class="number">98.5</span>&#125;&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;第二行第二列元素的值：&quot;</span>+class_score[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四行第一列元素的值：&quot;</span>+class_score[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二行第二列元素的值：<span class="number">98.0</span></span><br><span class="line">第四行第一列元素的值：<span class="number">99.5</span></span><br></pre></td></tr></table></figure><h4 id="获取全部元素"><a href="#获取全部元素" class="headerlink" title="获取全部元素"></a>获取全部元素</h4><p>在一维数组中直接使用数组的 length 属性获取数组元素的个数。而在二维数组中，直接使用 length 属性获取的是数组的行数，在指定的索引后加上 length（如 array[0].length）表示的是该行拥有多少个元素，即列数。</p><p>如果要获取二维数组中的全部元素，最简单、最常用的办法就是使用 for 语句。在一维数组全部输出时，我们使用一层 for 循环，而二维数组要想全部输出，则使用嵌套 for 循环（2 层 for 循环）。</p><p>使用 for 循环语句遍历 double 类型的 class_score 数组的元素，并输出每一行每一列元素的值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; class_score.length; i++) &#123; <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; class_score[i].length; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;class_score[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;]=&quot;</span> + class_score[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用嵌套 for 循环语句输出二维数组。在输出二维数组时，第一个 for 循环语句表示以行进行循环，第二个 for 循环语句表示以列进行循环，这样就实现了获取二维数组中每个元素的值的功能。</p><p>执行上述代码，输出结果如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class_score[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">98.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">97.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">99.5</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">99.5</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">98.5</span></span><br></pre></td></tr></table></figure><h3 id="创建多维数组"><a href="#创建多维数组" class="headerlink" title="创建多维数组"></a>创建多维数组</h3><p>除了一维数组和二维数组外，Java中还支持更多维的数组，如三维数组、四维数组和五维数组等，它们都属于多维数组。经过前面一维，二维的练习后不难发现，想要提高数组的维数，只要在声明数组时将索引与中括号再加一组即可，所以三维数组的声明为 int score[][][]，而四维数组为 int score[][][][]，以此类推。</p><p>通常也将二维数组看作是多维数组。本文以三维数组为例来介绍多维数组。</p><p>三维数组有三个层次，可以将三维数组理解为一个一维数组，其内容的每个元素都是二维数组。依此类推，可以获取任意维数的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[][][] namelist = &#123; &#123; &#123; <span class="string">&quot;张阳&quot;</span>, <span class="string">&quot;李风&quot;</span>, <span class="string">&quot;陈飞&quot;</span> &#125;, &#123; <span class="string">&quot;乐乐&quot;</span>, <span class="string">&quot;飞飞&quot;</span>, <span class="string">&quot;小曼&quot;</span> &#125; &#125;,</span><br><span class="line">            &#123; &#123; <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Kimi&quot;</span> &#125;, &#123; <span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span> &#125; &#125;, &#123; &#123; <span class="string">&quot;徐璐璐&quot;</span>, <span class="string">&quot;陈海&quot;</span> &#125;, &#123; <span class="string">&quot;李丽丽&quot;</span>, <span class="string">&quot;陈海清&quot;</span> &#125; &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; namelist.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; namelist[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; namelist[i][j].length; k++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;namelist[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;][&quot;</span> + k + <span class="string">&quot;]=&quot;</span> + namelist[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=张阳</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=李风</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>]=陈飞</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=乐乐</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=飞飞</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>]=小曼</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=Jack</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]=Kimi</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=Lucy</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=Lily</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>]=Rose</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>]=徐璐璐</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">0</span>][<span class="number">1</span>]=陈海</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>]=李丽丽</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">1</span>][<span class="number">1</span>]=陈海清</span><br></pre></td></tr></table></figure><h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><h4 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h4><p>将一个数组(变长参数的语法糖实现就是数组)转变成一个List(确切的来说是ArrayList)，注意这个List是定长的，企图添加或者删除数据都会报错（java.lang.UnsupportedOperationException）.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//3,4,2,1,5,7,6</span></span><br></pre></td></tr></table></figure><p>但是，对于基础类型（比如byte,int,float等）千万不要想着这么实现（案例1-2，勿效仿）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br></pre></td></tr></table></figure><p>因为List list = Arrays.asList(a);会变成List&lt;int[]&gt; list = Arrays.asList(a);所以遍历需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] arr:list)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作就显得非常的烦琐。因为预想List是List<Integer>形式的，没想到是List&lt;int[]&gt;形式的。使用的时候要特别的注意一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a[] = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><strong>对数组进行排序</strong>。适合byte,char,double,float,int,long,short等基本类型，还有Object类型（实现了Comparable接口），如果提供了比较器Comparator也可以适用于泛型。</p><p>案例（基础类型，输出：[1, 1, 4, 4, 5, 6, 7, 9]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure><p>案例（String类型(Object)，实现了Comparable接口，输出：[s1, s2, s3, s4]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br></pre></td></tr></table></figure><p>案例 （自定义类型，实现了Comparable接口，输出：[jj:17, zzh:18, qq:19]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person1 persons[] = <span class="keyword">new</span> Person1[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Person1(<span class="string">&quot;zzh&quot;</span>,<span class="number">18</span>),<span class="keyword">new</span> Person1(<span class="string">&quot;jj&quot;</span>,<span class="number">17</span>),<span class="keyword">new</span> Person1(<span class="string">&quot;qq&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(persons);</span><br><span class="line">System.out.println(Arrays.toString(persons));</span><br></pre></td></tr></table></figure><p>案例（泛型，如果类型没有实现Comparable接口，可以通过Comparator实现排序）[jj:17, zzh:18, qq:19]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person2 persons2[] = <span class="keyword">new</span> Person2[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Person2(<span class="string">&quot;zzh&quot;</span>,<span class="number">18</span>),<span class="keyword">new</span> Person2(<span class="string">&quot;jj&quot;</span>,<span class="number">17</span>),<span class="keyword">new</span> Person2(<span class="string">&quot;qq&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(persons2,<span class="keyword">new</span> Comparator&lt;Person2&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person2 o1, Person2 o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 == <span class="keyword">null</span> || o2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(persons2));</span><br></pre></td></tr></table></figure><h4 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h4><p>通过二分查找法对已排序（譬如经过Arrays.sort排序，且按照升序进行排序。如果数组没有经过排序，那么检索结果未知）的数组进行查找。适合byte,char,double,float,int,long,short等基本类型，还有Object类型和泛型（参考sort那段）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line"><span class="keyword">int</span> ans = Arrays.binarySearch(str, <span class="string">&quot;s1&quot;</span>);</span><br><span class="line">System.out.println(ans);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s1, s2, s3, s4]</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h4><p>数组拷贝，底层采用System.arrayCopy（native方法）实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOf(str, str.length);</span><br><span class="line">System.out.println(Arrays.toString(str2));</span><br><span class="line">System.out.println(str.equals(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s2, s4, s1, s3]</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h4><p><strong>数组拷贝，指定一定的范围</strong>，譬如（public static T[] copyOfRange(T[] original, int from, int to)）。底层采用System.arrayCopy（native方法）实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOfRange(str,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s4, s1]</span></span><br></pre></td></tr></table></figure><h4 id="equals和deepEquals"><a href="#equals和deepEquals" class="headerlink" title="equals和deepEquals"></a>equals和deepEquals</h4><p><strong>equals</strong>：判断两个数组的每一个对应的元素是否相等（equals, 对于两个数组的元素o1和o2有o1==null ? o2==null : o1.equals(o2)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str1[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>,<span class="keyword">null</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOf(str1, str1.length);</span><br><span class="line">System.out.println(Arrays.equals(str1, str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.equals(array1, array2)：</span></span><br><span class="line"><span class="comment">//检查两个数组是否包含相同数量的元素，并且两个数组中的所有相应元素对是否相等。</span></span><br><span class="line"><span class="comment">//array1.equals(array2)：</span></span><br><span class="line"><span class="comment">//将该对象与另一个对象进行比较，只有当两个对象的引用相同时才返回true `Object.equals()`</span></span><br></pre></td></tr></table></figure><p><strong>deepEquals</strong>：主要针对一个数组中的元素还是数组的情况，类似deepToString, deepHashCode如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a4[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a5[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a6[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a4,a5,a6&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.equals(a, b));</span><br><span class="line">System.out.println(Arrays.deepEquals(a, b));</span><br><span class="line"></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>给数组赋值。填充数组之用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>,<span class="keyword">null</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line">Arrays.fill(str, <span class="string">&quot;s5&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s2, s4, s1, s3, null]</span></span><br><span class="line"><span class="comment">//[s5, s5, s5, s5, s5]</span></span><br></pre></td></tr></table></figure><h4 id="toString和deepToString"><a href="#toString和deepToString" class="headerlink" title="toString和deepToString"></a>toString和deepToString</h4><p><strong>toString</strong>：对于一个数组int a[] = new int[]{1,9,5,4,6,4,7,1};如果按照System.out.println(a);打印企图可以打印出[1,9,5,4,6,4,7,1]，实际上只会打印出[I@3e2de41d这种。在打印数组的时候需要写成Arrays.toString(a)的形式。可参考sort的详解。<br>        <strong>deepToString</strong>：当数组中又包含数组，那么就不能单存的利用Arrays.toString()了，请看例子。<br>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">System.out.println(Arrays.deepToString(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[[I@1b6b7f83, [I@2e807f85, [I@76340c9c]</span></span><br><span class="line"><span class="comment">//[[1, 2, 3], [1, 3, 3], [4, 3, 2, 1]]</span></span><br></pre></td></tr></table></figure><h4 id="hashCode和deepHashCode"><a href="#hashCode和deepHashCode" class="headerlink" title="hashCode和deepHashCode"></a>hashCode和deepHashCode</h4><p><strong>hashCode</strong>：计算一个数组的hashCode.对于一个数组Object[], hashCode方法返回的值取决于：数组中每个元素的元素oi.hashCode()的值初级计算result = 31 * result + (oi== null ? 0 : oi.hashCode());<br>        <strong>deepHashCode</strong>: 对于一个数组Object[], deepHashCode取决于：数组中每个元素oi，如果oi还是一个数组，那么就继续深入的去获取hashCode，这段比较绕，来个例子比较形象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line">System.out.println(Arrays.hashCode(a));</span><br><span class="line">System.out.println(Arrays.deepHashCode(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1683374023</span></span><br><span class="line"><span class="comment">//31646847</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构简介&quot;&gt;&lt;a href=&quot;#数据结构简介&quot; class=&quot;headerlink&quot; title=&quot;数据结构简介&quot;&gt;&lt;/a&gt;数据结构简介&lt;/h2&gt;&lt;p&gt;数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈BFS和DFS</title>
    <link href="https://leslieaibin.github.io/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/BFS%E5%92%8CDFS%E8%AF%A6%E8%A7%A3/"/>
    <id>https://leslieaibin.github.io/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/BFS%E5%92%8CDFS%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-11-06T16:15:42.000Z</published>
    <updated>2020-11-07T13:39:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先遍历（Depth First Search, 简称DFS）与广度优先遍历（Breath First Search，简称BFS）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫）、搜索引擎、爬虫等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89.gif" alt="DFS 与 BFS 对比"></p><h2 id="DFS-Deep-First-Search"><a href="#DFS-Deep-First-Search" class="headerlink" title="DFS (Deep First Search)"></a>DFS (Deep First Search)</h2><p>DFS：从当前节点开始，先标记当前节点，再寻找与当前节点相邻，且未标记过的节点（ 这是一个递归思想的DFS）</p><ul><li>当前节点不存在下一个节点，则返回前一个节点进行DFS</li><li>当前节点存在下一个节点，则从下一个节点进行DFS</li></ul><p><strong>DFS 遍历使用递归遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。</p><h3 id="网格结构中的-DFS"><a href="#网格结构中的-DFS" class="headerlink" title="网格结构中的 DFS"></a>网格结构中的 DFS</h3><p> <strong>网格问题的基本概念</strong></p><p>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p><p>网格问题是由 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p><p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204300931.png" alt="image-20201107204300931"></p><p>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p><p> <strong>DFS 的基本结构</strong></p><p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的<strong>图</strong>结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travese</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问两个相邻节点：左子节点，右子节点</span></span><br><span class="line">    travese(root.left);</span><br><span class="line">    travese(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，二叉树的DFS有两个要素：【<strong>访问相邻节点</strong>】 和 【<strong>判断base case</strong>】。</p><p>第一个要素是<strong>访问相邻的节点</strong>。二叉树的相邻节点非常简单，只有左子树和右子树。二叉树本身就是一个递归定义的结构：一颗二叉树，他的左子树和右子树也是一颗二叉树。那么我们的DFS遍历只需要调用左子树和右子树即可。</p><p>第二个要素就是判断<strong>base case</strong>。一般来说，二叉树遍历的base case是 root == null。这样一个条件判断其实有两个含义:</p><ul><li>表示root指向指向的子树为空，不需要再往下遍历了。</li><li>在root == null的时候及时返回，可以让后面的root.left 和root.right操作不会出现空指针异常</li></ul><p>对于网格上的DFS，可以参考二叉树的DFS，写出网格的DFS的两个要素：</p><ul><li>相邻节点对于格子 <code>(r, c)</code> 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 <code>(r-1, c)</code>、<code>(r+1, c)</code>、<code>(r, c-1)</code>、<code>(r, c+1)</code>。换句话说，网格结构是「四叉」的。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204116039.png" alt="image-20201107204116039"></p><ul><li>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、<code>grid[r][c]</code> 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204315074.png" alt="image-20201107204315074"></p><h3 id="DFS遍历网格的框架代码"><a href="#DFS遍历网格的框架代码" class="headerlink" title="DFS遍历网格的框架代码"></a>DFS遍历网格的框架代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免重复遍历将已经遍历的格子设置为2</span></span><br><span class="line"><span class="comment">// 0 —— 海洋格子</span></span><br><span class="line"><span class="comment">// 1 —— 陆地格子（未遍历过）</span></span><br><span class="line"><span class="comment">// 2 —— 陆地格子（已遍历过）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][],grid <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">//将已经遍历过得格子 变为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//访问上、下、左、右相邻节点、</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断坐标（r,c）是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">         &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿问题解决"><a href="#岛屿问题解决" class="headerlink" title="岛屿问题解决"></a>岛屿问题解决</h3><h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><p>这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = area(grid, r , c);</span><br><span class="line">            res = Math.max(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">inArea</span><span class="params">(grid, r ,c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] == <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        + are(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + are(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + are(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + are(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt;= grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h4><p>实话说，这道题用 DFS 来解并不是最优的方法。对于岛屿，直接用数学的方法求周长会更容易。不过这道题是一个很好的理解 DFS 遍历过程的例题，不信你跟着我往下看。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/640" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimter</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; grid.length; r++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//题目限制只有一个岛屿，只计算一个即可</span></span><br><span class="line">                <span class="keyword">return</span> dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//函数因为（坐标（r,c)超出网格范围，对应一条黄色的边</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数因为当前格式是海洋格子返回，对应一条蓝色的边</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS-Breath-First-Search"><a href="#BFS-Breath-First-Search" class="headerlink" title="BFS(Breath First Search)"></a>BFS(Breath First Search)</h2><p>BFS: 广度优先算法便如其名字，他是以广度为优先的，一层一层搜索下去，就像病毒感染，扩散性的传播下去。</p><ul><li>比如每遍历start周围的一个“1”节点的时候，就把跟它相关联的“2”节点保存到队列中</li><li>然后依次访问队列内容，并对每个队列元素重复上个步骤</li><li>由此重复下去，直到队列为空或者搜索到终点</li></ul><p><strong>BFS 遍历使用队列数据结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-的应用一：层序遍历"><a href="#BFS-的应用一：层序遍历" class="headerlink" title="BFS 的应用一：层序遍历"></a>BFS 的应用一：层序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">[102. 二叉树的层序遍历]</a></p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.jpg" alt="二叉树的层序遍历"></p><p>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg" alt="BFS 遍历与层序遍历的输出结果不同"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif" alt="BFS 遍历的过程（动图）"></p><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 nn（也就是这一层的结点数量），然后一口气处理完这一层的 nn 个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">//变量i无实际意义只是为了循环n次</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif" alt="img"></p><p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p><p>最终我们得到的题解代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">       <span class="keyword">int</span> n = queue.size();</span><br><span class="line">       List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           level.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.add(level);</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-的应用二：最短路径"><a href="#BFS-的应用二：最短路径" class="headerlink" title="BFS 的应用二：最短路径"></a>BFS 的应用二：最短路径</h3><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/01a3617511b1070216582ae59136888072116ccba360ab7c2aa60fc273351b85.jpg" alt="层序遍历与最短路径"></p><p>要解最短路径问题，我们首先要写出层序遍历的代码，仿照上面的二叉树层序遍历代码，类似地可以写出网格层序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网格结构的层序遍历</span></span><br><span class="line"><span class="comment">// 从格子 (i, j) 开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span>[] node = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r = node[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = node[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r-<span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r+<span class="number">1</span> &lt; N &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r+<span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r][c-<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c+<span class="number">1</span> &lt; N &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r][c+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的层序遍历代码有几个注意点：</p><p>队列中的元素类型是 int[] 数组，每个数组的长度为 2，包含格子的行坐标和列坐标。<br>为了避免重复遍历，这里使用到了和 DFS 遍历一样的技巧：把已遍历的格子标记为 2。注意：我们在将格子放入队列之前就将其标记为 2。想一想，这是为什么？<br>在将格子放入队列之前就检查其坐标是否在网格范围内，避免将「不存在」的格子放入队列。<br>这段网格遍历代码还有一些可以优化的地方。由于一个格子有四个相邻的格子，代码中判断了四遍格子坐标的合法性，代码稍微有点啰嗦。我们可以用一个 moves 数组存储相邻格子的四个方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">    &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后把四个 if 判断变成一个循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[][] move : moves) &#123;</span><br><span class="line">    <span class="keyword">int</span> r2 = r + move[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c2 = c + move[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == <span class="number">0</span>) &#123;</span><br><span class="line">        grid[r2][c2] = <span class="number">2</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r2, c2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好了层序遍历的代码，接下来我们看看如何来解决本题中的最短路径问题。</p><p>这道题要找的是距离陆地最远的海洋格子。假设网格中只有一个陆地格子，我们可以从这个陆地格子出发做层序遍历，直到所有格子都遍历完。最终遍历了几层，海洋格子的最远距离就是几。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8e108e43731bd61a225f79cde11783ae0df17f171974896dc631bbdcda637aa9.gif" alt="从单个陆地格子出发的距离（动图）"></p><p>那么有多个陆地格子的时候怎么办呢？一种方法是将每个陆地格子都作为起点做一次层序遍历，但是这样的时间开销太大。</p><p>BFS 完全可以以多个格子同时作为起点。我们可以把所有的陆地格子同时放入初始队列，然后开始层序遍历，这样遍历的效果如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/0a7e2f150e95617c19ff7eddb9f2a8d795c23d02b8c1e51a1ff45920d493047b.gif" alt="从多个陆地格子出发的距离"></p><p>这种遍历方法实际上叫做「多源 BFS」。多源 BFS 的定义不是今天讨论的重点，你只需要记住多源 BFS 很方便，只需要把多个源点同时放入初始队列即可。</p><p>需要注意的是，虽然上面的图示用 1、2、3、4 表示层序遍历的层数，但是在代码中，我们不需要给每个遍历到的格子标记层数，只需要用一个 distance 变量记录当前的遍历的层数（也就是到陆地格子的距离）即可。</p><p>最终，我们得到的题解代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = grid.length;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将所有的陆地格子加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果地图上只有陆地或者海洋，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty() || queue.size() == N * N) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">        &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> distance = -<span class="number">1</span>; <span class="comment">// 记录当前遍历的层数（距离）</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        distance++;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span>[] node = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r = node[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = node[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] move : moves) &#123;</span><br><span class="line">                <span class="keyword">int</span> r2 = r + move[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c2 = c + move[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[r2][c2] = <span class="number">2</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r2, c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深度优先遍历（Depth First Search, 简称DFS）与广度优先遍历（Breath First Search，简称BFS）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫）、搜索引擎、爬虫等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://te</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="BFS" scheme="https://leslieaibin.github.io/tags/BFS/"/>
    
    <category term="DFS" scheme="https://leslieaibin.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前、中、后序遍历（递归和循环）</title>
    <link href="https://leslieaibin.github.io/2020/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF%EF%BC%89/</id>
    <published>2020-11-01T16:15:42.000Z</published>
    <updated>2020-11-02T15:43:30.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树节点结构"><a href="#二叉树节点结构" class="headerlink" title="二叉树节点结构"></a>二叉树节点结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p><strong>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</strong>  （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>前序遍历：1 2 4 6 7 8 3 5</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//一共到达三次root的节点</span></span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        <span class="comment">//返回root</span></span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">        <span class="comment">//返回root</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-c0aa74a23a4d357d.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val); <span class="comment">//先将节点加入结果队列</span></span><br><span class="line">                stack.push(root);  <span class="comment">//不断将该节点左子树入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">//栈顶节点出栈</span></span><br><span class="line">            root = root.right; <span class="comment">//转向该节点右子树的左子树（下一个循环）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p><strong>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</strong> （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>中序遍历 ：4 7 6 8 2 1 3 5</strong></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></p><h2 id="递归算法-1"><a href="#递归算法-1" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h2><p><img src="https://upload-images.jianshu.io/upload_images/2405011-c0aa74a23a4d357d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);  <span class="comment">//不断将该节点左子树入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">//栈顶节点出栈</span></span><br><span class="line">            res.add(root.val); <span class="comment">//将节点加入结果队列</span></span><br><span class="line">            root = root.right; <span class="comment">//转向该节点右子树的左子树（下一个循环）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h1><p><strong>后序遍历： 左子树 —&gt; 右子树 —&gt;根结点</strong>  （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>后序遍历：7 8 6 4 2 5 3 1</strong> </p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></p><h2 id="递归算法-2"><a href="#递归算法-2" class="headerlink" title="递归算法"></a>递归算法</h2><p><strong>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</strong>（根节点在 前中后 那个位置 就叫什么遍历）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>; <span class="comment">//pre节点用于记录前一次访问的节点</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root); <span class="comment">//不断将左节点压栈</span></span><br><span class="line">                root = root.left; </span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="keyword">null</span> || root.right==pre)&#123; <span class="comment">//若右节点为空 或右节点访问过</span></span><br><span class="line">                res.add(root.val); <span class="comment">//此时可以访问根结点啦</span></span><br><span class="line">                pre = root;</span><br><span class="line">                stack.pop();</span><br><span class="line">                root = <span class="keyword">null</span>; <span class="comment">//此时下一轮循环不要将左子树压栈，直接判断栈顶元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = root.right; <span class="comment">//先不出栈 把它右节点入栈</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="comment">//修改前序遍历代码中，节点写入结果链表的代码：将插入队尾修改为插入队首</span></span><br><span class="line"><span class="comment">//修改前序遍历代码中，每次先查看左节点再查看右节点的逻辑：变为先查看右节点再查看左节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.addFirst(root.val); <span class="comment">//插入队首</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right; <span class="comment">//先右后左</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树节点结构&quot;&gt;&lt;a href=&quot;#二叉树节点结构&quot; class=&quot;headerlink&quot; title=&quot;二叉树节点结构&quot;&gt;&lt;/a&gt;二叉树节点结构&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://leslieaibin.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Win10连接linux服务器的工具</title>
    <link href="https://leslieaibin.github.io/2020/10/31/%E5%B7%A5%E5%85%B7/win10%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://leslieaibin.github.io/2020/10/31/%E5%B7%A5%E5%85%B7/win10%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2020-10-31T15:40:42.000Z</published>
    <updated>2020-11-23T07:45:01.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的远程连接Linux工具"><a href="#常用的远程连接Linux工具" class="headerlink" title="常用的远程连接Linux工具"></a>常用的远程连接Linux工具</h2><p>常用的远程连接Linux工具有：Vscode、XShell、FinallShell等。下面重点介绍该三种工具：</p><h2 id="1-VsCode的Remote插件"><a href="#1-VsCode的Remote插件" class="headerlink" title="1 VsCode的Remote插件"></a>1 VsCode的Remote插件</h2><p>Vscode是一款开源的跨平台编辑器。默认情况下，vscode使用的语言为英文(us)</p><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h3><p>官方下载地址：<a href="https://links.jianshu.com/go?to=https://code.visualstudio.com/%23alt-downloads">https://code.visualstudio.com/#alt-downloads</a></p><p>选择自己的系统版本，安装时一直下一步即可，安装完成后直接运行code.exe</p><h3 id="1-2-修改vscode为中文环境"><a href="#1-2-修改vscode为中文环境" class="headerlink" title="1.2 修改vscode为中文环境"></a>1.2 修改vscode为中文环境</h3><ul><li><p>使用快捷键【Ctrl+Shift+X】，在搜索框中输入“chinese”，选择安装   中文（简体） install；</p></li><li><p> 再次使用快捷键【Ctrl+Shift+P】，在搜索框中输入“configure display language”，选择 zh-CN ，确认重启即可。</p></li></ul><h3 id="1-3-修改主题颜色"><a href="#1-3-修改主题颜色" class="headerlink" title="1.3 修改主题颜色"></a>1.3 修改主题颜色</h3><p>使用快捷键【Ctrl+K 】【Ctrl+T 】弹出选择框，选择自己喜欢的主题</p><h3 id="1-4-安装Remote-SSH"><a href="#1-4-安装Remote-SSH" class="headerlink" title="1.4 安装Remote-SSH"></a>1.4 安装Remote-SSH</h3><p>直接打开vscode中的插件搜索SSH找到Remote-SSH直接安装即可。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130400.png" alt="image-20201016130400637"></p><h3 id="1-5-配置Remote-SSH"><a href="#1-5-配置Remote-SSH" class="headerlink" title="1.5 配置Remote-SSH"></a>1.5 配置Remote-SSH</h3><p>​        安装完成后会出现一个远程资源管理器图标，其中可以选择SSH Targets。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130451.webp" alt="img"></p><p>然后点击配置：</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130523.webp" alt="img"></p><p>此时打开一个config配置文件，让你输入HostName和User：</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016131335.png" alt="image-20201016131326006"></p><h3 id="1-6-连接远程服务器"><a href="#1-6-连接远程服务器" class="headerlink" title="1.6 连接远程服务器"></a>1.6 连接远程服务器</h3><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132016.png" alt="image-20201016132016082"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132050.png" alt="image-20201016132050898"></p><p><strong>输入密码为test</strong></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132432.png" alt="image-20201016132252488"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132440.png" alt="image-20201016132323464"></p><p>打开文件夹 命令行</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016132600856.png" alt="image-20201016132600856"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016132650554.png" alt="image-20201016132650554"></p><h3 id="1-7安装插件"><a href="#1-7安装插件" class="headerlink" title="1.7安装插件"></a>1.7安装插件</h3><p>​        本机中的插件是无法在远程服务器中使用的，这就需要我们从新安装插件，这个也比较简单，在连接上远程服务器后在vscdoe的插件侧边栏中就可以看到一个专为远程服务器显示 安装插件的区域，此后的操作与本地安装基本一样。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016135335446.png" alt="image-20201016135335446"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016135433543.png" alt="image-20201016135433543"></p><h2 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h2><p>​        Xshell：是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。软件强大，在windows环境下使用用户多，非常重要的一点是：对个人、教育用户是免费的。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101034.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p>​        它的使用方式略有区别，第一次双击软件图标，打开后，需要先点击软件界面左上角的文件，点击新建，然后才能出来主机信息配置界面。输入主机别名、ip地址和端口，然后点击确定。就会弹到服务器列表，在列表中选择你刚才添加的服务器名称，然后点击连接。就开始自动连接对应的服务器。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101140.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101124.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101124.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p>​        输入用户名，点击确定，再输入密码。认证成功后就进入到了服务器的shell界面。显示你上一次的登录时间以及IP地址。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101212.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101220.png" alt="Windows下连接Linux的ssh工具有哪些"></p><h2 id="FinallShell"><a href="#FinallShell" class="headerlink" title="FinallShell"></a>FinallShell</h2><p>​        FinalShell一款很好用的ssh链接工具，标准免费版本就可以基本满足一般用户的需求，和xshell工具相比，虽然没有那么多绚丽多彩的功能，但是小巧实用，而且关键是免费。</p><p>​        xshell虽然也是免费，但是过了评估试用期还需要重新下载安装。</p><p>​        先来看一下FinalShell的链接界面。</p><p>​        界面简洁，但是基本上可以满足普通用户的基本需求了，因为在左侧可以一目了然服务器的基本情况。</p><p>​        磁盘使用情况，内存，cpu负载情况等等。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102020.png" alt="如何通过FinalShell连接linux服务器"></p><p>​        点击上方类似文件夹的图标，点开后，下方是我已经链接过的机器列表，如果是第一次使用，这个列表是空的。连接列表里面的机器，直接双击即可连接。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102103.png" alt="如何通过FinalShell连接linux服务器"></p><p>​            然后，点击第一个+号，在弹出的下拉列表处，选择ssh连接。这里可以看到有一个远程桌面链接（windows），FinalShell还是比较实用的。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102251.png" alt="如何通过FinalShell连接linux服务器"></p><p>​        在弹出的对话框中，写入要连接的服务器的ip地址和端口。名称可以随意填写，方便自己记忆。</p><p>可以直接在这个窗口填入用户名和密码。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102452.png" alt="如何通过FinalShell连接linux服务器"></p><p>​            当连接机器时，会提示输入用户名和密码的。也可以勾选保存，这样下次连接时就不用再次输入用户名和密码了。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102545.png" alt="如何通过FinalShell连接linux服务器"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102551.png"></p><p>​        如果是要连接已经连接的机器，打开列表框，双击某个记录就可以了。红框标出的就是我所有连接过的机器。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102621.png" alt="如何通过FinalShell连接linux服务器"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用的远程连接Linux工具&quot;&gt;&lt;a href=&quot;#常用的远程连接Linux工具&quot; class=&quot;headerlink&quot; title=&quot;常用的远程连接Linux工具&quot;&gt;&lt;/a&gt;常用的远程连接Linux工具&lt;/h2&gt;&lt;p&gt;常用的远程连接Linux工具有：Vscode</summary>
      
    
    
    
    <category term="Linux" scheme="https://leslieaibin.github.io/categories/Linux/"/>
    
    
    <category term="ssh" scheme="https://leslieaibin.github.io/tags/ssh/"/>
    
    <category term="Linux" scheme="https://leslieaibin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-（6-11章）</title>
    <link href="https://leslieaibin.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%886-11%E7%AB%A0%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%886-11%E7%AB%A0%EF%BC%89/</id>
    <published>2020-10-29T16:15:42.000Z</published>
    <updated>2020-10-30T08:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6. HTTP首部"></a>6. HTTP首部</h1><h2 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf41c1eadc" alt="httpstructure"></p><p>上图是HTTP<strong>请求报文</strong>的结构</p><p>HTTP请求报文由方法、URI、HTTP版本、HTTP首部字段等组成。</p><p>请求报文首部信息实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>; WOW64; rv:<span class="number">13.0</span>) Gecko/<span class="number">2010010</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*; q=0</span></span><br><span class="line"><span class="comment">Accept-Language: ja,en-us;q=0.7,en;q=0.3</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">DNT: 1</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT</span></span><br><span class="line"><span class="comment">If-None-Match: &quot;45bae1-16a-46d776ac&quot;</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br></pre></td></tr></table></figure><p>HTTP响应报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段三部分组成。</p><p>下面是HTTP<strong>响应报文</strong>结构：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf4203c6ba" alt="httpresstructure"></p><p>响应报文的首部实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line">Date: Thu, <span class="number">07</span> Jun <span class="number">2012</span> <span class="number">07</span>:<span class="number">21</span>:<span class="number">36</span> GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Connection: close</span><br><span class="line">Etag: <span class="string">&quot;45bae1-16a-46d776ac&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h2><h3 id="6-2-1-HTTP首部字段结构"><a href="#6-2-1-HTTP首部字段结构" class="headerlink" title="6.2.1 HTTP首部字段结构"></a>6.2.1 HTTP首部字段结构</h3><p>HTTP首部字段传递重要信息，其结构基本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首部字段名： 字段值</span><br><span class="line">例如：</span><br><span class="line">Content-Type: text/html</span><br><span class="line">另外，有些首部字段可以有多个值，如下：</span><br><span class="line">    Keep-Alive:timeout=<span class="number">15</span>,max=<span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="6-2-2-HTTP首部字段类型"><a href="#6-2-2-HTTP首部字段类型" class="headerlink" title="6.2.2 HTTP首部字段类型"></a>6.2.2 HTTP首部字段类型</h3><p>HTTP首部字段根据实际用途被分为四种类型：</p><ul><li><strong>通用首部字段</strong>  请求报文和响应报文都会使用到的首部字段</li><li><strong>请求首部字段</strong>  从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级的信息。</li><li><strong>响应首部字段</strong>  从服务端向客户端发送响应报文时的首部。补充了响应的附加内容，也会要求客户端附加的内容信息。</li><li><strong>实体首部字段</strong>  针对请求报文和响应报文的实体部分 使用的首部。补充了资源内容更新时间等与实体内容相关的信息。</li></ul><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">逐跳首部、连接的管理</td></tr><tr><td align="center">Data</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末尾的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他 协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Authorization</td><td align="center">Web信息认证</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在的服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与If-Match相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体Byte的范围请求</td></tr><tr><td align="center">If-Unmodifield-Since</td><td align="center">比较实体标记（与If-Match相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中URL的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码优先级</td></tr><tr><td align="center">Use-Agent</td><td align="center">HTTP客户端程序的信息</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配资源</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的HTTP方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小（字节）</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的URI</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改时间</td></tr></tbody></table><p>以上就是最常用的一些 HTTP 首部字段。</p><p>其他还有一些非 HTTP/1.1 规范的首部字段也用的比较多，比如 Set-Cookie、Cookie 等等。</p><p>此外，HTTP 首部根据将定义成缓存代理和非缓存代理的行为，分成了两种类型——端到端首部（End-to-End Header）和逐跳首部（Hop-by-Hop Header）。</p><p>端到端首部类的首部字段会转发给请求/响应的最终接受对象，且必须保存在由缓存生成的响应中，另外规定它必须转发；</p><p>逐跳首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 之后的版本中使用逐跳首部需要提供 Connection 首部字段。</p><p>下面这些字段都属于逐跳首部字段：</p><ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><p>所有其余字段皆为端到端首部字段。</p><p>下面开始详细介绍各个首部字段。</p><h3 id="6-2-3-HTTP-1-1-通用首部字段"><a href="#6-2-3-HTTP-1-1-通用首部字段" class="headerlink" title="6.2.3  HTTP/1.1 通用首部字段"></a>6.2.3  HTTP/1.1 通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段Cache-Control,就能操作缓存的工作机制。</p><p>Cache-Control 的指令参数是可选的，多个指令之间通过逗号分开。该首部字段在请求和响应时都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:<span class="keyword">private</span>, max-age = <span class="number">0</span> , no-cache</span><br></pre></td></tr></table></figure><p><strong>Cache-Control 可用指令如下：</strong></p><p><strong>请求指令</strong></p><table><thead><tr><th align="center">指令</th><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">no-cache</td><td align="center">无</td><td align="center">强制向源服务器再次验证</td></tr><tr><td align="center">no-store</td><td align="center">无</td><td align="center">不缓存请求或响应的任何内容</td></tr><tr><td align="center">max-age=[秒]</td><td align="center">必需</td><td align="center">响应的最大 age 值</td></tr><tr><td align="center">max-stale(=[秒])</td><td align="center">可省略</td><td align="center">接受已过期的响应</td></tr><tr><td align="center">min-fresh=[秒]</td><td align="center">必需</td><td align="center">期望在指定的时间内的响应仍然有效</td></tr><tr><td align="center">no-transform</td><td align="center">无</td><td align="center">代理不可更改媒体类型</td></tr><tr><td align="center">only-if-cached</td><td align="center">无</td><td align="center">从缓存获得资源</td></tr><tr><td align="center">cache-extension</td><td align="center">-</td><td align="center">新指令标记（token）</td></tr></tbody></table><p><strong>响应指令</strong></p><table><thead><tr><th align="center">指令</th><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">无</td><td align="center">可向任意方提供响应的缓存</td></tr><tr><td align="center">private</td><td align="center">可省略</td><td align="center">仅向特定用户返回响应</td></tr><tr><td align="center">no-cache</td><td align="center">可省略</td><td align="center">缓存前必须确认其有效性</td></tr><tr><td align="center">no-store</td><td align="center">无</td><td align="center">不缓存请求或响应的任何内容</td></tr><tr><td align="center">no-transform</td><td align="center">无</td><td align="center">代理不可更改媒体类型</td></tr><tr><td align="center">must-revalidate</td><td align="center">无</td><td align="center">可缓存但必须再向源服务器进行确认</td></tr><tr><td align="center">proxy-revalidate</td><td align="center">无</td><td align="center">要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td align="center">max-age=[秒]</td><td align="center">必需</td><td align="center">响应的最大 age 值</td></tr><tr><td align="center">s-maxage=[秒]</td><td align="center">必需</td><td align="center">公共缓存服务器响应的最大 age 值</td></tr><tr><td align="center">cache-extension</td><td align="center">-</td><td align="center">新指令标记（token）</td></tr></tbody></table><p>规定是否缓存的指令：</p><p>**public指令 **  当指定使用public指令时 ，则明确表明其他用户也可以利用缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">public</span></span><br></pre></td></tr></table></figure><p>当指定使用public指令时，则明确表明其他用户也可以利用缓存。</p><p><strong>private指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">private</span></span><br></pre></td></tr></table></figure><p>当指定private指令后响应只以特定的用户作为对象，当该对象向服务器发起请求时，服务器会返回缓存的资源</p><p><strong>no-cache指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>该指令的目的是为了防止使用过期的缓存资源</p><p>如果客户端发送的请求包含no-cache指令，则表示客户端将不会接受过期的缓存过得响应。于是，中间的代理服务器必须把请求转发给原服务器。</p><p>如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器以后也将不在对缓存服务器请求中提出的资源有效性进行确认，且进制其对资源响应进行缓存操作。</p><p>控制可执行缓存对象的指令</p><p><strong>no-store指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p>当使用no-store指令时，按时请求或响应中包含机密信息。</p><p>因此该指令规定缓存不能在本地存储请求或响应的任一部分。</p><p><strong>s-maxage 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: s-maxage&#x3D;604800（单位：秒）</span><br></pre></td></tr></table></figure><p>该指令功能和max-age相同，不同点是s-maxage指令只适合于供多位用户使用的公共缓存服务器。当使用smax-age 指令之后，直接会忽略 Expires 字段及 max-age 指令的处理。</p><p><strong>max-age 指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=<span class="number">604800</span>（单位：秒）</span><br></pre></td></tr></table></figure><p><strong>当客户端发送的请求中包含 max-age 指令时</strong>，如果判定缓存资源的缓存时间数值比指定的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器（相当于是 no-cache）。</p><p><strong>当服务器返回的响应中包含 max-age 指令时</strong>，缓存服务器将不对资源的有效性再做确认，而 max-age 数值代表的是资源保存为缓存的最长时间。</p><p>应用 HTTP/1.1 版本的缓存的服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而应用 HTTP/1.0 版本的服务器则恰恰相反。</p><p><strong>min-fresh 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: min-fresh&#x3D;60（单位：秒）</span><br></pre></td></tr></table></figure><p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源（即指定时间过后仍然是未过期的资源）。</p><p><strong>max-stale 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-stale&#x3D;3600（单位：秒） </span><br></pre></td></tr></table></figure><p>使用 max-stale 表示接受过期的缓存资源，后面的值表示具体过期的时长，表示响应不能已经过时超过该给定的时间。如果不传递数值，则表示无论经过多久，客户端都能够接受。</p><p><strong>only-if-cached 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: only-if-cached</span><br></pre></td></tr></table></figure><p>使用该指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。即只接受已缓存的资源，并且不用向源服务器检查资源的有效性。若代理服务器本地缓存无响应，则返回 504 Gateway Timeout。</p><p><strong>must-revalidate 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure><p>使用该指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p><p>使用 must-revalidate 指令会忽略 max-stale 指令。</p><p><strong>proxy-revalidate 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: proxy-revalidate</span><br></pre></td></tr></table></figure><p>该指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再验证资源的有效性。</p><p><strong>no-transform 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure><p>该指令规定无论在请求还是响应中缓存都不能改变实体的媒体类型。</p><p>这样可以防止缓存或者代理压缩图片等类似操作。</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>这个首部字段有一下两个作用：</p><ul><li>控制不再转发给代理的首部自担</li><li>管理持久连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: 不再转发的首部字段名</span><br></pre></td></tr></table></figure><p>这条语句就表示指定的首部字段不再转发到下一级服务器（可能是代理）。</p><p><a href="https://github.com/zhongdeming428/MyMemorandum/blob/master/%E5%9B%BE%E8%A7%A3HTTP/pics/httpconn.png"><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf42172df1" alt="httpconn"></a></p><p>除了上面的功能以外，该首部还可以管理持久连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>该指令明确指定断开当前连接。（HTTP/1.1 的所有连接默认都是长连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>以上指令明确指定当前连接为长连接。（适用于 HTTP/1.1 版本之前）</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>该字段表明 HTTP 报文创建的日期和时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure><h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>该字段是 HTTP/1.1 版本的遗留字段，为了向后兼容而定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>功能一致。</p><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>该字段事先说明在报文主体后记录了哪些首部字段，可用于 HTTP/1.1 版本分块传输编码时。</p><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>该首部字段指定了在传输报文主体时所使用的编码方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>该首部字段用于检测 HTTP 协议及其他协议是否可以升级为更高版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>该首部字段是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p><p>报文经过代理或者网关时，会在首部字段 Via 中附加该服务器的信息，然后再进行转发。而且这个字段不仅可以用于追踪报文的转发，还可以避免请求回环发生。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf499ebbc8" alt="httpvia"></p><p>各个代理服务器会向 Via 添加自身服务器的信息。</p><p>其中 <code>1.0</code> 以及 <code>1.1</code> 的开头表示服务器的 HTTP 协议版本。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>该首部自担通常告诉用户一些缓存相关的问题的警告，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</span><br></pre></td></tr></table></figure><h3 id="6-2-4-HTTP-1-1-请求首部字段"><a href="#6-2-4-HTTP-1-1-请求首部字段" class="headerlink" title="6.2.4 HTTP/1.1 请求首部字段"></a>6.2.4 HTTP/1.1 请求首部字段</h3><p>请求首部字段是从客户端发往服务器端时请求报文中所使用的字段。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8</span></span><br></pre></td></tr></table></figure><p>该首部字段可以通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可以使用 <code>type/subtype</code> 的形式一次指定多种媒体类型。</p><p>常用媒体类型：</p><ul><li><p>文本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html,text&#x2F;plain,text&#x2F;css,application&#x2F;xhtml+xml,application&#x2F;xml...</span><br></pre></td></tr></table></figure></li><li><p>图片文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image&#x2F;jpg,image&#x2F;gif,image&#x2F;png...</span><br></pre></td></tr></table></figure></li><li><p>视频文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video&#x2F;mpeg,video&#x2F;quicktime...</span><br></pre></td></tr></table></figure></li><li><p>应用程序使用的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application&#x2F;octet-stream,application&#x2F;zip...</span><br></pre></td></tr></table></figure></li></ul><p>多个协议之间使用逗号分隔，分号之前代表媒体类型，分号之后代表权重。</p><p>当服务器提供多种内容时，会首先返回权重最高的媒体类型。</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5,unicode-1-1;q&#x3D;0.8</span><br></pre></td></tr></table></figure><p>该字段可用来通知服务器用户代理支持的字符集以及字符集的权重。</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br></pre></td></tr></table></figure><p>该字段用来告知服务器用户代理支持的内容编码及内容编码格式的优先级。</p><p>以下是最常用的几个内容编码格式：</p><ul><li><p>gzip</p><p>由文件压缩程序gzip(GNU zip)生成的编码 格式(RFC1952)</p></li><li><p>compress</p><p>由UNIX文件压缩程序compress生成的编码格式</p></li><li><p>deflate</p><p>组和使用zlib格式及有deflate压缩算法生成的编码格式</p></li><li><p>identity</p><p>不执行压缩或者不会变化的默认编码格式</p></li></ul><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>告知服务器能够处理的自然语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-cn,zh;q = <span class="number">0.7</span>, en-us,en; q = <span class="number">0.3</span></span><br></pre></td></tr></table></figure><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>该字段用于告知服务器用户代理的认证信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure><h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect: <span class="number">100</span>-<span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">From: info<span class="meta">@hackr</span>.jp</span><br></pre></td></tr></table></figure><p>该字段用来告知服务器使用用户代理的用户电子邮箱地址</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>很多时候一台服务器上部署了多个网站，对应着多个域名，当 DNS 解析到服务器之后，我们需要知道用户访问的是哪个网址，以便分配到对应的端口给对应的程序进行处理，所以 Host 就用来告知服务器端用户访问的主机名称和端口号。</p><p>Host 首部是唯一一个必须被包含在请求内的首部字段。</p><p>如果服务器未设定主机名，那么发送一个空值即可</p><h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>形如 If-xxx 的请求首部字段，都可以称为条件请求。服务器接收到条件请求之后，只有在判断条件为真时才会执行请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><p>该首部字段属于附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag，后面会讲）值。服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时才会执行请求。反之会返回状态码 412 Precondition Failed 的响应。</p><p>使用 <code>*</code> 时，服务器会匹配任意的 ETag 值。</p><h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p>该首部字段指定一个时间点，如果在该时间点之后有修改过资源，则会响应请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Thu, <span class="number">15</span> Apr <span class="number">2004</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> GMT </span><br></pre></td></tr></table></figure><p>如果在这个时间点之后没有修改过资源，则返回304 Not Modified状态码的响应</p><h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>该字段与If-Match的作用相反。当该字段的值不匹配资源的ETag时才会响应请求。</p><h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p>该字段的值若是跟 ETag 的值或更新的日期时间相匹配，那么就作为范围请求处理；如果无法匹配的话就返回全体资源。</p><h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure><p>该首部字段和 <code>If-Modified-Since</code> 作用相反，它的作用是告知服务器指定的资源只有在指定日期之后没有发生变更的情况下才处理请求，否则就返回 412 Precondition Failed 状态码。</p><h4 id="Max-Forward"><a href="#Max-Forward" class="headerlink" title="Max-Forward"></a>Max-Forward</h4><p>通过 TRACE 方法或者 OPTIONS 方法发送包含首部字段 Max-Forward 的请求时，该字段以十进制整数形式指定可经过的服务器的最大数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Forward: <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwObjkNLAGFfY5</span><br></pre></td></tr></table></figure><p>该字段告知服务器认证所需要的的信息。该认证行为发生在客户端与代理服务器之间。</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes = <span class="number">5001</span>-<span class="number">10000</span></span><br></pre></td></tr></table></figure><p>该字段适用于只获取部分资源的范围请求，他告知了服务器所需要的服务器资源的指定范围。</p><p>接收到携带该字段请求的服务器返回状态码为206  Partil Content的响应，如果无法处理该范围请求，则服务器会返回状态码为220 OK的响应以及全部资源。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http:<span class="comment">//www.hackr.jp/index.htm</span></span><br></pre></td></tr></table></figure><p>该首部字段告知服务器请求的原始资料的URI</p><h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip,deflate;q=<span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>该字段会告知服务器客户端能够处理的响应传世编码方式及相对的优先级，其功能和Transfer-Enconding的功能相似。</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko&#x2F;20100101 Firefox&#x2F;13.0.1</span><br></pre></td></tr></table></figure><p>该字段会将创建请求的浏览器和用户代理名称的相关信息发送给服务器。当爬虫发起请求时，有可能会在该字段添加作者的地址。</p><p>值得一提的是有些网站会做出反爬虫策略，他们会验证 User-Agent 字段是否来自于浏览器，如果不是的话就会拒绝爬虫的请求；所以如果要想继续拿到想要的信息的话就会通过该字段将爬虫伪造成浏览器。</p><h3 id="6-2-4-HTTP-1-1-响应首部字段"><a href="#6-2-4-HTTP-1-1-响应首部字段" class="headerlink" title="6.2.4 HTTP/1.1 响应首部字段"></a>6.2.4 HTTP/1.1 响应首部字段</h3><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求信息等。</p><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p>该字段用于告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。当服务器能够处理客户端的范围请求时，其值为 bytes，反之为 none。</p><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aag: 600</span><br></pre></td></tr></table></figure><p>该首部字段告知客户端<strong>源服务器</strong>在多久之前创建了响应，字段的值的单位为秒。</p><p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到再次认证完成的时间值。</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure><p>首部字段 ETag 能告知客户端实体标志。它是一种能够将资源以字符串形式做唯一性标志的方式。服务器会为每份资源分配对应的 ETag 值。</p><p>当资源更新时，ETag 值也要更新。完成 ETag 值时，并没有统一的算法规则，仅仅由服务器分配。</p><p>访问某个资源的 URI 一般不会发生改变，但是当资源本身发生了变化时，资源对应的 ETag 也会更新。</p><p><strong>强 ETag 和弱 ETag</strong></p><p>ETag 值有强弱之分，强 ETag 值不管资源发生多么细微的变化都会随之变化，而弱 ETag 值只有在资源发生了根本改变并产生差异时才会发生变化。</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Location</span>: http://www.usagidesign.jp/sample.html</span><br></pre></td></tr></table></figure><p>该首部字段可以将接受响应的客户端引导到某一个与其请求 URI 位置不同的资源。</p><p>基本上该字段会配合 3xx 重定向状态码一起使用。</p><h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>该首部字段会把代理服务器所要求的认证信息发送给客户端。</p><h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry After"></a>Retry After</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Retry-After：120</span></span><br></pre></td></tr></table></figure><p>该首部字段告知客户端在多久之后再次发起请求。该字段可以指定为具体的时间或者创建响应后的秒数。</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>该首部字段会告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</span><br></pre></td></tr></table></figure><h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Vary</span>: Accept-Language</span><br></pre></td></tr></table></figure><p>该首部字段可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p><p>具体来说，该首部字段会指定一个其他的首部字段，比如上面的 Accept-Encoding，当指定字段的值未发生变化时，则使用缓存资源；如果指定字段的值发生了变化时，则需要向源服务器请求最新的资源。</p><p>这个字段可以指定 User-Agent，防止移动端浏览器访问页面时访问了 PC 端页面的缓存。</p><p>当该字段指定为 <code>*</code> 时，所有的请求都会被视为唯一的并且会被缓存。</p><h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>该首部字段用于 HTTP 访问认证。</p><h3 id="6-2-4-HTTP-1-1-实体首部字段"><a href="#6-2-4-HTTP-1-1-实体首部字段" class="headerlink" title="6.2.4 HTTP/1.1 实体首部字段"></a>6.2.4 HTTP/1.1 实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间和实体相关的信息。</p><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Allow：GET，HEAD</span></span><br></pre></td></tr></table></figure><p>该首部字段用于通知客户端服务器能够支持的 HTTP 方法，当服务器接收到不支持的请求方法时，会返回 405 Not Allowed 状态码。</p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding：gzip</span></span><br></pre></td></tr></table></figure><p>该首部字段会告知客户端对实体的主体部分所使用的内容编码格式。</p><p>具体编码格式可以参考 2.5.3 Accept-Encoding。</p><h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language； zh-CN</span><br></pre></td></tr></table></figure><p>该首部字段用于通知客户端实体主体所使用的自然语言。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length：15000</span></span><br></pre></td></tr></table></figure><p>该首部字段表明了实体主体的大小（单位是字节）。</p><p>如果对实体主体采用了内容编码传输时，不能再使用 Content-Length 首部字段。</p><h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Location：http://www.hackr.jp/index-ja.html</span></span><br></pre></td></tr></table></figure><p>该首部字段给出与报文主体相对应的 URI。当返回的页面内容与请求的实际对象不相同时，首部字段 Content-Location 会写明 URI。</p><h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure><p>客户端会对接收到的报文主体采用 MD5 算法进行散列计算，然后与 Content-MD5 的值进行比较以对接收到的主体内容进行完整性校验。</p><p>散列算法进行计算的做法主要用于防止传输内容被篡改，因为同一个输入通过散列算法计算以后得到的结果是相同的，不同的输入经过散列算法计算之后得到的结果基本不会重复。这也是许多提供资源下载的网站同时会给出资源对应 HASH 值的原因。</p><p>但是 Content-MD5 并不可靠，因为如果传输主体的内容可以被修改的话，Content-MD5 的值同样也可能被修改过，所以并不可靠。为了确保资源不被篡改，最好还是使用 HTTPS。</p><h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure><p>针对范围请求，该首部字段告知客户端返回的响应的实体的哪些部分符合范围请求，单位为字节。</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>该首部字段说明了实体主体内的媒体类型。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><p>该首部字段将资源失效的日期告知客户端。</p><p>当首部字段 Cache-Control 有指定 max-age 指令时，会优先处理 max-age 指令。</p><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure><p>该首部字段指明了资源的最终修改时间。</p><h3 id="Cookie-服务的首部字段"><a href="#Cookie-服务的首部字段" class="headerlink" title="Cookie 服务的首部字段"></a>Cookie 服务的首部字段</h3><p><strong>Cookie 的工作机制是用户识别及状态管理</strong>。</p><p>为 cookie 服务的首部字段：</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的 Cookie 信息</td><td>请求首部字段</td></tr></tbody></table><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><p>当服务器开始准备管理客户端的状态时，会实现告知各种信息。</p><p>下面的表格列举了 Set-Cookie 的字段值。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予 Cookie 的键和对应值</td></tr><tr><td>expires=DATE</td><td>Cookie 的有效期</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）</td></tr><tr><td>domain=域名</td><td>作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td></tr><tr><td>Secure</td><td>仅在 HTTPS 安全通信时才发送 Cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使 Cookie 不能被 JavaScript 所访问</td></tr></tbody></table><p>下面详细讲讲 Cookie 的各个属性。</p><ul><li><p><code>expires</code>：该属性指定浏览器可以发送 Cookie 的有效期。当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器关闭之前。</p><p>另外需要注意的是一旦 Cookie 从服务器端发送到客户端，服务器端就不存在可以显式删除 Cookie 的方法。只能通过覆盖已有的 Cookie 来达到删除的目的。</p></li><li><p><code>path</code>：该属性用于限定指定 Cookie 的发送范围的文件目录。但是有其他办法可以避开这个限制，所以不要对它抱有太大期望。</p></li><li><p><code>domain</code>：该属性的域名可做到与结尾匹配一致，比如指定 domain 为 example.com，此时 <a href="http://www.example.com/">www.example.com</a> 和 www2.example.com 也都可以访问 Cookie。所以不指定域名的情况下更加安全，因为默认只有当前响应的服务器的域名可以访问 Cookie。</p></li><li><p><code>secure</code>：该属性限制 Web 页面仅在 HTTPS 安全连接时才发送 Cookie。当省略该属性时，HTTP 和 HTTPS 协议的指定域名都可以访问 Cookie。</p></li><li><p><code>HttpOnly</code>：该属性使得 JavaScript 无法对 Cookie 进行读取操作。</p></li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie：status=enable</span><br></pre></td></tr></table></figure><p>首部字段 Cookie 会告知服务器，当客户端想要获得 HTTP 状态管理的支持时，就会在请求中包含从服务器中获取到的 Cookie。</p><h3 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h3><p>HTTP 首部字段是可以自行扩展的，所以在 Web 服务器和浏览器的应用上，会出现一些非标准的首部字段。</p><p>下面是比较常用的非标准首部字段：</p><ul><li>X-Frame-Options</li><li>X-XSS-Protection</li><li>DNT</li><li>P3P</li></ul><h4 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Frame-Options</span>: DENY</span><br><span class="line">此处的 Frame 包括 iframe、frame、object 等标签</span><br></pre></td></tr></table></figure><p>该首部字段属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是防止点击劫持攻击（clickjacking）。</p><p>该字段可以指定三类值：</p><ul><li><code>DENY</code>：拒绝被嵌套到 Frame，即使是相同域名下的页面也不行</li><li><code>SAMEORIGIN</code>：该页面只可以被嵌入到相同域名页面的 Frame 中</li><li><code>ALLOW-FROM uri</code>：表示可以在指定来源的页面中被嵌套</li></ul><h4 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h4><p>该字段属于响应首部，是针对跨域脚本攻击的一种策略，用于控制浏览器 XSS 防护机制的开关。</p><p>该字段可以设置一下了两个值：</p><ul><li>0：将 XSS 过滤设置成无效状态</li><li>1：将 XSS 过滤设置成有效状态</li></ul><h4 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">DNT：1</span></span><br></pre></td></tr></table></figure><p>该首部字段属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，表示拒绝个人信息被收集。</p><p>0 表示同意被追踪，1 表示拒绝被追踪。</p><h4 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h4><p>该首部字段属于响应首部，通过利用 P3P 技术让网站上的个人隐私变成仅供程序可理解的形式。</p><h1 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h1><h2 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h2><p>HTTP在通信过程中会面临以下三种安全问题：</p><ul><li>通信使用明文（不加密），内容可能会被监听</li><li>不验证通信方的身份，可能会遭遇伪装</li><li>无法验证报文的完整性，可能已经被篡改</li></ul><p><strong>谷歌浏览器强制要求https</strong></p><h3 id="7-1-1-窃听"><a href="#7-1-1-窃听" class="headerlink" title="7.1.1 窃听"></a>7.1.1 窃听</h3><p>HTTP本身不具备加密功能，所以传输的过程中都是以明文 方式发送</p><p>由于在网络的传输过程中，我们所发送的信息要 经过许多的网络节点和设备，在这个过程中这些设备是可能会拦截我们的信息并且进行窃听的，直接通过一些常用的抓包工具就可以窃听未加密的网络传输信息。</p><p><strong>通过加密防止窃听</strong></p><ul><li><p><strong>通信的加密</strong>  为了防止传输内容被窃听，我们采取的方式之一就是通信加密，HTTP本身没有加密机制，但是我们可以通过将HTTP和SSL（Secure Socket Layer 安全套接层） 或者 TLS（Transport Layer Security 安全传输协议）组和使用来加密传输内容。</p><p>用 SSL 建立安全通信线路以后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure）</p></li><li><p><strong>内容的加密</strong>  还有一种方式就是将参与通信的内容本身进行加密。这样的话就需要客户端对HTTP报文加密后再请求发送。由于该方式不同于HTTPS将整个通信线路加密的方式，所以内容仍然会有被篡改的风险。</p></li></ul><h3 id="7-1-2-伪装"><a href="#7-1-2-伪装" class="headerlink" title="7.1.2 伪装"></a>7.1.2 伪装</h3><p>HTTP 协议本身并不会对通信的另一方进行身份验证，所以任何人都能对服务器发起请求。</p><p>不验证通信方可能就会存在各种安全隐患：</p><ul><li>客户端无法确认自己的请求是否发送到了目标服务器或者返回响应的服务器是否是目标服务器，有可能是伪装了的服务器。</li><li>服务器无法确认向自己发起请求的客户端以及自己返回响应的客户端是否是目标中的客户端。</li><li>无法确认通信方是否具备访问权限，因为某些服务器只想给特定的用户访问。</li><li>即使是无意义的请求也会照单全收，使得服务器可能遭受到 DDoS 攻击。</li></ul><p><strong>通过查明对方证书来防止伪装</strong></p><p>SSL不仅提供加密处理，而且使用了一种称为证书的手段，可用于确认对方身份。</p><p><strong>证书由第三方机构颁发，用以证明服务器的客户端是实际存在的。</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38aa5f65f" alt="httpcert"></p><p>通过使用证书可以证明通信方就是意料中的服务器。对使用者而言，也减少了个人信息泄露的风险。</p><p>另外，客户端持有证书即可完成个人身份的认证，也可用于对网站的认证环节。</p><h3 id="7-1-3-篡改"><a href="#7-1-3-篡改" class="headerlink" title="7.1.3 篡改"></a>7.1.3 篡改</h3><p>HTTP协议通常无法确认信息的完整性，一旦传输的信息被篡改，那么信息就失去了准去性，导致信息有误。比如你想在某一个网站的下载一个资源，而你的资源传输已经被被人劫持，在你发起下载请求的时候，你所接收到的资源正在被人修改，所以你下载到的资源就不是你想要的那个了。</p><p>像这样，请求或者响应在传输途中遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack, MitM）。</p><p><strong>如何防止篡改</strong></p><p>之前的章节有提到过Content-MD5 实体首部字段可用于确认实体内容是否完整，但是由于Content-MD5本身的值也有可能被篡改，所以这个字段并不可靠，所以需要其他方法来确保传输的内容不被篡改。</p><p>通过其他散列算法来计算传输内容是否完整也不可靠，那么我们最终还是需要HTTPS来帮我解决这个问题。SSL提供认证和加密处理以及<strong>摘要功能</strong>。</p><h2 id="7-2-HTTPS"><a href="#7-2-HTTPS" class="headerlink" title="7.2 HTTPS"></a>7.2 HTTPS</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPS = HTTP + 加密 + 认证 + 摘要</span><br></pre></td></tr></table></figure><h3 id="7-2-1-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-1-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.1 HTTPS是身披SSL外壳的HTTP"></a>7.2.1 HTTPS是身披SSL外壳的HTTP</h3><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 的时候，就先和 SSL 通信，再由 SSL 和 TCP 通信了。所以简而言之，HTTPS 就是身披 SSL 外壳的 HTTP 协议。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38ab5952f" alt="https"></p><p>在采用 SSL 以后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护功能了。</p><p>SSL 协议是独立于 HTTP 的协议，所以其他协议也可以采用 SSL 协议，它是当今世界上应用最广泛的网络安全技术</p><h3 id="7-2-2-相互交换秘钥的公开秘钥加密技术"><a href="#7-2-2-相互交换秘钥的公开秘钥加密技术" class="headerlink" title="7.2.2 相互交换秘钥的公开秘钥加密技术"></a>7.2.2 相互交换秘钥的公开秘钥加密技术</h3><p>在将SSL之前可以了解一下加密技术，SSL采用一种叫做公开秘钥加密（Public-key Cryptography）的加密处理技术。</p><p>近代的加密方法中，加密算法是公开的，但是秘钥是保密的。加密和解密都会用到秘钥。没有秘钥无法对秘钥进行解密。反过来说没任何人只要拿到秘钥就可以解密信息。如果秘钥被攻击者获得，那加密就失去了意义</p><ul><li><p><strong>共享密钥加密的困境</strong></p><p><strong>加密和解密使用同一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密</strong>。</p><p>采用共享密钥加密方式加密时，需要将密钥一起发送给通信方，所以有需要考虑密钥传输的安全性，需要设法安全地保管密钥，这便是共享密钥加密方式的困扰。</p></li><li><p><strong>使用两把秘钥加密的公开秘钥加密方式</strong></p><p>公开密钥加密方式很好的解决了共享密钥加密方式的困扰。</p><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能被其他任何人知道，而公开密钥则可以仁任意传播，任何人都可以拿到。</p><p>使用公开密钥加密方式（非对称加密），发送密文的一方使用公钥进行加密处理，而接收方拿到被加密后的信息之后再使用自己的私钥进行解密。利用这种方式进行传输，就不需要发送密钥，也就不用担心密钥被攻击者拿走了。</p></li><li><p><strong>HTTPS采用混合加密机制</strong></p><p>HTTPS采用共享秘钥加密方式和公开秘钥加密方式混合的加密方式。</p><p>如果秘钥可以被安全传输，则HTTPS会考虑采用共享加密方式，否则将采用公开秘钥加密方式。这是因为公开密钥加密方式的速度比共享密钥加密方式要慢。HTTPS充分地利用了两者的有点，将多种方法组合起来用于通信。<strong>在使用公开密钥加密方式交换密钥之后，之后的信息传输使用共享密钥加密方式</strong>。</p></li></ul><h3 id="7-2-3-证明公开密钥正确性的证书"><a href="#7-2-3-证明公开密钥正确性的证书" class="headerlink" title="7.2.3 证明公开密钥正确性的证书"></a>7.2.3 证明公开密钥正确性的证书</h3><p>遗憾的是公开密钥加密方式本身也是有缺陷的，那就是无法证明公开的密钥本身是货真价实的。</p><p>为了解决上面说到的问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机构颁发的公开密钥证书。</p><p>数字证书认证机构处于客户端与服务端双方都信赖的第三方机构的立场上，威瑞新（VeriSign）就是其中一家非常有名的数字证书认证机构。</p><p>下面讲解一下数字证书认证机构的业务流程：</p><p>首先，服务器的运营人员会向数字机构提出公开密钥申请，CA 在认证申请者的身份信息之后，会对已申请的公开密钥进行数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书之后绑定在一起。</p><p>服务器会将这份 CA 颁发的公钥证书发送给客户端，以进行公钥加密方式通信，公钥证书也可叫做数字证书或者直接称为证书。</p><p>接到证书的客户端可使用 CA 的公钥对证书的数字签名进行认证，一旦验证通过，客户端便可确认两件事：</p><ul><li>认证服务器公钥的机构是真实有效的 CA 机构</li><li>服务器的公钥是值得信任的</li></ul><p>于是这就达到了确认公钥真实有效性的目的。</p><p>安全地转交 CA 机构的密钥给客户端是一件困难的事，因此多数浏览器会在内部植入常用认证机构的公钥。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd850947bf0" alt="httpskey"></p><ul><li><p>可证明组织真实性的 EV SSL 证书</p><p>证书的一个作用是证明作为通信一方的服务器是否符合规范，另一个作用是确认服务器运营商企业是否真实存在。能够证明企业真实性的正式就是 EV SSL 证书（Extended Validation SSL Certificate）。</p><p>该证书的目的是为了防止钓鱼攻击（Phishing）。</p></li><li><p>用以确认客户端的客户端证书</p><p>HTTPS 中还可以使用客户端证书对客户端进行认证。</p></li></ul><h2 id="7-4-HTTPS的安全通信机制"><a href="#7-4-HTTPS的安全通信机制" class="headerlink" title="7.4 HTTPS的安全通信机制"></a>7.4 HTTPS的安全通信机制</h2><p>为了更好的理解 HTTPS，我们来观察一下 HTTPS 的通信步骤。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-3badd05d6f7e3d84.png" alt="img"></p><ul><li>步骤1：客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li><li>步骤2：服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>步骤3：之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li><li>步骤4：最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</li><li>步骤5：SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li><li>步骤6：接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret密钥加密。</li><li>步骤7：客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>步骤8：服务器同样发送 Change Cipher Spec 报文。</li><li>步骤9：服务器同样发送 Finished 报文。</li><li>步骤10：服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完毕。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</li><li>步骤11：应用协议通信，即发送 HTTP 响应。</li><li>步骤12：最后由客户端断开连接。断开连接时，发送 close_notify 报文。</li></ul><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><p>下面是对整个流程的图解。图中说明了从仅适用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022150748120.png" alt="image-20201022150748120"></p><h3 id="SSL-速度慢吗"><a href="#SSL-速度慢吗" class="headerlink" title="SSL 速度慢吗"></a>SSL 速度慢吗</h3><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p><p>SSL 的慢是分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p><p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求/响应外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。</p><p>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。</p><p>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。</p><h3 id="为什么不一直使用-HTTPS"><a href="#为什么不一直使用-HTTPS" class="headerlink" title="为什么不一直使用 HTTPS"></a>为什么不一直使用 HTTPS</h3><ol><li>因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量也必然减少。因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。</li><li>除此之外，想要节约购买证书的开销也是原因之一。</li></ol><h1 id="8-确认访问用户身份的认证"><a href="#8-确认访问用户身份的认证" class="headerlink" title="8. 确认访问用户身份的认证"></a>8. 确认访问用户身份的认证</h1><h2 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h2><p>计算机本身无法判断坐在显示器前的使用者的身份，为了确认是谁在访问服务器，需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。核对的信息通常是指以下这些：</p><ul><li>密码：只有本人才会知道的字符串信息。</li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。</li><li>数字证书：仅限本人（终端）持有的信息。</li><li>生物认证：指纹和虹膜等本人的生理信息</li><li>IC 卡等：仅限本人持有的信息。</li></ul><p> <strong>HTTP/1.1 使用的认证方式如下所示：</strong></p><ul><li>BASIC认证（基本认证）</li><li>DIGEST认证（摘要认证）</li><li>SSL 客户端认证</li><li>FormBase 认证（基于表单认证）</li></ul><h2 id="8-2-BASIC-认证"><a href="#8-2-BASIC-认证" class="headerlink" title="8.2 BASIC 认证"></a>8.2 BASIC 认证</h2><p>BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022151634964.png" alt="image-20201022151634964"></p><p>步骤1：当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm）。</p><p>步骤2：接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（：）连接后，再经过 Base64 编码处理。将编码后的字符串写入首部字段 Authorization 后，发送请求。</p><p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。</p><p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解密。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。</p><p>另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。</p><p>BASIC 认证使用上不够灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。</p><h2 id="8-3-DIGEST-认证"><a href="#8-3-DIGEST-认证" class="headerlink" title="8.3 DIGEST 认证"></a>8.3 DIGEST 认证</h2><p>为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。DIGEST 认证同样使用质询/响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。</p><p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的咨询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-bb8255a4cfc8db60.png" alt="img"></p><p>因为发送给对方的只是响应摘要及由知讯码产生的计算结果，所以比起 BASIC 认证，密码泄露的可能性就降低了。</p><ul><li>DIGEST 认证的认证步骤</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-37e273e40111f18a.png" alt="img"></p><p>步骤1：请求需认证的资源时，服务器会随着状态码 401 Authorication Required，返回带  WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需要的临时咨询码（随机数，nonce）。</p><p>首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。</p><p>nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现</p><p>步骤2：接收到401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息，其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。</p><p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则会返回包含 Request-URI 资源的响应。</p><p>并且这时会在首部字段 Authorization-Info 写入一些认证成功的相关信息。</p><h2 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h2><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自登录的客户端。</p><ul><li>SSL 客户端认证的认证步骤</li></ul><p>为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。</p><p>步骤1：接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</p><p>步骤2：用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p><p>步骤3：服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</p><ul><li>SSL 客户端认证采用双因素认证</li></ul><p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p><p>换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。</p><ul><li>SSL 客户端认证必要的费用</li></ul><p>使用 SSL 客户端认证需要用到客户端证书，而客户端证书需要支付一定费用才能使用。</p><h2 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h2><p>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果认证。</p><p>多数情况下，输入已事先登录的用户 ID 和密码等登录信息后，发送给 Web 应用程序，基于认证结果来决定认证是否成功。</p><h4 id="8-5-1-Session-管理及-Cookie-应用"><a href="#8-5-1-Session-管理及-Cookie-应用" class="headerlink" title="8.5.1 Session 管理及 Cookie 应用"></a>8.5.1 Session 管理及 Cookie 应用</h4><p>第八章要讲的内容不多，所以把最重要的一点挪到了这一篇笔记。</p><p>关于用户身份的认证，现在多数是采用表单认证，一般会采用 Cookie 来管理 Session（会话）。</p><p>大致流程如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38ab3ca24" alt="httpsession"></p><p>具体步骤如下：</p><ul><li>客户端把用户的 ID 密码等登录信息放入报文的实体部分，通常用 POST 方法发送至服务器端。</li><li>服务器生成并发放用来识别客户的 Session ID，这个 Session ID 同时会在服务器端保存，然后通过 Set-Cookie 字段绑定到客户端。顺便可以使用 <code>httponly</code> 属性来禁止 JavaScript 修改 Cookie，防止跨站脚本攻击。</li><li>客户端把 Session ID 保存在本地 Cookie，下次访问时再带上。服务器端通过验证接收到的 Session ID 来识别用户，从数据库中可以顺便取到与用户相关的一系列信息。</li></ul><h1 id="9-基于-HTTP-的功能追加协议"><a href="#9-基于-HTTP-的功能追加协议" class="headerlink" title="9.基于 HTTP 的功能追加协议"></a>9.基于 HTTP 的功能追加协议</h1><h2 id="9-1-基于-HTTP-的协议"><a href="#9-1-基于-HTTP-的协议" class="headerlink" title="9.1 基于 HTTP 的协议"></a>9.1 基于 HTTP 的协议</h2><p>HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。</p><h2 id="9-2-消除-HTTP-瓶颈的-SPDY"><a href="#9-2-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="9.2 消除 HTTP 瓶颈的 SPDY"></a>9.2 消除 HTTP 瓶颈的 SPDY</h2><p>Google 在 2010 年发布了 SPDY，其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p><h3 id="9-2-1-HTTP-的瓶颈"><a href="#9-2-1-HTTP-的瓶颈" class="headerlink" title="9.2.1 HTTP 的瓶颈"></a>9.2.1 HTTP 的瓶颈</h3><p>HTTP 存在以下缺点和不足：</p><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收除响应以外的指令</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制压缩发送</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154013733.png" alt="image-20201022154013733"></p><ol><li>Ajax 的解决办法</li></ol><p>Ajax 是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少。</p><p>而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154032725.png" alt="image-20201022154032725"></p><ol><li>Comet 的解决办法<br> 一旦服务器有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延时应答，模拟实现服务器向客户端推送的功能。</li></ol><p>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154055953.png" alt="image-20201022154055953"></p><h3 id="9-2-2-SPDY-的设计与功能"><a href="#9-2-2-SPDY-的设计与功能" class="headerlink" title="9.2.2 SPDY 的设计与功能"></a>9.2.2 SPDY 的设计与功能</h3><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p><p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法，Cookie 以及 HTTP 报文等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154125271.png" alt="image-20201022154125271">spdy.png</p><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><ul><li>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</li><li>赋予请求优先级：SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li>压缩 HTTP 首部：压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了</li><li>推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</li><li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。</li></ul><h3 id="9-2-3-SPDY-消除-Web-瓶颈了吗"><a href="#9-2-3-SPDY-消除-Web-瓶颈了吗" class="headerlink" title="9.2.3 SPDY 消除 Web 瓶颈了吗"></a>9.2.3 SPDY 消除 Web 瓶颈了吗</h3><p>因为 SPDY 基本上只是将多个域名（IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会收到限制。</p><h2 id="9-3-使用浏览器进行全双工通信的-WebSocket9"><a href="#9-3-使用浏览器进行全双工通信的-WebSocket9" class="headerlink" title="9.3 使用浏览器进行全双工通信的 WebSocket9"></a>9.3 使用浏览器进行全双工通信的 WebSocket9</h2><p>WebSocket 是为解决 HTTP 协议所面临的困难的一种新的协议及 API。</p><h3 id="9-3-1-WebSocket-的设计与功能"><a href="#9-3-1-WebSocket-的设计与功能" class="headerlink" title="9.3.1 WebSocket 的设计与功能"></a>9.3.1 WebSocket 的设计与功能</h3><p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。</p><h3 id="9-3-2-WebSocket-协议"><a href="#9-3-2-WebSocket-协议" class="headerlink" title="9.3.2 WebSocket 协议"></a>9.3.2 WebSocket 协议</h3><p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可相互发送 JSON、XML、HTML 或图片等任意格式的数据。</p><p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p><p>下面我们列举一下 WebSocket 协议的主要特点：</p><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应较少了。</li></ul><p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次 “握手” 的步骤。</p><ol><li>握手·请求<br> 为了实现 WebSocket 通信，需要用到 HTTP 的 <code>Upgrade</code> 首部字段，告知服务器通信协议发送改变，已达到握手的目的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“GET /chat HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span>”</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Protocol</code> 字段内记录着握手过程中必不可少的键值，<code>Sec-WebSocket-Protocol</code> 字段内记录使用的子协议。</p><p>子协议按 <code>WebSocket</code> 协议标准在连接分开使用时，定义那些连接的名称。</p><ol><li>握手·响应<br> 对于之前的请求，返回状态码 <code>101 Switching Protocols</code> 的响应。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat”</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Accept</code> 的字段值是由握手请求中的 <code>Sec-WebSocket-Accept</code> 的字段值生成的。</p><p>成功握手确立 <code>WebSocket</code> 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154245807.png" alt="image-20201022154245807"></p><h2 id="9-4-期盼已久的-HTTP-2-0"><a href="#9-4-期盼已久的-HTTP-2-0" class="headerlink" title="9.4 期盼已久的 HTTP/2.0"></a>9.4 期盼已久的 HTTP/2.0</h2><p>HTTP/2.0 在 2014 年 11 月实现标准化。</p><ul><li>HTTP/2.0 的特点<br> HTTP/2.0 的目标是改善用户在使用 Web 时的速断体验。</li></ul><p>HTTP/2.0 围绕着主要的 7 项技术进行讨论。</p><table><thead><tr><th align="center">压缩</th><th align="center">SPDY、Friendly</th></tr></thead><tbody><tr><td align="center">多路复用</td><td align="center">SPDY</td></tr><tr><td align="center">TLS 义务化</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">协商</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">客户端拉拽</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">流量控制</td><td align="center">SPDY</td></tr><tr><td align="center">WebSocket</td><td align="center">Speed + Mobility</td></tr></tbody></table><h1 id="11-常见的Web攻击技术"><a href="#11-常见的Web攻击技术" class="headerlink" title="11.常见的Web攻击技术"></a>11.常见的Web攻击技术</h1><h2 id="11-1-跨站脚本攻击"><a href="#11-1-跨站脚本攻击" class="headerlink" title="11.1 跨站脚本攻击"></a>11.1 跨站脚本攻击</h2><p>跨站脚本攻击(Cross-Site Scripting , XSS) 是指通过存在安全漏洞的web网站注册用户的浏览器运行非法的HTML标签或者JavaScrip代码的一种攻击方式。动态创建的HTML可能存在安全漏洞。</p><p>该攻击可能造成以下影响：</p><ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li><li>显示伪造的文章或者图片</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bf024b37126" alt="xss"></p><p>上图的表单输入以后直接把输入内容当做 HTML 展示在页面上，所以存在着安全漏洞，攻击者可以直接在输入框内编辑危险的代码，然后就会在页面上运行。</p><h2 id="11-2-SQL-注入攻击"><a href="#11-2-SQL-注入攻击" class="headerlink" title="11.2 SQL 注入攻击"></a>11.2 SQL 注入攻击</h2><p>SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的安全威胁，有时会直接导致个人信息及机密信息的泄露。</p><p>SQL 注入可能会导致如下影响：</p><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><p>如果我们不对输入进行验证就直接拿去拼接 SQL 的话，是可能会被执行 SQL 注入攻击的。</p><h2 id="11-3-目录遍历攻击"><a href="#11-3-目录遍历攻击" class="headerlink" title="11.3 目录遍历攻击"></a>11.3 目录遍历攻击</h2><p>目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也被叫做路径遍历攻击（Path Traversal）。</p><h2 id="11-4-会话劫持"><a href="#11-4-会话劫持" class="headerlink" title="11.4 会话劫持"></a>11.4 会话劫持</h2><p>会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</p><p>具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理认证状态的主流方式。会话 ID 中记录客户端的 Cookie 等信息，服务器端将会话 ID 与认证状态进行一对一匹配管理。</p><p>攻击者可能通过以下方式获得会话 ID：</p><ul><li>通过非正规的生成方法推测会话 ID</li><li>通过窃听或 XSS 攻击盗取会话 ID</li><li>通过会话固定攻击（Session Fixation）强行获取会话 ID</li></ul><p>通常情况下攻击者在发现网站存在的 XSS 攻击漏洞之后，会注入一段 JavaScript 代码，通过 <code>document.cookie</code> 盗取到会话 ID，之后植入到自己的浏览器，就可以伪装成被盗窃的用户访问被攻击的网站。</p><h2 id="11-5-跨站点请求伪造"><a href="#11-5-跨站点请求伪造" class="headerlink" title="11.5 跨站点请求伪造"></a>11.5 跨站点请求伪造</h2><p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</p><p>最常见的例子就是在一个需要登录才能进行操作的网站，攻击者在该网站伪造了一个可以触发危险操作的内容（比如 a 和 button 标签），用户在不经意间点击这些伪造的内容后就自动发起了请求，而这些请求如果是指向当前网站的话，用户的会话 ID 等信息也会被带上，使得被攻击者不经意之间完成了一次可能极为危险的操作。</p><h2 id="11-6-点击劫持"><a href="#11-6-点击劫持" class="headerlink" title="11.6 点击劫持"></a>11.6 点击劫持</h2><p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱导用户在不知情的情况下点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</p><p>这种攻击最常见的案例就是某些小网站……</p><h2 id="11-7-DoS-攻击"><a href="#11-7-DoS-攻击" class="headerlink" title="11.7 DoS 攻击"></a>11.7 DoS 攻击</h2><p>DoS 攻击（Denial of Service Attack）是一种让运行中的服务呈停止状态的攻击。有时也叫作停止服务攻击或者拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。</p><p>DoS 主要有以下两种攻击方式：</p><ul><li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态</li><li>通过攻击安全漏洞是服务停止</li></ul><p>由此可见所有使得服务停止的攻击都可以称为 DoS 攻击。</p><p>DoS 攻击在中国前端届比较著名的案例就是阮一峰老师的博客遭到过的一次攻击：<a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html">DDOS 攻击的防范教程</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-HTTP首部&quot;&gt;&lt;a href=&quot;#6-HTTP首部&quot; class=&quot;headerlink&quot; title=&quot;6. HTTP首部&quot;&gt;&lt;/a&gt;6. HTTP首部&lt;/h1&gt;&lt;h2 id=&quot;6-1-HTTP报文首部&quot;&gt;&lt;a href=&quot;#6-1-HTTP报文首部&quot; c</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://leslieaibin.github.io/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
</feed>
