<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2020-11-22T10:00:24.516Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统（一）操作系统概述</title>
    <link href="https://leslieaibin.github.io/2020/11/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://leslieaibin.github.io/2020/11/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-11-21T16:15:42.000Z</published>
    <updated>2020-11-22T10:00:24.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统举例"><a href="#操作系统举例" class="headerlink" title="操作系统举例"></a>操作系统举例</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2020022012313767.png" alt="在这里插入图片描述"></p><h2 id="操作系统的层次结构"><a href="#操作系统的层次结构" class="headerlink" title="操作系统的层次结构"></a>操作系统的层次结构</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121211023859.png" alt="image-20201121211023859"></p><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><ul><li>是系统最基本最核心的软件，属于系统软件</li><li>控制和管理整个计算机的硬件和软件资源</li><li>合理的组织、调度计算机的工作与资源分配</li><li>为用户和其他软件提供方便的接口和环境</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121212138580.png" alt="image-20201121212138580"></p><h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121212425015.png" alt="image-20201121212425015"></p><h3 id="计算机系统资源的管理者"><a href="#计算机系统资源的管理者" class="headerlink" title="计算机系统资源的管理者"></a>计算机系统资源的管理者</h3><ul><li><p>处理机管理（进程管理）</p></li><li><p>存储器管理（内存）</p></li><li><p>文件管理（文件系统）</p></li><li><p>设备管理（I/O）</p></li></ul><h4 id="处理机管理-进程管理"><a href="#处理机管理-进程管理" class="headerlink" title="处理机管理(进程管理)"></a>处理机管理(进程管理)</h4><p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归纳为进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁通信、处理机调度等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121214558742.png" alt="image-20201121214558742"></p><h4 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h4><p>为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存的<strong>分配与回收、地址映射、内存保护与共享和内存扩充</strong>等功能。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121230607457.png" alt="image-20201121230607457"></p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>计算机中所有的信息都是以文件的形式存在的，操作票系统中负责文件管理的部分称为文件系统，文件管理包括<strong>文件存储空间的管理、目录管理及文件读写管理和保护</strong>等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121230956206.png" alt="image-20201121230956206"></p><h4 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h4><p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓<strong>存管理、设备分配、设备处理和虚拟设备</strong>等功能。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121231235672.png" alt="image-20201121231235672"></p><p><strong>以上4种管理功能都由“工人”负责，“雇主”无序关注。</strong></p><h3 id="用户与计算机硬件系统之间的接口"><a href="#用户与计算机硬件系统之间的接口" class="headerlink" title="用户与计算机硬件系统之间的接口"></a>用户与计算机硬件系统之间的接口</h3><ul><li><p>为了让用户方便、快捷、可靠的操作计算机硬件并执行自己的程序，操作系统提供了用户接口</p></li><li><p>操作系统提供的接口分为两类：<code>命令接口和程序接口</code></p><ul><li><strong>命令接口</strong>：用户可以<strong>直接</strong>使用的，利用这些操作命令来组织和控制作业的执行</li><li><strong>程序接口</strong>：用户通过程序<strong>间接</strong>使用的，编程人员可以使用它们来请求操作系统服务</li></ul></li></ul><h4 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h4><p>用户利用这些命令来组织和控制作业的运行</p><ul><li><p>联机命令接口： 又称交互式命令接口，适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121232243498.png" alt="image-20201121232243498"></p></li><li><p>脱机命令接口： 又称批处理命令接口，使用于批处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令。在操作系统运行这些命令时用户不可干预。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121232546065.png" alt="image-20201121232546065"></p></li></ul><h4 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h4><p>由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用请求操作系统为其提供服务，只能通过用户程序间接调用，如使用各种外部设备、申请分配和回收内存及其他各种要求</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121233121560.png" alt="image-20201121233121560"></p><h3 id="作为扩充机器（虚拟机）"><a href="#作为扩充机器（虚拟机）" class="headerlink" title="作为扩充机器（虚拟机）"></a>作为扩充机器（虚拟机）</h3><p>没有任何软件支持的计算机称为<strong>裸机</strong>，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器：因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p><h1 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h1><p>操作系统是一种系统软件，但与其它系统软件和应用软件有很大的不同，它有自己的特殊性，及基本特征。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121234036988.png" alt="image-20201121234036988"></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>并发</strong>：两个或多个时间在同一时间间隔内发生，这些时间在宏观上是同时发生的，在微观上是交替发生的，操作系统的并发性指系统中同时存在着多个运行的程序。</p><p><strong>并行</strong>：两个或多个时间在同一时刻发生</p><ul><li>一个单核(CPU)同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</li><li>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的</li><li>在如今的计算机中，一般都是多核cpu的，即在同一<strong>时刻</strong>可以并行执行多个程序，比如我的计算机是8核的，我的计算机可以在同一时刻并行执行8个程序，但是事实上我们计算机执行的程序并不止8个，因此并发技术是必须存在的，并发性必不可少。</li></ul><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>资源共享即共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用，共享分为两类：<strong>互斥共享和同时共享</strong></p><h3 id="互斥共享"><a href="#互斥共享" class="headerlink" title="互斥共享"></a>互斥共享</h3><ul><li>计算机中的某个资源在一段时间内只能允许<code>一个进程</code>访问，别的进程没有使用权</li><li>临界资源(独占资源)：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享</li><li>举个例子：比如QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li></ul><h3 id="同时共享"><a href="#同时共享" class="headerlink" title="同时共享"></a>同时共享</h3><ul><li>计算机中的某个资源在在一段时间内可以<code>同时</code>允许<code>多个</code>进程访问</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，<strong>分时共享</strong></li><li>这里的<code>同时</code>指在宏观上是同时的，在微观上是交替进行访问的，只是cpu处理速度很快，我们感觉不到，在宏观上感觉是在同时进行</li><li>举个例子：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行访问磁盘的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li><strong>注意</strong>：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul><h3 id="并发性和共享性互为存在条件"><a href="#并发性和共享性互为存在条件" class="headerlink" title="并发性和共享性互为存在条件"></a>并发性和共享性互为存在条件</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122000214611.png" alt="image-20201122000214611"></p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。 物理实体（前者） 是实际存在的， 而逻辑上<br>对应物（后者） 是用户感受到的。  </p><p>多道程序设计：是指在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。</p><ul><li>虚拟是把一个物理上的实体变为若干逻辑上的对应物。</li><li>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</li><li>虚拟技术：用于实现虚拟的技术</li><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的</li><li>操作系统的虚拟技术科归纳为：<ul><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟存储器</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122000457368.png" alt="image-20201122000457368"></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步是指， 在多道程序环境下， 允许多个程序并发执行， 但由于资源有限， 进程的执行不是一贯到底的，<br>而是走走停停， 以不可预知的速度向前推进， 这就是进程的异步性。  </p><ul><li>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</li></ul><p>如果失去了并发性， 即系统只能串行地运行各个程序， 那么每个程序的执行会一贯到底。 只有系统拥有并发性， 才有可能导致异步性。  </p><h1 id="操作系统分类和发展"><a href="#操作系统分类和发展" class="headerlink" title="操作系统分类和发展"></a>操作系统分类和发展</h1><h2 id="操作系统的分类及其特征优劣"><a href="#操作系统的分类及其特征优劣" class="headerlink" title="操作系统的分类及其特征优劣"></a>操作系统的分类及其特征优劣</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20200222160313682.png" alt="在这里插入图片描述"></p><h2 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122003006007.png" alt="image-20201122003006007"></p><h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><h2 id="两种命令"><a href="#两种命令" class="headerlink" title="两种命令"></a>两种命令</h2><ul><li><p>特权指令</p><p>不允许用户直接使用的命令，比如：I/O令、置中断指令、存取用于内存保护的寄存器、送程序状态字到程序状态寄存器，内存清零等的指令</p></li><li><p>非特权指令</p><p>加减乘除等普通运算指令</p></li></ul><h2 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h2><ul><li><p>核心态(管态)</p><p>特权指令和非特权指令都可执行</p></li><li><p>用户态(目态)</p><p>只能执行非特权指令</p></li></ul><h2 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h2><ul><li><p>内核程序（管理程序）</p><p>操作系统内核程序是系统管理，特权指令和非特权指令都可执行，运行在核心态</p></li><li><p>用户持续（应用程序）</p><p>为了保证系统能够安全运行，用户只能执行非特权指令，运行在用户态</p></li></ul><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122172717616.png" alt="image-20201122172717616"></p><p>内核是计算机配置在底层的软件，是操作系统最基本最核心的部分；实现操作系统内核功能的程序是内核程序</p><ul><li><strong>时钟管理</strong><ul><li>计时  操作系统需要通过时钟管理，向用户提供标准的系统时间</li><li>切换进程 在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度</li></ul></li><li><strong>中断机制</strong><ul><li>初衷是提高多道程序运行环境中CPU的利用率，主要针对外部设备</li><li>后来逐步得到发展形成了多种类型，成为操作系统各项操作的基础</li></ul></li><li><strong>原语</strong><ul><li>处于操作系统的最低层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性，其操作只能一气呵成（主要从系统安全性和便于管理考虑）</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul></li><li><strong>资源管理</strong><ul><li>进程管理  进程状态管理、进程调度和分派、创建与撤销进程控制块</li><li>存储器管理 存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li><li>设备管理 缓冲区管理、设备分配和回收等</li></ul></li></ul><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="中断技术的诞生"><a href="#中断技术的诞生" class="headerlink" title="中断技术的诞生"></a>中断技术的诞生</h2><p>为了实现多道程序并发执行的一种技术为了提高资源利用率</p><h2 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h2><p>发生中断，就意味着需要操作系统介入开展管理工作，cpu会立即进入核心态作用：</p><p>“中断”是CPU从用户进入核心态的<strong>唯一途径</strong></p><h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>陷入（有意而为之的异常，如系统调用）、故障（由错误条件引起的，可能被故障处理程序修复，如缺页）、终止（不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除以0），<strong>信号来源CPU内部，与当前执行的指令有关</strong></p><ul><li><p>资源中断</p><ul><li>指令中断：系统调用时使用的访管指令（又叫陷入指令，trap指令）</li></ul></li><li><p>强迫中断</p><ul><li>硬件故障： 缺页</li><li>软件中断： 整数除以0</li></ul></li></ul><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p><strong>信号来源于CPU外部，与当前执行的指令无关</strong></p><ul><li>外设要求    如：/操作完成发出的中断信号</li><li>人为干预    如：用户强行终止一个进程</li></ul><h2 id="中断（外中断）处理过程"><a href="#中断（外中断）处理过程" class="headerlink" title="中断（外中断）处理过程"></a>中断（外中断）处理过程</h2><ul><li><p>关中断    CPU响应中所后，应该拒绝响应更高级的中源的中断请求件完成</p></li><li><p>保存断点    完成为了之后能重新恢复执行这个程序，需要将原来的程序的断点（即程序计数器PC）保存起来</p></li><li><p>中断服务程序寻址    取出中断服务程序的入口地址送到程序计数器PC</p></li><li><p>保存现场和屏蔽字    中断程序完成进入程序中所服务程序后，首先要保护现场，现场信息一般是指程序状态字寄存器PSWR和某些通用寄存器的内容</p></li><li><p>开中断 允许更高级中断请求得到响应，想象一下多道程序设计的并发执行，CPU交替执行内存里面的各个程序</p></li><li><p>执行中断 服务程序这是中断请求的目的，完成某些中断后的操作</p></li><li><p>关中断    保证在恢复现场和屏蔽字时不被中断，完成中断后的操作之后，需要恢复现场，不希望被打扰</p></li><li><p>恢复现场和屏蔽字    将现场和屏蔽字恢复到原来的状态</p></li><li><p>开中断    中断返回中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122172302086.png" alt="image-20201122172302086"></p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是操作系统提供给应用程序的接口</p><p>作用：应用程序可以通过系统调用（程序接口）请求获得操作系统的服务</p><p>系统调用会使处理器从用户态切换到核心态</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>设备管理     完成设备的请求、释放启动等功能</li><li>文件管理    完成文件的读，写、创删除等功能</li><li>进程控制    完成进程的创建、撒销、阻塞、唤醒等功能</li><li>进程通信    完成进程之间的消息传递、信号传递等功能</li><li>内存管理    完成内存的分配、回收、获取作业占用内存区大小及始址等功能</li></ul><h2 id="系统调用和库函数区别"><a href="#系统调用和库函数区别" class="headerlink" title="系统调用和库函数区别"></a>系统调用和库函数区别</h2><p>系统用时操作系统向上提供的接口</p><p>有的库函数是对系统调用的进一步封装</p><p>当今编写的应用程序大多是通过高级语言提供的库数接的进行系统调用</p><h2 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a>系统调用背后的过程</h2><ul><li>用户程序执行陷入指令（又称访问指令/Trap指令），请求操作系统服务</li><li>操作系统内核程序对系统调用进行相应处理</li><li>处理完成后，操作系统内核程序将CPU使用权还给用户</li></ul><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><ul><li><p>大内核</p><p>操作系统的主要功能模块都作为一个紧密联系的整体运行在和心态，为应用提供高性能的系统服务。但随着体系结构和应用需求的发展，需要操作系统提供的服务越来越多，接口越来越复杂，设计规模急剧增长。</p><p>优点： 高性能</p><p>缺点： 内核代码庞大、结构混乱、难以维护</p></li><li><p>微内核</p><ul><li><p>将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。</p></li><li><p>被移出的代码根据分层的原则被划分为若干服务程序，执行相互独立，交互借助于微内核进行通信。</p></li><li><p>微内核结构有效的分离了内核与服务、服务与服务，使得接口更加清晰，维护代价大大降低，各部分可以独立的优化和演进，从而保证操作系统的可靠性。</p></li><li><p>客户服务器模式：将进行划分为两类，服务器用来提供服务，客户端使用这些服务。</p></li></ul><p>优点： 内核功能少、结构清晰、方便维护</p><p>缺点：需要频繁在用户态和核心态之间切换，性能低</p></li></ul><p><strong>内核态→用户态</strong>：执行一条特权指令一一修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</p><p><strong>用户态→内核态</strong>：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122162253358.png" alt="image-20201122162253358"></p><h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><h2 id="CPU-（Central-Processing-Unit）"><a href="#CPU-（Central-Processing-Unit）" class="headerlink" title="CPU （Central Processing Unit）"></a>CPU （Central Processing Unit）</h2><ul><li>CPU从系统的RAM中提取指令，然后解码该指令的实际内容，然后由CPU的相关部分执行该指令（提取、解码和执行）</li><li>CPU从功能上看主要由两部分构成<ol><li>控制单元： 从内存中提取指令并解码执行</li><li>算数逻辑单元（ALU）： 处理算数和逻辑运算</li></ol></li><li>内部结构：<ol><li>寄存器：中央处理器内的组成部分。用来暂存指令、数据和地址。可以将其看作是内存的一中，根据种类的不同，一个CPU内部会有20-100个寄存器。</li><li>控制器：负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机</li><li>运算器： 负责运算从内存中读入寄存器的数据</li><li>时钟：负责发出CPU开始计时的时钟信号</li></ol></li></ul><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>累加寄存器</td><td>存储运行的数据和运算后的数据</td></tr><tr><td>标志寄存器</td><td>用于反应处理器的状态和运算结果的某些特征以及控制指令的执行</td></tr><tr><td>程序计数器</td><td>程序计数器是用于存放下一条指令所在单元的地址的地方</td></tr><tr><td>基址寄存器</td><td>存储数据内存的起始位置</td></tr><tr><td>变址寄存器</td><td>存储基址寄存器的相对地址</td></tr><tr><td>通用寄存器</td><td>存储任意数据</td></tr><tr><td>指令寄存器</td><td>储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td></tr><tr><td>栈寄存器</td><td>存储栈区域的起始位置</td></tr></tbody></table><ul><li>CPU指令执行过程<ol><li>取指令</li><li>指令译码</li><li>执行指令</li><li>访问取数</li><li>结果写回</li></ol></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的。</li><li>又称为主存，作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据</li><li>只要计算机在运行中，CPU就会把需要运算的数据调到主存中进行运算，当运算完成后CPU再将结构传送回来</li><li>内存的内部是有各种IC（Integrated Circuit，集成电路）电路组成的，它的种类很庞大，但是主要分为三种存储器：<ol><li>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</li><li>只读存储器（ROM）：ROM一般只能用于数据的读取，不能写入数据，但是当机器停电时，数据不会丢失</li><li>高速缓存（Cache）：分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache），它位于内存和CPU之间，是一个读写速度比内存更快的存储器。当CPU向内存写入数据时，这些数据会被写入高速缓存中，需要读取数据时，会直接从高速缓存中读取。如果需要的数据在Cache中没有，会再去读取内存中的数据</li></ol></li></ul><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><ul><li>磁盘中存储的程序必须加载到内存中才能运行，在磁盘中保存的程序是无法直接运行的。这是因为负责解析和运行程序内容的CPU是需要通过程序计数器来指定内存地址从而读出程序指令的。</li><li>磁盘缓存和虚拟内存</li></ul><h2 id="BIOS和引导"><a href="#BIOS和引导" class="headerlink" title="BIOS和引导"></a>BIOS和引导</h2><p>程序的运行环境，存在着名为BIOS（Basic Input/Output System）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘和显卡等基本控制外，还有引导程序的功能，引导程序是存储在启动驱动器启示区域的小程序。</p><p>电脑开机后，BIOS会确认硬件是否正常运行，没有异常的话会直接启动引导程序。引导程序的功能是吧在硬盘等记录的OS加载到内存中运行。虽然启动应用是OS的功能，但是OS不能启动自己，是通过引导程序启动的。</p><h2 id="DMA（Direct-Memory-Access）"><a href="#DMA（Direct-Memory-Access）" class="headerlink" title="DMA（Direct Memory Access）"></a>DMA（Direct Memory Access）</h2><p>DMA是指在不通过CPU的情况下，外围设备直接和主存进行数据传输。通过DMA大量数据可以在短时间内实现传输，因为CPU作为中介的事件被节省了。</p><p>参考: 王道考研 <a href="https://www.bilibili.com/video/BV1YE411D7nH">计算机操作系统</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;操作系统举例&quot;&gt;&lt;a href=&quot;#操作系统举例&quot; class=&quot;headerlink&quot; title=&quot;操作系统举</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch7.6.1 入门到实战</title>
    <link href="https://leslieaibin.github.io/2020/11/20/Java/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://leslieaibin.github.io/2020/11/20/Java/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2020-11-19T16:15:42.000Z</published>
    <updated>2020-11-20T13:30:03.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ElasticSearch</strong> ，简称为es，是一个开源的、高拓展的分布式全文检索引擎，它可以近乎实时的存储、检索数据。本身拓展性很好，可以拓展到上百台服务器，处理PB级别的数据。ElasticSearch使用java开发并且使用Lucene作为其核心来实现所有索引和搜索的功能，但是他的目的是通过简单的RestFul API来隐藏Lucene的复杂性，从而让全文检索变得简单。</p><h2 id="ElasticSearch和Solr的比较"><a href="#ElasticSearch和Solr的比较" class="headerlink" title="ElasticSearch和Solr的比较"></a>ElasticSearch和Solr的比较</h2><ul><li>es基本上是开箱即用，非常简单，Solr安装略麻烦；</li><li>Solr利用Zookeeper进行分布式管理，而elasticsearch自身就带有分布式协调管理功能；</li><li>Solr支持更多格式的数据，例如：json，xml，csv，而ElasticSearch仅仅支持json文件格式；</li><li>Solr官方提供的功能更多，而ElasticSearch本身更注重核心功能，高级功能多由第三方插件提供，例如图形化界面需要kibana友好支持；</li><li>Solr查询快，但更新索引时慢（即插入删除慢），用于电商的查询多的应用；<ul><li>ElasticSearch建立索引快（即查询慢），即实时性查询快，用于新浪的搜索；</li><li>Solr是传统搜索应用的解决方案，但ElasticSearch更适用于新兴的实时搜索应用。</li></ul></li><li>Solr比较成熟，有一个更大、更成熟的用户、开发和贡献者社区，而ElasticSearch相对开发维护者较少，更新太快，学习使用成本较高。</li></ul><h2 id="ElasticSearch安装及启动"><a href="#ElasticSearch安装及启动" class="headerlink" title="ElasticSearch安装及启动"></a>ElasticSearch安装及启动</h2><p>声明：ElasticSearch要求安装环境必须是要jdk1.8以上才行。</p><p><strong>1、下载安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f873770589" alt="在这里插入图片描述"></p><p><strong>2、解压安装包完成解压</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f87e35e972" alt="在这里插入图片描述"></p><p>解压完成即安装完成。</p><p><strong>3、ElasticSearch目录环境说明</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204157257.png" alt="image-20201120204157257"></p><ul><li>bin：可执行文件</li><li>config：配置文件<ul><li>elasticsearch.yml：项目配置文件</li><li>jvm.options：jvm相关的配置文件</li><li>log4j2.properties：日志相关配置文件</li></ul></li><li>jdk：相关的jdk环境</li><li>lib：项目所使用的相关jar包</li><li>logs：日志信息</li><li>modules：模块信息</li><li>plugins：插件信息</li></ul><p><strong>4、启动ElasticSearch</strong> 双击elasticsearch.bat运行。</p><p><strong>5、访问</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204350146.png" alt="image-20201120204350146"></p><p>访问成功！</p><h2 id="可视化界面的安装"><a href="#可视化界面的安装" class="headerlink" title="可视化界面的安装"></a>可视化界面的安装</h2><p>声明：可视化界面的安装必须基于node.js的环境</p><p><strong>1、下载可视化界面的项目压缩包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f882073b44" alt="在这里插入图片描述"></p><p><strong>2、解压</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204504275.png" alt="image-20201120204504275"></p><p><strong>3、启动可视化页面</strong></p><p>因为是基于node.js的前端项目，所以我们先要进入到项目文件，在cmd窗口中使用<code>npm install</code>命令安装相关环境，然后使用<code>npm run start</code>运行项目：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204553147.png" alt="image-20201120204553147"></p><p>启动完成，访问端口是9100。</p><h3 id="解决可视化界面访问ElasticSearch产生的跨域问题"><a href="#解决可视化界面访问ElasticSearch产生的跨域问题" class="headerlink" title="解决可视化界面访问ElasticSearch产生的跨域问题"></a>解决可视化界面访问ElasticSearch产生的跨域问题</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f89b18c48e" alt="在这里插入图片描述"></p><p>可视化界面的端口是9100，通过可视化界面去访问9200的ElasticSearch会产生跨域问题。</p><p><strong>修改ElasticSearch.yml文件让其支持跨域请求</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a5a5264d" alt="在这里插入图片描述"></p><p>在yml文件的最后加上允许跨域的配置，并重启ElasticSearch。</p><p>重启之后再使用可视化界面进行访问：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a538bc03" alt="在这里插入图片描述"></p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Kibana是一个针对ElasticSearch的开源分析及可视化平台，用于搜索、查看交互存储在ElasticSearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解，它操作简单，基于浏览器的用户界面可以快速创建仪表板实时显示ElasticSearch查询动态。设置Kibana非常简单，无需编码或者额外的基础架构，几分钟就可以完成安装并启动索引监测。</p><p><strong>注意事项</strong>：Kibana的版本必须要与安装的es版本一致。</p><p>我们可以将es理解为一个处理海量数据的数据库，Kibana可以监测并分析数据库中的数据信息。</p><h3 id="Kibana的安装和启动"><a href="#Kibana的安装和启动" class="headerlink" title="Kibana的安装和启动"></a>Kibana的安装和启动</h3><p><strong>1、下载安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a95bfccc" alt="在这里插入图片描述"></p><p><strong>2、解压安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204800373.png" alt="image-20201120204800373"></p><p><strong>3、启动Kibana</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204914227.png" alt="image-20201120204914227"></p><p><strong>4、访问</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204935828.png" alt="image-20201120204935828"></p><p>访问成功！</p><h3 id="Kibana的汉化"><a href="#Kibana的汉化" class="headerlink" title="Kibana的汉化"></a>Kibana的汉化</h3><p>Kibana是支持汉化的，我们只需要在他的项目yml文件中进行相关配置即可：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8c8bc988d" alt="在这里插入图片描述"></p><p>配置保存之后重启Kibana：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8ca016c3f" alt="在这里插入图片描述"></p><p>汉化完成！</p><h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><p>ElasticSearch是一个面向文档的数据库，其中的所有数据都是json，以下是各种专用名词和关系型数据库的对比：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8d088a633" alt="在这里插入图片描述"></p><p>ElasticSearch中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档，每个文档中又包含多个字段。</p><p><strong>物理设计：</strong></p><p>ElasticSearch在后台把每个索引划分为多个分片，每份分片可以在集群的不同服务器间迁移。ElasticSearch一启动就是一个集群，哪怕只有一个，默认的集群名称为：elasticsearch。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120205122140.png" alt="image-20201120205122140"></p><p><strong>逻辑设计</strong></p><p>在ES中，一个索引中包含多个文档，当我们索引一篇文档时，可以通过这样的顺序找到它：索引&gt;类型&gt;文档ID。通过这个组合我们就能索引到某个具体的文档。</p><blockquote><p>文档</p></blockquote><p>文档的概念换算到关系型数据库中就类似于一条数据。</p><p>ES是面向文档的，也就意味着索引和搜索数据的最小单位是文档，在ElasticSearch中，文档有几个重要属性：</p><ul><li>自我包含：一片文档同时包含字段和对应的值，也就是同时包含key-value；</li><li>可以是层次型的：一个文档包含另一个文档；</li><li>灵活的结构：文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用。在ElasticSearch中，对于字段是非常灵活的，有时候我们可以忽略该字段，或者动态的添加一个新的字段。</li></ul><blockquote><p>类型</p></blockquote><p>类型是文档的逻辑容器，就像关系型数据库中表格是行的容器一样，类型对于字段的定义称之为映射，比如说<code>name</code>映射为字符串类型。</p><p>我们说文档是无模式的，我们不需要对我们新增的每一个字段的类型进行映射，在没有进行映射的时候Elasticsearch会对数据的类型进行猜测，但是也有可能会猜不对，所以最安全的方式提前定义好所需要的映射，这一部分就跟关系型数据库差不多了。</p><blockquote><p>索引</p></blockquote><p>索引就类似于关系型数据库中的数据库。</p><p>索引是映射类型的容器，ElasticSearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置，然后他们被保存到了各个分片上。</p><blockquote><p>物理设计：节点和分片如何工作</p></blockquote><p>一个集群至少有一个节点，就是最基本的elasticsearch进程，每个节点可以有多个索引，如果你创建索引，则，默认会创建5个分片（又称主分片），每一个分片都会有一个副本（又称复制分片）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8e4abf4d5" alt="在这里插入图片描述"></p><p>例如上图是一个有三个节点的集群，可以看到主分片对应的复制分片都不会在同一个节点内，这样就有利于如果某个节点挂掉了，数据也不至于丢失，</p><p>实际上，一个分片是一个lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使得ElasticSearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。</p><p>等等，倒排索引是什么？？？？</p><blockquote><p>倒排索引</p></blockquote><p>Lucene采用倒排索引作为底层，这种设计适用于快速的全文搜索。</p><p>在ElasticSearch中，倒排索引的做法是对索引中的每个单词都进行重构为一个索引列表， 这样就可以清楚的反应每个单词在文档中的位置，当我们想要查找某个数据的时候，根据倒排索引生成的索引列表就可以最大限度的避免不符合数据的重复查询，只会在包含该数据的文档中进行查询。</p><p>例如下图数据：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8e661322b" alt="在这里插入图片描述"></p><p>在以上数据中可以得知：python这个词条，在1，2，3号文档中都有出现，linux这个词条在3，4号文档中出现，当我们想要查询linux这个词条的时候，根据倒排索引生成的索引列表，就不会再去查询1，2这两个文档，最大限度的避免了无用数据的查询。</p><p><strong>ElasticSearch索引和Lucene索引的关系</strong></p><p>在ElasticSearch中，每创建一个索引就会生成多个分片，其实每个分片就是一个Lucene索引，所以一个ElasticSearch索引本质就是用多个Lucene索引构成的。</p><h2 id="ik分词器插件"><a href="#ik分词器插件" class="headerlink" title="ik分词器插件"></a>ik分词器插件</h2><blockquote><p>什么是分词器？</p></blockquote><p>分词的意思就是把一段文字分成一个个的关键字，我们在搜索的时候会把自己的信息进行分词，会把数据库中的数据进行分词，然后进行一个匹配操作。</p><p>例如，我搜索”奥特曼打小怪兽“，在搜索结果中你可能看到只包含”奥特曼“的信息，也有可能看到只包含”小怪兽”的信息，这就是程序对我们的搜索信息进行了分词。</p><p>而默认的中文分词器是将每一个字分成一个词，例如：”奥特曼“分解成”奥“”特“”曼“。这种粒度的分词显然是不太方便的，所以在此我们使用ik分词器插件。</p><p>ik分词器提供了两个分词算法：ik_smart和ik_max_word，其中ik_smart为最少切分，ik_max_word为最细粒度切分。</p><h3 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h3><p><strong>1、下载</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8ee6df28f" alt="在这里插入图片描述"></p><p><strong>2、将压缩包解压到ElsticSearch的插件包中</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8eef02040" alt="在这里插入图片描述"></p><p><strong>3、重启ElasticSearch</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8f1893256" alt="在这里插入图片描述"></p><p>重启可以在日志中观察到ik分词器插件被加载。</p><p><strong>4、使用ElasticSearch的命令查看插件是否安装成功</strong></p><p>在ElasticSearch的bin目录中打开cmd窗口，输入命令<code>elasticsearch-plugin list</code>即可查看安装的插件列表：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f906288fc5" alt="在这里插入图片描述"></p><h3 id="使用Kibana发送请求展示ik分词器效果"><a href="#使用Kibana发送请求展示ik分词器效果" class="headerlink" title="使用Kibana发送请求展示ik分词器效果"></a>使用Kibana发送请求展示ik分词器效果</h3><p><strong>json代码：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET _analyze   //请求分词器</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,   <span class="comment">//选择分词算法</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;大连理工大学信息检索与文本挖掘&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>分词效果：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120205327514.png" alt="image-20201120205327514"></p><p>由上可以看到，分词器会根据语句中的词语进行分割，但是他们怎么认使什么字连起来是一个词呢？这是因为在分词器的内部有一个自己的字典，可以识别常用的正常词语，当我们输入一个人名或者自己捏造的词语的时候就无法达到想要的效果。</p><h2 id="ElasticSearch基本操作"><a href="#ElasticSearch基本操作" class="headerlink" title="ElasticSearch基本操作"></a>ElasticSearch基本操作</h2><p>操作ElasticSearch的命令都是通过RestFul风格的请求命令去完成的，大致如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9645bb539" alt="在这里插入图片描述"></p><blockquote><p>使用Kibana演示基础操作</p></blockquote><h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><p>语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引名/类型名/文档id</span><br><span class="line">&#123;</span><br><span class="line">    请求体</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f92a72cc2f" alt="在这里插入图片描述"></p><p>在head页面上查看数据：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9436bf43b" alt="在这里插入图片描述"></p><p>由以上示例可知，我们通过put命令创建了一个索引并添加了文档数据，但是我们并没有给这个索引映射类型，在ElasticSearch中数据有多少的数据类型呢？</p><p>ElasticSearch相关的数据类型：</p><ul><li>字符串类型：text、keyword</li><li>数值类型：long、integer、short、byte、doule、float、half float、scaled float</li><li>日期类型：date</li><li>布尔值类型：boolean</li><li>二进制类型：binary</li><li>等等……</li></ul><h3 id="创建一个索引不赋值并指定类型"><a href="#创建一个索引不赋值并指定类型" class="headerlink" title="创建一个索引不赋值并指定类型"></a>创建一个索引不赋值并指定类型</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f936aa0804" alt="在这里插入图片描述"></p><p>以上json命令只创建了一个test2索引并映射类型</p><h3 id="查看索引信息"><a href="#查看索引信息" class="headerlink" title="查看索引信息"></a>查看索引信息</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9321042df" alt="在这里插入图片描述"></p><p>通过<code>GET</code>命令就可以查看到索引的信息，后面的目标准确到索引就查看索引信息，准确到文档就查看文档信息。</p><h3 id="修改文档信息"><a href="#修改文档信息" class="headerlink" title="修改文档信息"></a>修改文档信息</h3><p>修改文档信息有两种方式，第一种是通过PUT命令在原来的文档上添加数据进行覆盖，第二种是通过POST进行修改。</p><p>1）PUT覆盖修改</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f98191b029" alt="在这里插入图片描述"></p><p>使用PUT进行修改有一个弊端，就是他会将所有的数据都进行覆盖，如果你修改的字段有缺漏，则缺漏的部分会被覆盖为空，造成数据的丢失。</p><p>2)POST方式修改</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9450e430e" alt="img"></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除索引信息通过DELETE命令来完成。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f946619a01" alt="在这里插入图片描述"></p><p>DELETE操作和GET操作一样，后面的目标精确到文档就删除文档信息，精确到索引就删除索引信息。</p><h2 id="复杂查询操作"><a href="#复杂查询操作" class="headerlink" title="复杂查询操作"></a>复杂查询操作</h2><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名&#x2F;类型名&#x2F;_search?q&#x3D;字段名:字段值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9488dfd73" alt="在这里插入图片描述">关于基础条件查询语句的解析： 其中_search后面的q的意思是query，在语法中是一个对象，完整的写法应该如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9590bc229" alt="在这里插入图片描述"></p><p>如上图所示，我们可以在query对象中设置很多的参数来完成各种情况下的查询方式。查询的结果中包含一个hits对象，这个对象的参数就包含了所有具体的查询结果。</p><h3 id="条件查询-只显示某几个字段"><a href="#条件查询-只显示某几个字段" class="headerlink" title="条件查询_只显示某几个字段"></a>条件查询_只显示某几个字段</h3><p>默认情况下的条件查询会将文档的所有字段都查询出来，但是我们可以通过一个_source属性去指定想要查询出来的字段：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f95acc765b" alt="在这里插入图片描述"></p><p>由上图可以看到，当我们指定了只查询”name”字段的时候，后面查询出来的信息中就只包含了”name”字段信息。</p><h3 id="根据指定字段排序查询"><a href="#根据指定字段排序查询" class="headerlink" title="根据指定字段排序查询"></a>根据指定字段排序查询</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9674eeaa8" alt="在这里插入图片描述"></p><p>如上图所示，按照age字段进行降序排列，因为我们自定义了按照某种规则进行排序吗，所以之前的排序规则分数就会为Null。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9682f7fbd" alt="在这里插入图片描述"></p><p>我们可以通过设置”from”和”size”参数来设置分页查询的相关信息。</p><h3 id="布尔值查询"><a href="#布尔值查询" class="headerlink" title="布尔值查询"></a>布尔值查询</h3><p>通过布尔值查询的方式我们可以实现类似于数据库的多条件查询：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9686da4ea" alt="在这里插入图片描述"></p><p>例如通过这个must指令就可以实现多条件查询，在上图中，只有同时满足name中包含张三，并且年龄为18的数据才会被查询出。</p><p>简单的来说满足这两个条件就会返回true的布尔值然后被查询出来，所以被叫做布尔值查询，相当于sql语句中的where and条件语句。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f97b3bba44" alt="在这里插入图片描述"></p><p>而should命令则表示后方的两个条件只需要满足其中之一即可，就类似于sql语句中的where or条件语句。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9846bacda" alt="在这里插入图片描述"></p><p>同理，must_not表示查询出不满足条件的数据，例如上图查询出年龄不为18的信息，相当于sql中的not条件语句。</p><h3 id="过滤查询操作"><a href="#过滤查询操作" class="headerlink" title="过滤查询操作"></a>过滤查询操作</h3><p>在满足多种条件查询的同时，es也支持我们对查询的数据进行进一步的筛选过滤。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f987f687fc" alt="在这里插入图片描述"></p><p>通过上图的配置可以实现按照年龄大小进行进一步过滤的操作，gte是大于等于操作，lte是小于等于操作，gt只表示大于操作，lt只表示小于操作。</p><p>同时，也可以同时设置大于和小于来进行值的区间搜索操作，相当于sql中的between and条件。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9a430a6c0" alt="在这里插入图片描述"></p><h3 id="匹配多个条件查询"><a href="#匹配多个条件查询" class="headerlink" title="匹配多个条件查询"></a>匹配多个条件查询</h3><p>匹配多个条件查询就有点类似于sql中的in关键字。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9a77edf10" alt="在这里插入图片描述"></p><p>如图所示，tags是兴趣标签，在数据中是以数组的形式存在的，也就是说有多个值，通过这种方式就可以进行多个值的随意匹配。</p><h3 id="精确匹配term"><a href="#精确匹配term" class="headerlink" title="精确匹配term"></a>精确匹配term</h3><p><strong>term精确匹配和match的不同：</strong></p><p>term会将条件依据倒排索引进行精确匹配，而match则会将查询条件进行分词然后再匹配。简单的来说，match会产生类似与模糊查询的效果，而term不会，条件匹配不上即使数据包含查询条件也不会被查询出来。</p><p><strong>关于text和keyword类型：</strong></p><p>text类型和keyword的不同之处在于，text会被分词器进行分词，而keyword不会被分词器分词。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9ac0d8885" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9b6e25f4f" alt="在这里插入图片描述"></p><h3 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h3><p>ElasticSearch同时也支持高亮查询，他会将查询结果中的查询条件关键字进行自动的高亮显示。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9be9b79bf" alt="在这里插入图片描述"></p><h2 id="SpringBoot集成ElasticSearch"><a href="#SpringBoot集成ElasticSearch" class="headerlink" title="SpringBoot集成ElasticSearch"></a>SpringBoot集成ElasticSearch</h2><p>此次SpringBoot集成ElasticSearch采用SpringBoot脚手架来进行学习。</p><p><strong>1、勾选引入ElasticSearch依赖</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9d015dd3a" alt="在这里插入图片描述"></p><p>勾选之后需要注意的是，我们在此使用的SpringBoot版本为2.3.1，此版本的ES客户端并不是本地安装的7.6.1版本：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120210008727.png" alt="image-20201120210008727"></p><p>因此，我们需要在pom.xml进行ES客户端版本的自定义配置：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120210127576.png" alt="image-20201120210127576"></p><p>版本依赖导入完成！</p><p><strong>2、书写配置类将ES对象注入到Spring容器之中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/16 21:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//ES集群的相关信息，如果有多个就配置多个</span></span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，SpringBoot集成ElasticSearch就完成了。</p><h2 id="关于java操作ES索引的API"><a href="#关于java操作ES索引的API" class="headerlink" title="关于java操作ES索引的API"></a>关于java操作ES索引的API</h2><p>关于java API的学习都会在测试类中进行完成。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parse</span><span class="params">(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.parseContent(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span>String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span><span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span><span class="keyword">int</span> pageSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.searchPageHighlightBuilder(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建成功!</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9df034b64" alt="在这里插入图片描述"></p><h3 id="判断索引是否存在"><a href="#判断索引是否存在" class="headerlink" title="判断索引是否存在"></a>判断索引是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据放入es搜索中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">parseContent</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Content&gt; contents = <span class="keyword">new</span> HtmlParseUtil().parseJD(keywords);</span><br><span class="line">    <span class="comment">// 把查询到的数据放入es中</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contents.size(); i++) &#123;</span><br><span class="line">        bulkRequest.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;jd_goods&quot;</span>)</span><br><span class="line">                        .source(JSON.toJSONString(contents.get(i)),XContentType.JSON));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> !bulk.hasFailures();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9e05854a9" alt="在这里插入图片描述"></p><h3 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试删除索引</span><br><span class="line">    @Test</span><br><span class="line">    void deleteIndex() throws IOException &#123;</span><br><span class="line">        DeleteIndexRequest java_index &#x3D; new DeleteIndexRequest(&quot;java_index&quot;);</span><br><span class="line">        AcknowledgedResponse delete &#x3D; restHighLevelClient.indices().delete(java_index, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(delete.isAcknowledged());  &#x2F;&#x2F;获取删除成功与否的提示信息</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码效果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9e8afbaad" alt="在这里插入图片描述"></p><p>删除成功！</p><h2 id="关于java操作ES文档的API"><a href="#关于java操作ES文档的API" class="headerlink" title="关于java操作ES文档的API"></a>关于java操作ES文档的API</h2><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试添加文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//创建请求</span></span><br><span class="line">        IndexRequest java_index = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;java_index&quot;</span>);</span><br><span class="line">        <span class="comment">//填充规则</span></span><br><span class="line">        java_index.id(<span class="string">&quot;1&quot;</span>);  <span class="comment">//文档编号</span></span><br><span class="line">        <span class="comment">//将对象放入请求中</span></span><br><span class="line">        java_index.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">        <span class="comment">//客户端发送请求，接收响应结果</span></span><br><span class="line">        IndexResponse index = restHighLevelClient.index(java_index, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//打印响应结果</span></span><br><span class="line">        System.out.println(index.toString());  <span class="comment">//查看返回的具体json信息</span></span><br><span class="line">        System.out.println(index.status());  <span class="comment">//查看操作的状态</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因为ES只支持json格式的数据流通，所以在将对象放入请求的过程中需要将对象序列化为josn字符串，在此需要阿里巴巴的fastjson支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看添加文档结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9ffc955bd" alt="在这里插入图片描述"></p><p>添加成功！</p><h3 id="判断文档是否存在"><a href="#判断文档是否存在" class="headerlink" title="判断文档是否存在"></a>判断文档是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试判断文档是否存在</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExistDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">GetRequest java_index = <span class="keyword">new</span> GetRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> exists = restHighLevelClient.exists(java_index, RequestOptions.DEFAULT);</span><br><span class="line">System.out.println(exists);  <span class="comment">//返回布尔值表示是否存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa092d0cdf" alt="在这里插入图片描述"></p><p>一号文档存在！</p><h3 id="获取文档信息"><a href="#获取文档信息" class="headerlink" title="获取文档信息"></a>获取文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试获取文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetRequest java_index = <span class="keyword">new</span> GetRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    GetResponse getResponse = restHighLevelClient.get(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(getResponse.getSourceAsString());  <span class="comment">//打印文档的内容</span></span><br><span class="line">    System.out.println(getResponse);  <span class="comment">//getResponse对象就包含ES的所有查询信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码效果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa03154a2d" alt="在这里插入图片描述"></p><h3 id="修改文档记录"><a href="#修改文档记录" class="headerlink" title="修改文档记录"></a>修改文档记录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试修改文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UpdateRequest java_index = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;法外狂徒张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    java_index.doc(JSON.toJSONString(user),XContentType.JSON);</span><br><span class="line">    UpdateResponse update = restHighLevelClient.update(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(update.status());  <span class="comment">//查看更新状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa22459d38" alt="在这里插入图片描述"></p><p>修改成功！</p><h3 id="删除文档信息"><a href="#删除文档信息" class="headerlink" title="删除文档信息"></a>删除文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteRequest java_index = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    DeleteResponse delete = restHighLevelClient.delete(java_index,RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.status());  <span class="comment">//查看删除状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa2230fc5d" alt="在这里插入图片描述"></p><p>删除成功！</p><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>ES同时也支持批量增删改的操作，在此只演示批量添加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试批量添加文档下信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bulkDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建批量操作对象</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    ArrayList&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三1&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三2&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三3&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三4&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三5&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        bulkRequest.add(</span><br><span class="line">                <span class="keyword">new</span> IndexRequest(<span class="string">&quot;java_index&quot;</span>).id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>))</span><br><span class="line">                        .source(JSON.toJSONString(list.get(i)),XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(bulk.hasFailures());  <span class="comment">//查看状态，是否失败，返回false代表成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa23f07bfa" alt="在这里插入图片描述"></p><h3 id="查询文档信息"><a href="#查询文档信息" class="headerlink" title="查询文档信息"></a>查询文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试查询文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建请求对象</span></span><br><span class="line">    SearchRequest java_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;java_index&quot;</span>);</span><br><span class="line">    <span class="comment">//构造搜索条件</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//使用工具类构造搜索信息</span></span><br><span class="line">    MatchQueryBuilder query = QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三1&quot;</span>);</span><br><span class="line">    searchSourceBuilder.query(query);</span><br><span class="line">    java_index.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    SearchResponse search = restHighLevelClient.search(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(JSON.toJSONString(search.getHits()));  <span class="comment">//Hits对象就包含查询的各种信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa2895e40e" alt="在这里插入图片描述"></p><p>Hits对象中包含的是所有的查询结果信息，我们可以通过遍历想要的参数获得具体的信息。</p><p>对于复杂查询的各种操作都可以在searchSourceBuilder对象的方法中找到对应的方法：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa23f5904f" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa37d4fde0" alt="在这里插入图片描述"></p><h2 id="ElasticSeatch项目实战：京东搜索"><a href="#ElasticSeatch项目实战：京东搜索" class="headerlink" title="ElasticSeatch项目实战：京东搜索"></a>ElasticSeatch项目实战：京东搜索</h2><p>此次项目实战采用java爬虫爬取京东的数据放在es数据源中，然后通过页面来模拟京东搜索。</p><h3 id="1、项目搭建"><a href="#1、项目搭建" class="headerlink" title="1、项目搭建"></a>1、项目搭建</h3><p><strong>创建项目并引入相关pom依赖</strong></p><p>相关pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xsh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>es_jdsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>es_jdsearch<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>yml相关配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">  <span class="comment">#关闭thymeleaf缓存</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>引入静态资源</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211525026.png" alt="image-20201120211525026"></p><p><strong>编写控制器访问index.html页面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xsh.es_jdsearch.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>访问页面</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa567c20bf" alt="在这里插入图片描述"></p><h3 id="2、使用jsoup爬取京东相关的数据"><a href="#2、使用jsoup爬取京东相关的数据" class="headerlink" title="2、使用jsoup爬取京东相关的数据"></a>2、使用jsoup爬取京东相关的数据</h3><p><strong>引入jsoup依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编写工具类解析网页爬取数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhangaibin.pojo.Content;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/19 15:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlParseUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HtmlParseUtil().parseJD(<span class="string">&quot;大连理工&quot;</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Content&gt; <span class="title">parseJD</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求</span></span><br><span class="line">        <span class="comment">// String url = &quot;https://search.jd.com/Search?keyword=&quot; + keywords+&quot;&amp;enc=utf-8&quot;;</span></span><br><span class="line">        <span class="comment">// 指定编码集，防止中文乱码</span></span><br><span class="line">        Document document = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            document = Jsoup.parse(<span class="keyword">new</span> URL(<span class="string">&quot;https://search.jd.com/Search?keyword=&quot;</span> + keywords + <span class="string">&quot;&amp;enc=utf-8&quot;</span>), <span class="number">30000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---JDSearchHtmlParser.parse()失败---&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析网页（jsoup返回的document就是浏览器返回的Document对象）</span></span><br><span class="line">        <span class="comment">//Document document = Jsoup.parse(new URL(url), 30000);</span></span><br><span class="line">        <span class="comment">// 所有在js中的方法，都可以使用</span></span><br><span class="line">        Element element = document.getElementById(<span class="string">&quot;J_goodsList&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有的li元素</span></span><br><span class="line">        Elements elements = element.getElementsByTag(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        List&lt;Content&gt; goodList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取元素内容,每个li标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element el : elements) &#123;</span><br><span class="line">            String img = el.getElementsByTag(<span class="string">&quot;img&quot;</span>).eq(<span class="number">0</span>).attr(<span class="string">&quot;data-lazy-img&quot;</span>);</span><br><span class="line">            String price = el.getElementsByClass(<span class="string">&quot;p-price&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            String title = el.getElementsByClass(<span class="string">&quot;p-name&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            Content content = <span class="keyword">new</span> Content();</span><br><span class="line">            content.setImg(img);</span><br><span class="line">            content.setPrice(price);</span><br><span class="line">            content.setTitle(title);</span><br><span class="line">            goodList.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：该类可以通过jsoup爬取页面上的相关信息，在爬取图片的时候狂神使用的是source-data-lazy-img属性，但是我在写的时候这个属性是无效的，还是使用的src属性才获取到的图片地址。</p><h3 id="3、书写接口使用工具类将解析到的数据插入到ElasticSearch中"><a href="#3、书写接口使用工具类将解析到的数据插入到ElasticSearch中" class="headerlink" title="3、书写接口使用工具类将解析到的数据插入到ElasticSearch中"></a>3、书写接口使用工具类将解析到的数据插入到ElasticSearch中</h3><p><strong>创建jd_goods索引</strong></p><p>在此通过图形化界面快速创建索引：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211807101.png" alt="image-20201120211807101"></p><p><strong>注入ElasticSearch客户端对象</strong></p><p>要实现对ES数据进行操作，首先肯定要通过配置类来注入客户端对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/16 21:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//ES集群的相关信息，如果有多个就配置多个</span></span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Controller代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhangaibin.service.ContentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/19 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parse</span><span class="params">(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.parseContent(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span>String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span><span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span><span class="keyword">int</span> pageSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.searchPageHighlightBuilder(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据放入es搜索中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">parseContent</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Content&gt; contents = <span class="keyword">new</span> HtmlParseUtil().parseJD(keywords);</span><br><span class="line">    <span class="comment">// 把查询到的数据放入es中</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contents.size(); i++) &#123;</span><br><span class="line">        bulkRequest.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;jd_goods&quot;</span>)</span><br><span class="line">        .source(JSON.toJSONString(contents.get(i)),XContentType.JSON));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> !bulk.hasFailures();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问接口就可以调用jsoup工具类将解析到的网页数据插入到es索引中，结果如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211945140.png" alt="image-20201120211945140"></p><h3 id="4、书写接口分页带条件查询信息"><a href="#4、书写接口分页带条件查询信息" class="headerlink" title="4、书写接口分页带条件查询信息"></a>4、书写接口分页带条件查询信息</h3><p>数据有了之后，就是做数据展示，在此接口接收查询的关键字和分页的信息进行分页并带条件的查询：</p><p><strong>Controller接口代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询数据接口</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span> <span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span> <span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> jdService.search(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="number">0</span>)&#123;</span><br><span class="line">            pageNo=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建搜索对象</span></span><br><span class="line">        SearchRequest jd_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_goods&quot;</span>);</span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置分页信息</span></span><br><span class="line">        sourceBuilder.from(pageNo);</span><br><span class="line">        sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        TermQueryBuilder query = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">        <span class="comment">//封装搜索条件</span></span><br><span class="line">        sourceBuilder.query(query);</span><br><span class="line">        <span class="comment">//封装搜索对象</span></span><br><span class="line">        jd_index.source(sourceBuilder);</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        SearchResponse response = restHighLevelClient.search(jd_index, RequestOptions.DEFAULT);</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            list.add(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5、采用Vue-axios进行前后端分离数据展示"><a href="#5、采用Vue-axios进行前后端分离数据展示" class="headerlink" title="5、采用Vue+axios进行前后端分离数据展示"></a>5、采用Vue+axios进行前后端分离数据展示</h3><p><strong>使用npm下载vue.js和axios.js的相关文件</strong></p><p>首先我们随便创建一个英文名称的文件夹，在其中使用cmd命令行<code>npm init</code>来初始化，使用<code>npm install vue</code>和<code>npm install axios</code>来下载依赖。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa70f8d7eb" alt="在这里插入图片描述"></p><p>下载结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa69d12f5a" alt="在这里插入图片描述"></p><p>在项目中引入vue.min.js和axios.min.js文件：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa84b0d7b6" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa79343ca1" alt="在这里插入图片描述"></p><p>修改页面信息，动态绑定搜索框的数据和搜索按钮的单击事件，实现单击搜索按钮就发送请求进行ES库的查询，并且使用v-for将查询结果进行遍历显示，以下仅展示vue对象的相关代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--前端使用vue，实现前后端分离--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            keyword: <span class="string">&#x27;&#x27;</span>,<span class="comment">//搜索的关键字</span></span></span><br><span class="line"><span class="javascript">            results: []<span class="comment">//搜索的结果</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">searchKey</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> keyword = <span class="built_in">this</span>.keyword;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(keyword);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 对接后端的接口</span></span></span><br><span class="line"><span class="javascript">                axios.get(<span class="string">&#x27;search/&#x27;</span>+keyword+<span class="string">&quot;/1/20&quot;</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//对接后端代码</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.results = response.data;<span class="comment">// 绑定数据</span></span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>查看页面查询效果</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120212100093.png" alt="image-20201120212100093"></p><p>以上，我们就通过代码完成了es数据库的查询操作，可以用来做页面的搜索功能。</p><p>但是如上图所示，我们不仅实现了搜索功能，还实现了关键字结果的高亮，这是因为接口的不同：</p><h3 id="6、分页待条件且关键字高亮查询"><a href="#6、分页待条件且关键字高亮查询" class="headerlink" title="6、分页待条件且关键字高亮查询"></a>6、分页待条件且关键字高亮查询</h3><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高亮分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; searchHighLight(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="number">0</span>)&#123;</span><br><span class="line">            pageNo=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建搜索对象</span></span><br><span class="line">        SearchRequest jd_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_index&quot;</span>);</span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置分页信息</span></span><br><span class="line">        sourceBuilder.from(pageNo);</span><br><span class="line">        sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装高亮显示条件</span></span><br><span class="line">        HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">        highlightBuilder.field(<span class="string">&quot;title&quot;</span>);  <span class="comment">//对哪个字段进行高亮</span></span><br><span class="line">        highlightBuilder.preTags(<span class="string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>);  <span class="comment">//设置高亮前缀</span></span><br><span class="line">        highlightBuilder.postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);  <span class="comment">//高亮后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        TermQueryBuilder query = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">        <span class="comment">//封装搜索条件</span></span><br><span class="line">        sourceBuilder.query(query);</span><br><span class="line">        sourceBuilder.highlighter(highlightBuilder);  <span class="comment">//封装高亮搜索条件</span></span><br><span class="line">        <span class="comment">//封装搜索对象</span></span><br><span class="line">        jd_index.source(sourceBuilder);</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        SearchResponse response = restHighLevelClient.search(jd_index, RequestOptions.DEFAULT);</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">            HighlightField title = highlightFields.get(<span class="string">&quot;title&quot;</span>);  <span class="comment">//高亮之后的title</span></span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();  <span class="comment">//未高亮之前的结果集</span></span><br><span class="line">            <span class="comment">//接下来就是将高亮的title与结果集中未高亮的title进行替换</span></span><br><span class="line">            <span class="keyword">if</span>(title!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Text[] fragments = title.fragments();</span><br><span class="line">                String newTitle=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (Text text : fragments) &#123;</span><br><span class="line">                    newTitle+=text;</span><br><span class="line">                &#125;</span><br><span class="line">                sourceAsMap.put(<span class="string">&quot;title&quot;</span>,newTitle);  <span class="comment">//替换掉未高亮的title</span></span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sourceAsMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7-运行"><a href="#7-运行" class="headerlink" title="7. 运行"></a>7. 运行</h3><ol><li>启动ElasticSear</li><li>启动ElasticSearch-head</li><li>运行主启动类EsJdApplication.class</li><li>浏览器输入<a href="http://localhost:9090/parse/java">http://localhost:9090/parse/java</a> (要爬取的书籍)(将爬取结果放入es)</li><li><a href="http://localhost:9090/">http://localhost:9090</a> ，在搜索栏中输入java，就得到结果了，不过要先执行第4步，在es中有相应的东西才能有结果，目前中文不支持(即可以放进es，但得不到搜索结果)</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV17a4y1x7zq">狂神说</a> 他公众号有相应资源<br>         <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">nodejs安装</a><br>         <a href="https://blog.csdn.net/wjnf012/article/details/80422313">cnpm安装</a><br>         <a href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&O=D">ElasticSearch</a><br>         <a href="https://mirrors.huaweicloud.com/logstash/?C=N&O=D">logstash</a><br>         <a href="https://mirrors.huaweicloud.com/kibana/?C=N&O=D">kibana</a></p><p><a href="https://juejin.cn/post/6844904168835006477#heading-46">小白必看_从入门到实战的ElasticSearch7.6.1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt; ，简称为es，是一个开源的、高拓展的分布式全文检索引擎，它可以近乎实时的存储、</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="ElasticSearch" scheme="https://leslieaibin.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>100的阶乘是0？</title>
    <link href="https://leslieaibin.github.io/2020/11/18/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/100%E9%98%B6%E4%B9%98/"/>
    <id>https://leslieaibin.github.io/2020/11/18/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/100%E9%98%B6%E4%B9%98/</id>
    <published>2020-11-17T16:15:42.000Z</published>
    <updated>2020-11-17T16:26:26.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="100的阶乘的0？"><a href="#100的阶乘的0？" class="headerlink" title="100的阶乘的0？"></a>100的阶乘的0？</h2><h3 id="有趣的疑问"><a href="#有趣的疑问" class="headerlink" title="有趣的疑问"></a>有趣的疑问</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/86735519.jpg" alt="img"></p><p>超出数据类型取值范围 会输出什么数字：</p><p> 数据类型：int</p><p> 取值范围：-2^31–2^31-1</p><p> 测试1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">34</span>;i++)&#123;</span><br><span class="line">i3=i3*<span class="number">2</span>;</span><br><span class="line">System.out.println(i3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">512</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">2048</span></span><br><span class="line"><span class="number">4096</span></span><br><span class="line"><span class="number">8192</span></span><br><span class="line"><span class="number">16384</span></span><br><span class="line"><span class="number">32768</span></span><br><span class="line"><span class="number">65536</span></span><br><span class="line"><span class="number">131072</span></span><br><span class="line"><span class="number">262144</span></span><br><span class="line"><span class="number">524288</span></span><br><span class="line"><span class="number">1048576</span></span><br><span class="line"><span class="number">2097152</span></span><br><span class="line"><span class="number">4194304</span></span><br><span class="line"><span class="number">8388608</span></span><br><span class="line"><span class="number">16777216</span></span><br><span class="line"><span class="number">33554432</span></span><br><span class="line"><span class="number">67108864</span></span><br><span class="line"><span class="number">134217728</span></span><br><span class="line"><span class="number">268435456</span></span><br><span class="line"><span class="number">536870912</span></span><br><span class="line"><span class="number">1073741824</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>为了更详细的看出其变化，将在临界值前后输出更多值，测试2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i3=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">31</span>;i++)&#123;</span><br><span class="line">i3=i3*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=(i3-<span class="number">3</span>)*<span class="number">2</span>;k&lt;<span class="number">15</span>;j++,k++)&#123;</span><br><span class="line">System.out.println(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">测试结果</span><br><span class="line"></span><br><span class="line"><span class="number">2147483642</span></span><br><span class="line"><span class="number">2147483643</span></span><br><span class="line"><span class="number">2147483644</span></span><br><span class="line"><span class="number">2147483645</span></span><br><span class="line"><span class="number">2147483646</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line">-<span class="number">2147483647</span></span><br><span class="line">-<span class="number">2147483646</span></span><br><span class="line">-<span class="number">2147483645</span></span><br><span class="line">-<span class="number">2147483644</span></span><br><span class="line">-<span class="number">2147483643</span></span><br><span class="line">-<span class="number">2147483642</span></span><br><span class="line">-<span class="number">2147483641</span></span><br><span class="line">-<span class="number">2147483640</span></span><br></pre></td></tr></table></figure><p>分析：当前int型数据达到最大值2147483647时，是第一位为0，其余31位为全1，01111111111111111111111111111111；再加1则进1，第一位为1，其余全零，10000000000000000000000000000000。系统把第一位判断为负号，而且同时代表值，所以是-2147483648，当再继续相加时，系统会把之前的数当做负数，再加上正数1，则为-2147483647，10000000000000000000000000000001，后面以此类推。结合测试1，当为10000000000000000000000000000000时，即-2147483648，再乘以2将溢出，溢出位娶不到，全0，即为00000000000000000000000000000000，此时为0（-2147483648再乘以2为什么是0的理解） . 再乘以2依然为0.</p><p>为了解决这样大数的问题 引入了BigInteger 和 BigDecimal</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi &#x3D; new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">System.out.println(bi.pow(5)); &#x2F;&#x2F; 2867971860299718107233761438093672048294900000</span><br></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 &#x3D; new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">BigInteger i2 &#x3D; new BigInteger(&quot;12345678901234567890&quot;);</span><br><span class="line">BigInteger sum &#x3D; i1.add(i2); &#x2F;&#x2F; 12345678902469135780</span><br></pre></td></tr></table></figure><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i &#x3D; new BigInteger(&quot;123456789000&quot;);</span><br><span class="line">System.out.println(i.longValue()); &#x2F;&#x2F; 123456789000</span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); &#x2F;&#x2F; java.lang.ArithmeticException: BigInteger out of long range</span><br></pre></td></tr></table></figure><p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure><p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比较BigDecimal</strong></p><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 &#x3D; new BigDecimal(&quot;123.456&quot;);</span><br><span class="line">BigDecimal d2 &#x3D; new BigDecimal(&quot;123.45600&quot;);</span><br><span class="line">System.out.println(d1.equals(d2)); &#x2F;&#x2F; false,因为scale不同</span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); &#x2F;&#x2F; true,因为d2去除尾部0后scale变为2</span><br><span class="line">System.out.println(d1.compareTo(d2)); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p> 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h3 id="100的阶乘实现"><a href="#100的阶乘实现" class="headerlink" title="100的阶乘实现"></a>100的阶乘实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JieCheng</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法int</span></span><br><span class="line">        jichengint();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法biginteger</span></span><br><span class="line">        jiechengbiginteger();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法bigdecimal</span></span><br><span class="line">        jiechengbigdecimal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jichengint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘Int:  &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiechengbiginteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger result = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1&quot;</span>);<span class="comment">//为result赋初始值，为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            BigInteger num = <span class="keyword">new</span> BigInteger(String.valueOf(i));</span><br><span class="line">            result = result.multiply(num);<span class="comment">//调用自乘方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘BigInTeger  &quot;</span>+result);<span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;位数： &quot;</span>+String.valueOf(result).length());<span class="comment">//输出长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiechengbigdecimal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//求一百的阶乘之和</span></span><br><span class="line">        <span class="comment">//只能用math里边的BigDecimal来存储数据</span></span><br><span class="line">        <span class="comment">//定义变量保存阶乘的和</span></span><br><span class="line">        BigDecimal result = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>);<span class="comment">//为result赋初始值，为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            BigDecimal num = <span class="keyword">new</span> BigDecimal(String.valueOf(i));</span><br><span class="line">            result = result.multiply(num);<span class="comment">//调用自乘方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘BigDecimal  &quot;</span>+result);<span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;位数： &quot;</span>+String.valueOf(result).length());<span class="comment">//输出长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">阶乘Int:  <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">阶乘BigInTeger <span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br><span class="line">位数： <span class="number">158</span></span><br><span class="line">    </span><br><span class="line">阶乘BigDecimal  <span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br><span class="line">位数： <span class="number">158</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;100的阶乘的0？&quot;&gt;&lt;a href=&quot;#100的阶乘的0？&quot; class=&quot;headerlink&quot; title=&quot;100的阶乘的0？&quot;&gt;&lt;/a&gt;100的阶乘的0？&lt;/h2&gt;&lt;h3 id=&quot;有趣的疑问&quot;&gt;&lt;a href=&quot;#有趣的疑问&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM(三） —— 类文件结构</title>
    <link href="https://leslieaibin.github.io/2020/11/15/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://leslieaibin.github.io/2020/11/15/Java/JVM/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2020-11-14T16:15:42.000Z</published>
    <updated>2020-11-15T15:25:16.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。<code>.class</code>文件的二进制格式可以使用 <a href="https://www.x-ways.net/winhex/">WinHex</a> 查看。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115230551749.png" alt="image-20201115230551749"></p><p><strong>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</strong></p><h2 id="Class-文件结构总结"><a href="#Class-文件结构总结" class="headerlink" title="Class 文件结构总结"></a>Class 文件结构总结</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><p><strong>Class文件字节码结构组织示意图</strong> （之前在网上保存的，非常不错，原出处不明）：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115230948289.png" alt="image-20201115230948289"></p><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>每个 Class 文件的头四个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p><p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p><h3 id="Class-文件版本"><a href="#Class-文件版本" class="headerlink" title="Class 文件版本"></a>Class 文件版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><table><thead><tr><th>类型</th><th>标志（tag）</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整形字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>５</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>６</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>７</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>８</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>９</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MothodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v  class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p><p>类访问和属性修饰符:</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231234370.png" alt="image-20201115231234370"></p><p>我们定义了一个 Employee 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231213318.png" alt="image-20201115231213318"></p><h3 id="当前类索引-父类索引与接口索引集合"><a href="#当前类索引-父类索引与接口索引集合" class="headerlink" title="当前类索引,父类索引与接口索引集合"></a>当前类索引,父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p><p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值:</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231147414.png" alt="image-20201115231147414"></p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201115231123298.png" alt="image-20201115231123298"></p><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 Java 中，JVM 可以理解的代码就叫做&lt;code&gt;字节码&lt;/code&gt;（即扩展名为 &lt;code&gt;.class&lt;/code&gt; 的文件）</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM(二） —— 垃圾回收</title>
    <link href="https://leslieaibin.github.io/2020/11/13/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://leslieaibin.github.io/2020/11/13/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2020-11-12T16:15:42.000Z</published>
    <updated>2020-11-15T15:13:51.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111225928785.png" alt="image-20201111225928785"></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="JVM内存分配与回收"><a href="#JVM内存分配与回收" class="headerlink" title="JVM内存分配与回收"></a>JVM内存分配与回收</h2><p>Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java自动内存管理最核心的功能是堆内存中对象的分配与回收。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被称作为GC堆（Garbage Collected Heap）. 从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：</p><ul><li>新生代： Eden空间、From Survivor、To Survivor空间</li><li>老年代：Old Memory</li></ul><p><strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111231314990.png" alt="image-20201111231314990"></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。</p><p><strong>动态年龄计算的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">size_t desired_survivor_size = (size_t)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">size_t total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"> total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"> <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line"> age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111232843231.png" alt="image-20201111232843231"></p><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中Eden区分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] alocation1,alloction2;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方式运行：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111234604025.png" alt="image-20201111234604025"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111234626646.png" alt="image-20201111234626646"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111234844467.png" alt="image-20201111234844467"></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，永久代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201111235001934.png" alt="image-20201111235001934"></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">        allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）</p><p>原因：</p><p>为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><p><strong>内存分配担保机制：</strong> 当在新生代无法分配内存的时候，把新生代的对象转移到老生代，然后把新生代，然后把新对象放入腾空的新生代。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"> total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"> <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line"> age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure></blockquote><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。</strong> 如果你去Oracle的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.</strong></p><h3 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h3><p>针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="对象已经死亡？"><a href="#对象已经死亡？" class="headerlink" title="对象已经死亡？"></a>对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201112232337258.png" alt="image-20201112232337258"></p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。所谓对象之间的像话引用，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc;</span><br><span class="line">        ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201112233246468.png" alt="image-20201112233246468"></p><p>可作为GC Roots的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="不可达的对象并非“非死不可”"><a href="#不可达的对象并非“非死不可”" class="headerlink" title="不可达的对象并非“非死不可”"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_24-%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B9%B6%E9%9D%9E%E9%9D%9E%E6%AD%BB%E4%B8%8D%E5%8F%AF">不可达的对象并非“非死不可”</a></h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title=" 如何判断一个常量是废弃常量？"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_25-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F%EF%BC%9F"> 如何判断一个常量是废弃常量？</a></h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><ul><li><p><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></p></li><li><p><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</p></li><li><p><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p></li></ul><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6?id=_26-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB">如何判断一个类是无用的类</a></h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（Mark-Sweep"><a href="#标记-清除算法（Mark-Sweep" class="headerlink" title="标记-清除算法（Mark-Sweep)"></a>标记-清除算法（Mark-Sweep)</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155330cfb489a9" alt="标记-清除算法"></p><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。</p><p><strong>优点：</strong>简单</p><p><strong>缺点：</strong></p><ul><li>效率问题 执行时间不稳定，如果Java堆中包含大量对象，某一次回收时无用的对象非常多，这时候会花费很多时间进行内存的清理</li><li>空间问题 标记清除后产生大量不连续的碎片  上图只是一个理想的删除过程，正好没有内存碎片产生，而实际上在内存中待清除的内存有可能不是连续的，导致会产生许多内存碎片，如果某个大对象无法找到一块连续的内存进行存放时，会误以为堆内存不足，提前触发<code>Full GC</code></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552725604fc95" alt="放入内存失败"></p><p>所以为了<strong>解决内存碎片问题</strong>，科学家们研制出了一种新的算法：标记-复制算法</p><h3 id="标记-复制算法（Mark-Copying）"><a href="#标记-复制算法（Mark-Copying）" class="headerlink" title="标记-复制算法（Mark-Copying）"></a>标记-复制算法（Mark-Copying）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1715531a50e73a3a" alt="标记-复制"></p><p>由上面的动图可以看出，标记-复制算法将原本的<strong>堆内存划分了两个区域</strong>，采用了“半区复制”算法，将一半的内存省出来，当发生垃圾收集行为时，将存活的对象复制到另外一半保留区域中<strong>连续存放</strong>。</p><p>标记-复制算法的优点是解决了<strong>大对象</strong>分配内存的<code>内存碎片问题</code>，也解决了标记-清除算法中大量垃圾对象导致的<code>清除效率问题</code>。</p><p>缺点也非常的明显，那就是<strong>可分配的内存空间少了整整一半</strong>，而且如果某次存活的对象较多，甚至<strong>全部存活</strong>，那么复制的效率将会非常低。</p><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）<img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1715532188455c17" alt="标记-整理"></h3><p>为了提升内存的利用率，科学家提出了标记-整理算法，该算法的起始过程和<code>标记-清除</code>算法相同，先标记处待回收对象的内存区域，但是在清除时不是对所有可回收对象清除，而是<strong>让所有存活对象往内存空间的一边移动</strong>，把存活对象边界外的内存直接清空掉。</p><p>标记-整理算法<strong>提高了内存的利用率</strong>、解决了<strong>大对象分配时的内存碎片问题</strong>，看似完美的垃圾收集算法，也有它的弊端。在移动存活对象的过程中，需要全程暂停用户程序的执行，被设计者称为“<strong>Stop The World</strong>”。</p><h3 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h3><p>新生代垃圾收集及内存分配</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1715531245ade622" alt="分代收集"></p><p>分代收集算法本质上<strong>标记-复制算法</strong>，它把堆内存中较大的一块区域作为<strong>新生代区域</strong>，新生代区域中分为一个Eden区域和两个Survivor区域，Eden和Survivor的比例默认是<strong>8:1</strong>，因为在Eden区域，绝大数对象都熬不过第一轮GC（98%），所以每个Survivor区域只需要10%的空间就足矣了，每一次触发<code>Minor GC</code>时，就会将Eden区和Survivor区存活的对象复制到另外一个Survivor区域中，然后清除掉被回收的对象，每次都依据这样的步骤进行垃圾收集。</p><p>不知道你有没有注意到每个对象有一个数字的标记，这个标记是<strong>对象的年龄</strong>，当对象到了<strong>15岁以后</strong>（默认情况）就会被晋升为<strong>老年代</strong></p><h4 id="晋升老年代"><a href="#晋升老年代" class="headerlink" title="晋升老年代"></a>晋升老年代</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171553164b071572" alt="晋升老年代"></p><p>如图所示，当对象在Survivor区存活了15次以后，就会晋升为老年代对象。</p><p>还有以下情况会晋升为老年代对象：</p><blockquote><p><strong>大对象</strong>。当对象所占连续内存非常大时，不会分配在Eden区，如果分配在Eden区，那么对象存活时产生的复制操作将导致效率大大降低。</p><p>如果在Survivor区，相同年龄的<strong>对象总大小</strong>大于<strong>Survivor区空间的一半</strong>时，也会将这些年龄相同的对象直接晋升到老年代，原因也是防止对象的复制操作导致的效率问题。</p></blockquote><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在对象无法分配到Eden区时，会触发一次<code>Minor GC</code>，JVM会首先检查<strong>老年代最大的可用连续空间</strong>是否大于<strong>新生代所有对象的总和</strong>，如果大于，那么这次<code>Minor GC</code>是安全的，如果<strong>不大于</strong>的话，JVM就需要判断<code>HandlePromotionFailure</code>是否允许空间分配担保。</p><p>如果允许担保，则证明老年代的连续可用内存空间大于历次晋升到老年代对象的平均大小，此时触发一次<code>Minor GC</code>，如果小于，那么证明老年代并没有把握放得下Survivor区有可能晋升的对象，此时发生一次<code>Full GC</code>。</p><h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><p>发生<code>GC</code>(MinorGC或者FullGC)时，都会将用户线程停顿并进行垃圾收集，在<code>Minor GC</code>中，<code>STW</code>的时间较短，只涉及<code>Eden</code>和<code>survivor</code>区域的对象清除和复制操作，而<code>Full GC</code>则是对整个堆内存进行垃圾收集，对象的扫描、标记和清除操作工作量大大提高，所以<code>Full GC</code>会导致用户线程停顿较长时间，如果频繁地发生<code>Full GC</code>，那么用户线程将无法正常执行。</p><p>或者通俗的理解：</p><blockquote><p>你给你妈妈打扫房间时，你是希望她坐在一旁静静等你扫完地再继续活动，还是想你一边扫地，她一边丢垃圾呢？</p></blockquote><h4 id="Safe-Points"><a href="#Safe-Points" class="headerlink" title="Safe Points"></a>Safe Points</h4><p>既然要<strong>用户线程停顿下来</strong>，那么要在什么地方停顿呢？JVM采用<strong>主动式中断方式</strong>告诉Java线程需要停顿了，JVM在特定的位置设置了这些安全点（Safe point），让线程可以在这些安全点主动挂起。</p><blockquote><p>方法调用、循环跳转、异常跳转</p></blockquote><p>这些安全点的特征是<strong>令程序有可能进行某一段长时间执行的特征</strong>。</p><p>在这些安全点上存有对象引用信息的<code>OopMap</code>数据结构，这种数据结构你可以理解为<code>HashMap</code>这种数据结构，它内部存储了什么位置上存储了对象引用信息，这些信息在类加载完成时就确定下来了。所以JVM在垃圾收集时不需要从一个个方法的<code>GC Roots</code>去扫描，从<code>OopMap</code>中可以快速准确地定位到这些<code>GC Roots</code>。</p><blockquote><p>如果用户线程本身处于停顿状态，例如阻塞（Blocked）、睡觉（Sleep），那么此时触发GC时，用户线程无法响应JVM的中断（我听不见你喊我，我睡着了~），用户线程无法主动地跑去安全点中断挂起，此时该怎么办呢？</p></blockquote><p>对于这种情况，必须引入<strong>Safe Region</strong>来解决。</p><h4 id="Safe-Region"><a href="#Safe-Region" class="headerlink" title="Safe Region"></a>Safe Region</h4><p>安全区域是指，用户线程进入某一段代码区域中时，引用关系不会发生变化，那么在这片代码区域的任何地方开始GC都不会受到影响。实现的方式是，用户线程进入安全区域时<strong>会标识自己已经进入安全区域</strong>，在JVM发起GC时<strong>不必理会那些已经标识为进入安全区域的线程</strong>，当用户线程<strong>需要离开安全区域时</strong>，会主动检查JVM是否已经完成了<strong>需要停顿线程的工作</strong>，如果已完成则可以离开，如果未完成则<strong>必须一直等待</strong>，直到JVM发送可以离开安全区域的信号为止。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集器分为新生代收集器与老年代收集器，各种不同的收集器之间如果符合标准则可以相互搭配使用。</p><h3 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552728c19c34d" alt="Serial/Serial Old收集器"></p><p>Serial收集器是一款单线程的垃圾收集器，“单线程”的<strong>意义</strong>不仅仅是指它只能用一条线程或占用一个处理器去完成垃圾收集操作，更重要的是它进行垃圾收集时，<strong>需要暂停其它所有线程，直到垃圾收集结束。</strong>它身为最古老的一款垃圾收集器，在当今依旧广泛受用，它有以下优点：</p><ul><li><p>对于内存受限的环境，它是所有收集器里额外内存消耗最小的</p></li><li><p>没有线程交互的开销，Serial收集器可以很好地专注于收集垃圾，把用户线程都停掉</p></li></ul><p>在用户桌面的应用场景和近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般不会特别大，收集几十兆、一两百兆的新生代（桌面应用的新生代甚至少于这个容量），垃圾收集完全可以控制在十几、几十毫秒，最多一百毫秒，这点停顿时间对用户来说是十分友好的。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272bc663994" alt="parNew收集器"></p><p>ParNew是一款<strong>并行新生代收集器</strong>，parNew收集器除了支持多线程并行收集以外，<strong>其余的行为与Serial收集器完全一致</strong>，包括收集算法、STW（Stop The World）、对象分配规则、回收策略等等。</p><p>parNew是不少运行在服务器端模式下的HotSpot虚拟机中首选的新生代收集器，其中一个与性能、功能无关但很重要的原因是：<strong>除了Serial收集器，只有ParNew能够与CMS收集器配合工作。</strong></p><p>CMS收集器与Parallel Scavenge收集器不能配合工作的一个原因是：Parallel Scavenge收集器内部并<strong>没有按照分代收集的框架进行设计垃圾回收</strong>，在之后的<strong>G1收集器</strong>也同样没有按照分代回收的框架设计。</p><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201113001642889.png" alt="image-20201113001642889"></p><p>Parallel Scavenge收集器同样是基于标记-复制算法实现的收集器，也是能够并行收集的一款新生代收集器，那它与ParNew收集器的<strong>差别在哪里呢？</strong></p><p>Parallel Scavenge收集器的特别之处在于它与其它收集器的关注点不一样，其它垃圾收集器关注如何<strong>最大限度地减少STW的时间</strong>，而Parrel Scavenge关注的是<strong>如何达到一个可控制的吞吐量（Throughput）</strong>，由于与吞吐量关系密切，所以也被称作“吞吐量优先收集器”。</p><p>Parallel Scavenge收集器可以实现<strong>自适应策略</strong>，这是另外一个与ParNew收集器的差别，可以通过指定<code>-XX:UseAdaptiveSizePolicy</code>参数，虚拟机就会根据系统当前的运行情况收集监控信息，并且<strong>自动调整系统的相关JVM参数以提供最高的吞吐量和最合适的停顿时间</strong>。</p><h3 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h3><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552728c19c34d" alt="Serial/Serial Old收集器"></p><p>使用<code>标记-整理</code>算法，是一个单线程收集器，它有另外两个用途：</p><blockquote><p>它作为CMS收集器发生失败后的后备预案，在CMS收集器并发收集发生Concurrent Mode Failure使用</p><p>作为Parallel Scavenge的老年代收集器</p></blockquote><p>这个时候就有疑惑了，<code>Parallel Scavenge</code>收集器不是没有按分代收集框架实现吗，为什么能够搭配<code>Serial Old</code>收集器使用</p><p>《深入理解Java虚拟机》：<code>Parallel Scavenge</code>收集器架构中含有<code>PS MarkSweep</code>收集器进行老年代收集，并非直接调用<code>Serial Old</code>收集器，但是<code>PS MarkSweep</code>与<code>Serial Old</code>的实现几乎是一样的，所以官方很多地方用<code>Serial Old</code>代替它进行讲解。</p><h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272c2e877cc" alt="Parallel Scavenge/Parallel Old"></p><p><code>Parallel Old</code>是<code>Parallel Scavenge</code>的老年代版本，支持多线程并发收集，基于<code>标记-整理</code>算法设计，自从JDK6以后，<code>Parallel Old</code>和<code>Parallel Scavenge</code>成为了最好的搭档，在<strong>注重吞吐量或者处理器资源比较紧缺</strong>的情况下，都可以采用这个组合。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器是基于获取<strong>最短回收停顿时间</strong>为目标的收集器，CMS收集器适合追求服务的响应速度的应用，例如基于浏览器的B/S系统的服务端上。</p><p>CMS是基于<code>标记-清除</code>算法设计的，它支持用户线程与GC线程并发执行，如下图所示</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272c6924308" alt="CMS收集器"></p><p>运作过程分为4个阶段：</p><blockquote><p>初始标记、并发标记、重新标记、并发清除</p></blockquote><p>初始标记的过程就是扫描GC Roots；</p><p>并发标记是扫描GC Roots链上所有的对象，此时会出现一些对象标记的变动，因为用户线程仍然在执行；</p><p>重新标记的过程是修正并发标记期间产生引用变动的那一部分对象的标记记录</p><p>并发清除是删除掉标记阶段判断已经死亡的对象，由于不用移动存活对象，此时也是可以并发执行的。</p><p>CMS收集器有三个缺点：</p><ol><li>对处理器资源特别敏感，由于是并发执行，所以CMS收集器工作时会占用一部分CPU资源而导致用户程序变慢，降低总吞吐量，建议具有四核处理器以上的服务器使用CMS收集器</li><li>CMS无法清除浮动垃圾，有可能出现<code>Concurrent Mode Failure</code>失败而导致另一次<code>STW</code>的<code>Full GC</code>产生。由于并发清理过程中用户线程与GC线程并发执行，就一定会产生新的垃圾对象，但是无法在本次GC中处理这些垃圾对象，不得不推迟到下一次GC中处理，这些垃圾对象就称为“浮动垃圾”，到JDK6的时候，CMS收集器启动阈值达到<code>92%</code>，也就是老年代占了<code>92%</code>的空间后会触发GC，但是如果剩余的内存<code>8%</code>不足以分配新对象时，就会发生“并发失败”，进而冻结用户线程，使用<code>Serial Old</code>收集器进行一次<code>Full GC</code>，所以触发CMS收集器的阈值还是根据实际场景来设置，参数为<code>-XX:CMSInitiatingOccu-pancyFraction</code>。</li><li>基于<code>标记-清除</code>算法会导致内存碎片不断增多，在分配大对象时有可能会提前触发一次<code>Full GC</code>。所以CMS提供两个参数可供开发者指定在每次<code>Full GC</code>时进行<strong>碎片整理</strong>，由于碎片整理需要移动对象，所以是无法并发收集的，<code>-XX:+UseCMSCompactAtFullCollection</code>(JDK9开始废弃)，<code>-XX:CMSFullGCsBeforeCompaction</code>(JDK9开始废弃，默认值是0，每次Full GC都进行碎片整理)。</li></ol><h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>这是一个在垃圾收集器技术发展历史上的里程碑式的成果，它取代了<code>Parallel Scavenge + Parallel Old</code>的组合，并取代了<code>CMS</code>，作为它们的继承者和替代者，G1到底有什么魔力呢？</p><blockquote><p>G1是一种“<strong>停顿时间模型</strong>”收集器，也就是说可以指定在时间片段为<code>M</code>毫秒时，垃圾收集所占用的时间不会超过<code>N</code>毫秒。</p><p>G1颠覆了之前的所有垃圾收集器的垃圾收集行为：要么新生代收集（Minor GC）、要么老年代收集（Major GC）、要么整堆收集（Full GC），而G1可以面向<strong>堆内存任何部分组成回收集</strong>（Collection Set , CSet），衡量标准不再是它属于哪个分代，而是<strong>哪块内存存放的垃圾数量较多</strong>，这就是G1所特有的Mixed GC模式。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/17155272c785ce97" alt="G1堆内存布局"></p><p>可以看到上图中每一个方块就是一个Region，每个Region可以存放1~32MB大小的对象，使用参数<code>-XX:G1HeapRegionSize</code>指定，Region中可以存放<code>Eden</code>/<code>Survivor</code>/<code>Humongous</code>/<code>Old</code>，G1中新生代和老年代并不是连续存放的，而是一个动态的集合。</p><p>注意在G1中专门用<code>Region</code>存放一个<code>Humongous</code>大对象，当对象容量大于Region的一半时就认为它是大对象，按照“大对象优先在老年代中分配”，<code>Humongous</code>也是老年代的一部分对象。</p><p>G1收集器将<code>Region</code>单元看出是最小的内存回收单元，每次发生GC时，G1收集器都会评估各个<code>Region</code>的<strong>价值大小</strong>，根据用户所指定的收集停顿时间来优先处理那些回收价值最大的<code>Region</code>，这也是<code>Garbage First</code>的由来。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/171552abf5ed5ea5" alt="G1收集器垃圾收集"></p><p>G1收集器的运作过程可以分为4个步骤：</p><blockquote><p><strong>初始标记</strong>：仅记录GC Roots对象，需要停顿用户线程，但时间很短，借助<code>Minor GC</code>同步完成。</p><p><strong>并发标记</strong>：从GC Roots开始遍历扫描所有的对象进行可达性分析，找出要回收的对象，由于是并发标记，有可能在扫描过程中出现引用变动。</p><p><strong>最终标记</strong>：将并发标记过程中出现变动的对象引用给纠正过来。</p><p><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据用户所希望的停顿时间来制定回收计划，选取任意多个Region区域进行回收，把回收的Region区域中的存活对象复制到空的Region区域中，然后清空掉原来的Region区域，涉及对象的移动，所以需要暂停用户线程，由多条GC线程并行完成。</p></blockquote><p>如何设置G1的停顿时间？<code>-XX:MaxGCPauseMillis</code></p><p>G1的停顿时间不能过短，如果停顿时间过短，那么每次GC收集都只会回收占用Region内存区域很小的一部分，而随着内存不断分配，堆上的垃圾越来越多，GC的速度低于分配的速度，就会触发<code>Full GC</code>，所以，只要我们把停顿时间设置后的效果为<strong>垃圾回收的速度与内存分配的速度大致相同</strong>，那么在理论上来说就永远不会发生<code>Full GC</code>，<strong>这也是G1被称为很牛逼的一个地方。</strong></p><h3 id="G1和CMS的比较"><a href="#G1和CMS的比较" class="headerlink" title="G1和CMS的比较"></a>G1和CMS的比较</h3><blockquote><p>G1从整体上看是“标记-整理”算法，从局部（两个Region之间）上看是“标记-复制”算法，不会产生内存碎片，而CMS基于“标记-清除”算法会产生内存碎片。</p><p>G1在垃圾收集时产生的内存占用和程勋运行时的额外负载都比CMS高</p><p>G1支持动态指定停顿时间，而CMS无法指定</p><p>两者都利用了并发标记这个技术</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本文导火索&quot;&gt;&lt;a href=&quot;#本文导火索&quot; class=&quot;headerlink&quot; title=&quot;本文导火索&quot;&gt;&lt;/a&gt;本文导火索&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://test-1874253.oss-cn-beijing.aliyuncs.com/</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程、进程、协程</title>
    <link href="https://leslieaibin.github.io/2020/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https://leslieaibin.github.io/2020/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-11T15:40:42.000Z</published>
    <updated>2020-11-23T07:57:54.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p><p>直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p><p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><p>线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。线程拥有自己的栈空间。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110233822293.png" alt="image-20201110233822293"></p><p>有人给出了很好的归纳：</p><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong>无论进程还是线程，都是由操作系统所管理的。Java中线程具有五种状态：</p><p><strong>初始化 可运行 运行中 阻塞 销毁</strong></p><p>这五种状态的转化关系如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110234003671.png" alt="image-20201110234003671"></p><p>但是，线程不同状态之间的转化是谁来实现的呢？是JVM吗？</p><p>并不是。JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p><p><strong>进程和线程的痛点</strong></p><p>线程之间是如何进行协作的呢？</p><p>最经典的例子就是<strong>生产者/消费者模式</strong>：</p><p>若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110234117470.png" alt="image-20201110234117470"></p><p>如何用java语言实现生产者/消费者模式呢？</p><p>让我们来看一看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="keyword">private</span> <span class="keyword">final</span> Queue sharedQueue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码做了下面几件事：</p><ul><li><p>定义了一个生产者类，一个消费者类。</p></li><li><p>生产者类循环100次，向同步队列当中插入数据。</p></li><li><p>消费者循环监听同步队列，当队列有数据时拉取数据。</p></li><li><p>如果队列满了（达到5个元素），生产者阻塞。</p></li><li><p>如果队列空了，消费者阻塞。</p></li></ul><p>上面的代码正确地实现了生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：</p><ul><li><p>涉及到同步锁。</p></li><li><p>涉及到线程阻塞状态和可运行状态之间的切换。</p></li><li><p>涉及到线程上下文的切换。</p></li></ul><p>以上涉及到的任何一点，都是非常耗费性能的操作。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110234418452.png" alt="image-20201110234418452"></p><p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p><p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JVM(一） —— 内存区域简介</title>
    <link href="https://leslieaibin.github.io/2020/11/10/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/"/>
    <id>https://leslieaibin.github.io/2020/11/10/Java/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-09T16:15:42.000Z</published>
    <updated>2020-11-15T15:13:52.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域</p><p><strong>JDK 1.8 之前：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110143215274.png" alt="image-20201110143215274"></p><p><strong>JDK 1.8 ：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110143245341.png" alt="image-20201110143245341"></p><p>线程私有：</p><ul><li>程序计时器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享：</p><ul><li>堆</li><li>方法区</li><li>直接内存</li></ul><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值，我们通过下面这段程序可以测试一下这个结果：</p><p>栈溢出测试源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorMock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index++;</span><br><span class="line">        call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackErrorMock mock = <span class="keyword">new</span> StackErrorMock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mock.call();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stack deep : &quot;</span>+index);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110150002504.png" alt="image-20201110150002504"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110150018247.png" alt="image-20201110150018247"></p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：</p><ul><li><p>return 语句。</p></li><li><p>抛出异常。</p></li></ul><p>不管哪种返回方式都会导致栈帧被弹出。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永生代(Permanent Generation)</li></ol><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110151449540.png" alt="image-20201110151449540"></p><p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110151457988.png" alt="image-20201110151457988"></p><p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p><p>Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">  uint age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ul><li><p><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</p></li><li><p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p></li></ul><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>方法区也被称为永久代。</p><h4 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h4><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h4 id="为什么要将永久代（PermGen）替换为元空间（Meta-Space）呢？"><a href="#为什么要将永久代（PermGen）替换为元空间（Meta-Space）呢？" class="headerlink" title="为什么要将永久代（PermGen）替换为元空间（Meta Space）呢？"></a>为什么要将永久代（PermGen）替换为元空间（Meta Space）呢？</h4><p>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><ul><li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li><li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li></ul><h3 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><ul><li><p>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</p></li><li><p>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 。</p></li><li><p>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</p></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110161814048.png" alt="image-20201110161814048"></p><h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：指针碰撞、空闲列表</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><ul><li><p><strong>指针碰撞</strong>：用过的内存全部放到一边，没用的内存放在另一边，中间有分界值指针，分配地址时只需要将指针向没用的内存移动对象内存大小位置即可(GC收集器：ParNew,Serial)</p></li><li><p><strong>空闲列表：</strong>虚拟机维护一个列表，该列表记录那些内存块是可用的，在分配内存时找一块足够大的内存分配给对象实例，然后更新列表记录；（GC收集器：cms）</p></li></ul><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110163702065.png" alt="image-20201110163702065"></p><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110163723635.png" alt="image-20201110163723635"></p><p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>; <span class="comment">//先检查字符串常量池中有没有“abcd&quot;, </span></span><br><span class="line"><span class="comment">//如果字符串常量池中没有，则创建一个,然后str1指向字符串常量池中的对象，</span></span><br><span class="line"><span class="comment">//如果有，则直接将str1指向“abcd&quot;</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>); <span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>); <span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这两种不同的创建方法是有差别的。</p><ul><li>第一种方式是在常量池中拿对象；</li><li>第二种方式是直接在堆内存空间创建一个新的对象。</li></ul><p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110164736482.png" alt="image-20201110164736482"></p><p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;计算机&quot;</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象      </span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201110165340549.png" alt="image-20201110165340549"></p><p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p><h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><h3 id="8-种基本类型的包装类和常量池"><a href="#8-种基本类型的包装类和常量池" class="headerlink" title="8 种基本类型的包装类和常量池"></a>8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;         </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">static</span> &#123;             </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)                 </span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);         </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 缓存源代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><ul><li><p>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</p></li><li><p>Integer i1 = new Integer(40);这种情况下会创建新的对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 比较更丰富的一个例子:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));<span class="comment">//true </span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));   <span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构简介</title>
    <link href="https://leslieaibin.github.io/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    <id>https://leslieaibin.github.io/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-07T16:15:42.000Z</published>
    <updated>2020-11-08T14:17:41.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><p>数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率。</p><p>如下图所示，常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1599638810-SZDwfK-Picture1.png" alt="Picture1.png"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1599587176-JAxwpf-Picture2.png" alt="Picture2.png"></p><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>为了在程序中使用一个数组，必须声明一个引用该数组的变量，并指明整个变量可以引用的数组类型。声明一维数组的语法格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName; <span class="comment">//数据类型[] 数组名;</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">type arrayName[]; <span class="comment">//数据类型 数组名[];</span></span><br></pre></td></tr></table></figure><p>数组的声明有两种形式：一种是中括号”[]“跟在元素数据类型之后，另一种是中括号”[]“跟在变量名之后。</p><p>对于以上两种语法格式而言，Java 更推荐采用第一种声明格式，因为第一种格式不仅具有更好的语意，而且具有更好的可读性。其中的数据类型既可以是基本数据类型，也可以是引用数据类型。数组名可以是任意合法的变量名。声明数组就是要告诉计算机该数组中数据的类型是什么。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] score;<span class="comment">//存储学生的成绩，类型是整型</span></span><br><span class="line"><span class="keyword">double</span>[] price;<span class="comment">//存储商品的价格，类型是浮点型</span></span><br><span class="line">String[] name;<span class="comment">//存储商品名称，类型为字符串型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明数组时不需要规定数组的长度，例如：</span></span><br><span class="line"><span class="keyword">int</span> score[<span class="number">10</span>];<span class="comment">//这是错误的</span></span><br></pre></td></tr></table></figure><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>声明了数组，只是得到了一个存放数组的变量，并没有为数组元素分配内存空间，不能使用。因此要为数组分配内存空间，这样数组的每一个元素才有一个空间进行存储。</p><p>简单地说，分配空间就是要告诉计算机在内存中为它分配几个连续的位置来存储数据。在 Java 中可以使用 new 关键字来给数组分配空间。分配空间的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[size];<span class="comment">//数组名 = new 数据类型[数组长度]</span></span><br></pre></td></tr></table></figure><p>其中，数组长度就是数组中能存放的元素个数，显然应该为大于 0 的整数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">price = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br><span class="line">name = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>这里的 score 是已经声明过的 int[] 类型的变量，当然也可以在声明数组时就给它分配空间，语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> type[size];    <span class="comment">// 数据类型[] 数组名 = new 数据类型[数组长度];</span></span><br></pre></td></tr></table></figure><p>例如，声明并分配一个长度为 5 的 int 类型数组 arr，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/3-1Q016111945238.jpg" alt="img"></p><p>在图  中 arr 为数组名称，方括号“[]”中的值为数组的下标。数组通过下标来区分数组中不同的元素，并且下标是从 0 开始的。因此这里包含 5 个元素的 arr 数组最大下标为 4。</p><p>注意：一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。</p><h4 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h4><p>Java 语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。</p><p>能不能只分配内存空间，不赋初始值呢？</p><p>不行，一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容为空，这个空也是一个值（null）。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种形式，一种由系统自动分配，另一种由程序员指定。</p><p>数组在初始化数组的同时，可以指定数组的大小，也可以分别初始化数组中的每一个元素。在 Java 语言中，初始化数组有以下 3 种方式。</p><ul><li><strong>使用new指定数组大小后进行初始化</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br></pre></td></tr></table></figure><p>创建数组后元素是不确定的，需要对数组的元素进行赋值，其下标从0开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">number[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">number[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">number[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">number[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>如果程序员只指定了数组的长度，那么系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值。</p><p>数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的值是 0。</p><p>数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是 0.0。</p><p>数组元素的类型是基本类型中的字符类型（char），则数组元素的值是‘\u0000’。</p><p>数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是 false。</p><p>数组元素的类型是引用类型（类、接口和数组），则数组元素的值是 null。</p><ul><li><strong>使用 new 指定数组元素的值</strong></li></ul><p>使用上述方式初始化数组时，只有在为元素赋值时才确定值。可以不使用上述方式，而是在初始化时就已经确定值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> type[]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,值 <span class="number">4</span>,• • •,值 n&#125;;</span><br></pre></td></tr></table></figure><p>指定数组元素的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p>上述代码的效果等价于第一种的效果。</p><p>注意：不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值，这样会造成代码错误。例如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">5</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">//这样是错误的</span></span><br></pre></td></tr></table></figure><ul><li>直接指定数组元素的值</li></ul><p>在上述两种方式的语法中，type 可以省略，如果已经声明数组变量，那么直接使用这两种方式进行初始化。如果不想使用上述两种方式，那么可以不使用 new 直接指定数组元素的值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = &#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,...,值 n&#125;;</span><br></pre></td></tr></table></figure><p>在前面例子的基础上更改代码，直接使用上述语法实现 number 数组的初始化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p>使用这种方式时，数组的声明和初始化操作要同步，即不能省略数组变量的类型。如下的代码就是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number;</span><br><span class="line">number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="获取单个元素"><a href="#获取单个元素" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>获取单个元素是指获取数组中的一个元素，如第一个元素或最后一个元素。获取单个元素的方法非常简单，指定元素所在数组的下标即可。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[index];</span><br></pre></td></tr></table></figure><p>其中，arrayName 表示数组变量，index 表示下标，下标为 0 表示获取第一个元素，下标为 array.length-1 表示获取最后一个元素。当指定的下标值超出数组的总长度时，会拋出 ArraylndexOutOfBoundsException 异常。</p><p>获取 number 数组中的第一个元素、最后一个元素和第六个元素，并将元素的值输出。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;获取第一个元素：&quot;</span>+number[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取最后一个元素：&quot;</span>+number[number.length-<span class="number">1</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取第6个元素：&quot;</span>+number[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>执行上述代码，输出结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第一个元素：1</span></span><br><span class="line"><span class="comment">//获取最后一个元素：8</span></span><br><span class="line"><span class="comment">//java.lang.ArrayIndexOutOfBoundsException: 5</span></span><br></pre></td></tr></table></figure><h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h3><h4 id="声明数组-1"><a href="#声明数组-1" class="headerlink" title="声明数组"></a>声明数组</h4><p>在 Java 中二维数组被看作数组的数组，即二维数组为一个特殊的一维数组，其每个元素又是一个一维数组。Java 并不直接支持二维数组，但是允许定义数组元素是一维数组的一维数组，以达到同样的效果。声明二维数组的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[][];    <span class="comment">// 数据类型 数组名[][];</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type[][] arrayName;    <span class="comment">// 数据类型[][] 数组名;</span></span><br></pre></td></tr></table></figure><p>其中，type 表示二维数组的类型，arrayName 表示数组名称，第一个中括号表示行，第二个中括号表示列。</p><p>下面分别声明 int 类型和 char 类型的数组，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] age;</span><br><span class="line"><span class="keyword">char</span>[][] sex;</span><br></pre></td></tr></table></figure><h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p>二维数组可以初始化，和一维数组一样，可以通过 3 种方式来指定元素的初始值。这 3 种方式的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[][] arrayName = <span class="keyword">new</span> type[][]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,…,值 n&#125;;    <span class="comment">// 在定义时初始化</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> type[size1][size2];    <span class="comment">// 给定空间，在赋值</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> type[size][];    <span class="comment">// 数组第二维长度为空，可变化</span></span><br></pre></td></tr></table></figure><p>使用第一种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>使用第二种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>使用第三种方式声明 int 类型的二维数组，并且初始化数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure><h4 id="获取单个元素-1"><a href="#获取单个元素-1" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>在上部分使用的前 2 种方式创建并初始化了一个二行二列的 int 类型数组 temp。当需要获取二维数组中元素的值时，也可以使用下标来表示。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>其中，arrayName 表示数组名称，i 表示数组的行数，j 表示数组的列数。例如，要获取第二行第二列元素的值，应该使用 temp[1][1]来表示。这是由于数组的下标起始值为 0，因此行和列的下标需要减 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123;&#123;<span class="number">10.0</span>,<span class="number">99</span>,<span class="number">99</span>&#125;,&#123;<span class="number">100</span>,<span class="number">98</span>,<span class="number">97</span>&#125;,&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">99.5</span>&#125;,&#123;<span class="number">99.5</span>,<span class="number">99</span>,<span class="number">98.5</span>&#125;&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;第二行第二列元素的值：&quot;</span>+class_score[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四行第一列元素的值：&quot;</span>+class_score[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二行第二列元素的值：<span class="number">98.0</span></span><br><span class="line">第四行第一列元素的值：<span class="number">99.5</span></span><br></pre></td></tr></table></figure><h4 id="获取全部元素"><a href="#获取全部元素" class="headerlink" title="获取全部元素"></a>获取全部元素</h4><p>在一维数组中直接使用数组的 length 属性获取数组元素的个数。而在二维数组中，直接使用 length 属性获取的是数组的行数，在指定的索引后加上 length（如 array[0].length）表示的是该行拥有多少个元素，即列数。</p><p>如果要获取二维数组中的全部元素，最简单、最常用的办法就是使用 for 语句。在一维数组全部输出时，我们使用一层 for 循环，而二维数组要想全部输出，则使用嵌套 for 循环（2 层 for 循环）。</p><p>使用 for 循环语句遍历 double 类型的 class_score 数组的元素，并输出每一行每一列元素的值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; class_score.length; i++) &#123; <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; class_score[i].length; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;class_score[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;]=&quot;</span> + class_score[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用嵌套 for 循环语句输出二维数组。在输出二维数组时，第一个 for 循环语句表示以行进行循环，第二个 for 循环语句表示以列进行循环，这样就实现了获取二维数组中每个元素的值的功能。</p><p>执行上述代码，输出结果如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class_score[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">98.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">97.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">99.5</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">99.5</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">98.5</span></span><br></pre></td></tr></table></figure><h3 id="创建多维数组"><a href="#创建多维数组" class="headerlink" title="创建多维数组"></a>创建多维数组</h3><p>除了一维数组和二维数组外，Java中还支持更多维的数组，如三维数组、四维数组和五维数组等，它们都属于多维数组。经过前面一维，二维的练习后不难发现，想要提高数组的维数，只要在声明数组时将索引与中括号再加一组即可，所以三维数组的声明为 int score[][][]，而四维数组为 int score[][][][]，以此类推。</p><p>通常也将二维数组看作是多维数组。本文以三维数组为例来介绍多维数组。</p><p>三维数组有三个层次，可以将三维数组理解为一个一维数组，其内容的每个元素都是二维数组。依此类推，可以获取任意维数的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[][][] namelist = &#123; &#123; &#123; <span class="string">&quot;张阳&quot;</span>, <span class="string">&quot;李风&quot;</span>, <span class="string">&quot;陈飞&quot;</span> &#125;, &#123; <span class="string">&quot;乐乐&quot;</span>, <span class="string">&quot;飞飞&quot;</span>, <span class="string">&quot;小曼&quot;</span> &#125; &#125;,</span><br><span class="line">            &#123; &#123; <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Kimi&quot;</span> &#125;, &#123; <span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span> &#125; &#125;, &#123; &#123; <span class="string">&quot;徐璐璐&quot;</span>, <span class="string">&quot;陈海&quot;</span> &#125;, &#123; <span class="string">&quot;李丽丽&quot;</span>, <span class="string">&quot;陈海清&quot;</span> &#125; &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; namelist.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; namelist[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; namelist[i][j].length; k++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;namelist[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;][&quot;</span> + k + <span class="string">&quot;]=&quot;</span> + namelist[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=张阳</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=李风</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>]=陈飞</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=乐乐</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=飞飞</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>]=小曼</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=Jack</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]=Kimi</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=Lucy</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=Lily</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>]=Rose</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>]=徐璐璐</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">0</span>][<span class="number">1</span>]=陈海</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>]=李丽丽</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">1</span>][<span class="number">1</span>]=陈海清</span><br></pre></td></tr></table></figure><h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><h4 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h4><p>将一个数组(变长参数的语法糖实现就是数组)转变成一个List(确切的来说是ArrayList)，注意这个List是定长的，企图添加或者删除数据都会报错（java.lang.UnsupportedOperationException）.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//3,4,2,1,5,7,6</span></span><br></pre></td></tr></table></figure><p>但是，对于基础类型（比如byte,int,float等）千万不要想着这么实现（案例1-2，勿效仿）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br></pre></td></tr></table></figure><p>因为List list = Arrays.asList(a);会变成List&lt;int[]&gt; list = Arrays.asList(a);所以遍历需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] arr:list)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作就显得非常的烦琐。因为预想List是List<Integer>形式的，没想到是List&lt;int[]&gt;形式的。使用的时候要特别的注意一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a[] = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><strong>对数组进行排序</strong>。适合byte,char,double,float,int,long,short等基本类型，还有Object类型（实现了Comparable接口），如果提供了比较器Comparator也可以适用于泛型。</p><p>案例（基础类型，输出：[1, 1, 4, 4, 5, 6, 7, 9]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure><p>案例（String类型(Object)，实现了Comparable接口，输出：[s1, s2, s3, s4]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br></pre></td></tr></table></figure><p>案例 （自定义类型，实现了Comparable接口，输出：[jj:17, zzh:18, qq:19]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person1 persons[] = <span class="keyword">new</span> Person1[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Person1(<span class="string">&quot;zzh&quot;</span>,<span class="number">18</span>),<span class="keyword">new</span> Person1(<span class="string">&quot;jj&quot;</span>,<span class="number">17</span>),<span class="keyword">new</span> Person1(<span class="string">&quot;qq&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(persons);</span><br><span class="line">System.out.println(Arrays.toString(persons));</span><br></pre></td></tr></table></figure><p>案例（泛型，如果类型没有实现Comparable接口，可以通过Comparator实现排序）[jj:17, zzh:18, qq:19]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person2 persons2[] = <span class="keyword">new</span> Person2[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Person2(<span class="string">&quot;zzh&quot;</span>,<span class="number">18</span>),<span class="keyword">new</span> Person2(<span class="string">&quot;jj&quot;</span>,<span class="number">17</span>),<span class="keyword">new</span> Person2(<span class="string">&quot;qq&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(persons2,<span class="keyword">new</span> Comparator&lt;Person2&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person2 o1, Person2 o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 == <span class="keyword">null</span> || o2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(persons2));</span><br></pre></td></tr></table></figure><h4 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h4><p>通过二分查找法对已排序（譬如经过Arrays.sort排序，且按照升序进行排序。如果数组没有经过排序，那么检索结果未知）的数组进行查找。适合byte,char,double,float,int,long,short等基本类型，还有Object类型和泛型（参考sort那段）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line"><span class="keyword">int</span> ans = Arrays.binarySearch(str, <span class="string">&quot;s1&quot;</span>);</span><br><span class="line">System.out.println(ans);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s1, s2, s3, s4]</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h4><p>数组拷贝，底层采用System.arrayCopy（native方法）实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOf(str, str.length);</span><br><span class="line">System.out.println(Arrays.toString(str2));</span><br><span class="line">System.out.println(str.equals(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s2, s4, s1, s3]</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h4><p><strong>数组拷贝，指定一定的范围</strong>，譬如（public static T[] copyOfRange(T[] original, int from, int to)）。底层采用System.arrayCopy（native方法）实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOfRange(str,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s4, s1]</span></span><br></pre></td></tr></table></figure><h4 id="equals和deepEquals"><a href="#equals和deepEquals" class="headerlink" title="equals和deepEquals"></a>equals和deepEquals</h4><p><strong>equals</strong>：判断两个数组的每一个对应的元素是否相等（equals, 对于两个数组的元素o1和o2有o1==null ? o2==null : o1.equals(o2)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str1[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>,<span class="keyword">null</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOf(str1, str1.length);</span><br><span class="line">System.out.println(Arrays.equals(str1, str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.equals(array1, array2)：</span></span><br><span class="line"><span class="comment">//检查两个数组是否包含相同数量的元素，并且两个数组中的所有相应元素对是否相等。</span></span><br><span class="line"><span class="comment">//array1.equals(array2)：</span></span><br><span class="line"><span class="comment">//将该对象与另一个对象进行比较，只有当两个对象的引用相同时才返回true `Object.equals()`</span></span><br></pre></td></tr></table></figure><p><strong>deepEquals</strong>：主要针对一个数组中的元素还是数组的情况，类似deepToString, deepHashCode如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a4[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a5[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a6[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a4,a5,a6&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.equals(a, b));</span><br><span class="line">System.out.println(Arrays.deepEquals(a, b));</span><br><span class="line"></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>给数组赋值。填充数组之用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>,<span class="keyword">null</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line">Arrays.fill(str, <span class="string">&quot;s5&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s2, s4, s1, s3, null]</span></span><br><span class="line"><span class="comment">//[s5, s5, s5, s5, s5]</span></span><br></pre></td></tr></table></figure><h4 id="toString和deepToString"><a href="#toString和deepToString" class="headerlink" title="toString和deepToString"></a>toString和deepToString</h4><p><strong>toString</strong>：对于一个数组int a[] = new int[]{1,9,5,4,6,4,7,1};如果按照System.out.println(a);打印企图可以打印出[1,9,5,4,6,4,7,1]，实际上只会打印出[I@3e2de41d这种。在打印数组的时候需要写成Arrays.toString(a)的形式。可参考sort的详解。<br>        <strong>deepToString</strong>：当数组中又包含数组，那么就不能单存的利用Arrays.toString()了，请看例子。<br>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">System.out.println(Arrays.deepToString(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[[I@1b6b7f83, [I@2e807f85, [I@76340c9c]</span></span><br><span class="line"><span class="comment">//[[1, 2, 3], [1, 3, 3], [4, 3, 2, 1]]</span></span><br></pre></td></tr></table></figure><h4 id="hashCode和deepHashCode"><a href="#hashCode和deepHashCode" class="headerlink" title="hashCode和deepHashCode"></a>hashCode和deepHashCode</h4><p><strong>hashCode</strong>：计算一个数组的hashCode.对于一个数组Object[], hashCode方法返回的值取决于：数组中每个元素的元素oi.hashCode()的值初级计算result = 31 * result + (oi== null ? 0 : oi.hashCode());<br>        <strong>deepHashCode</strong>: 对于一个数组Object[], deepHashCode取决于：数组中每个元素oi，如果oi还是一个数组，那么就继续深入的去获取hashCode，这段比较绕，来个例子比较形象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line">System.out.println(Arrays.hashCode(a));</span><br><span class="line">System.out.println(Arrays.deepHashCode(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1683374023</span></span><br><span class="line"><span class="comment">//31646847</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构简介&quot;&gt;&lt;a href=&quot;#数据结构简介&quot; class=&quot;headerlink&quot; title=&quot;数据结构简介&quot;&gt;&lt;/a&gt;数据结构简介&lt;/h2&gt;&lt;p&gt;数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈BFS和DFS</title>
    <link href="https://leslieaibin.github.io/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/BFS%E5%92%8CDFS%E8%AF%A6%E8%A7%A3/"/>
    <id>https://leslieaibin.github.io/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/BFS%E5%92%8CDFS%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-11-06T16:15:42.000Z</published>
    <updated>2020-11-07T13:39:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先遍历（Depth First Search, 简称DFS）与广度优先遍历（Breath First Search，简称BFS）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫）、搜索引擎、爬虫等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89.gif" alt="DFS 与 BFS 对比"></p><h2 id="DFS-Deep-First-Search"><a href="#DFS-Deep-First-Search" class="headerlink" title="DFS (Deep First Search)"></a>DFS (Deep First Search)</h2><p>DFS：从当前节点开始，先标记当前节点，再寻找与当前节点相邻，且未标记过的节点（ 这是一个递归思想的DFS）</p><ul><li>当前节点不存在下一个节点，则返回前一个节点进行DFS</li><li>当前节点存在下一个节点，则从下一个节点进行DFS</li></ul><p><strong>DFS 遍历使用递归遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。</p><h3 id="网格结构中的-DFS"><a href="#网格结构中的-DFS" class="headerlink" title="网格结构中的 DFS"></a>网格结构中的 DFS</h3><p> <strong>网格问题的基本概念</strong></p><p>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p><p>网格问题是由 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p><p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204300931.png" alt="image-20201107204300931"></p><p>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p><p> <strong>DFS 的基本结构</strong></p><p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的<strong>图</strong>结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travese</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问两个相邻节点：左子节点，右子节点</span></span><br><span class="line">    travese(root.left);</span><br><span class="line">    travese(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，二叉树的DFS有两个要素：【<strong>访问相邻节点</strong>】 和 【<strong>判断base case</strong>】。</p><p>第一个要素是<strong>访问相邻的节点</strong>。二叉树的相邻节点非常简单，只有左子树和右子树。二叉树本身就是一个递归定义的结构：一颗二叉树，他的左子树和右子树也是一颗二叉树。那么我们的DFS遍历只需要调用左子树和右子树即可。</p><p>第二个要素就是判断<strong>base case</strong>。一般来说，二叉树遍历的base case是 root == null。这样一个条件判断其实有两个含义:</p><ul><li>表示root指向指向的子树为空，不需要再往下遍历了。</li><li>在root == null的时候及时返回，可以让后面的root.left 和root.right操作不会出现空指针异常</li></ul><p>对于网格上的DFS，可以参考二叉树的DFS，写出网格的DFS的两个要素：</p><ul><li>相邻节点对于格子 <code>(r, c)</code> 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 <code>(r-1, c)</code>、<code>(r+1, c)</code>、<code>(r, c-1)</code>、<code>(r, c+1)</code>。换句话说，网格结构是「四叉」的。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204116039.png" alt="image-20201107204116039"></p><ul><li>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、<code>grid[r][c]</code> 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204315074.png" alt="image-20201107204315074"></p><h3 id="DFS遍历网格的框架代码"><a href="#DFS遍历网格的框架代码" class="headerlink" title="DFS遍历网格的框架代码"></a>DFS遍历网格的框架代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免重复遍历将已经遍历的格子设置为2</span></span><br><span class="line"><span class="comment">// 0 —— 海洋格子</span></span><br><span class="line"><span class="comment">// 1 —— 陆地格子（未遍历过）</span></span><br><span class="line"><span class="comment">// 2 —— 陆地格子（已遍历过）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][],grid <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">//将已经遍历过得格子 变为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//访问上、下、左、右相邻节点、</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断坐标（r,c）是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">         &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿问题解决"><a href="#岛屿问题解决" class="headerlink" title="岛屿问题解决"></a>岛屿问题解决</h3><h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><p>这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = area(grid, r , c);</span><br><span class="line">            res = Math.max(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">inArea</span><span class="params">(grid, r ,c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] == <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        + are(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + are(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + are(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + are(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt;= grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h4><p>实话说，这道题用 DFS 来解并不是最优的方法。对于岛屿，直接用数学的方法求周长会更容易。不过这道题是一个很好的理解 DFS 遍历过程的例题，不信你跟着我往下看。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/640" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimter</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; grid.length; r++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//题目限制只有一个岛屿，只计算一个即可</span></span><br><span class="line">                <span class="keyword">return</span> dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//函数因为（坐标（r,c)超出网格范围，对应一条黄色的边</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数因为当前格式是海洋格子返回，对应一条蓝色的边</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS-Breath-First-Search"><a href="#BFS-Breath-First-Search" class="headerlink" title="BFS(Breath First Search)"></a>BFS(Breath First Search)</h2><p>BFS: 广度优先算法便如其名字，他是以广度为优先的，一层一层搜索下去，就像病毒感染，扩散性的传播下去。</p><ul><li>比如每遍历start周围的一个“1”节点的时候，就把跟它相关联的“2”节点保存到队列中</li><li>然后依次访问队列内容，并对每个队列元素重复上个步骤</li><li>由此重复下去，直到队列为空或者搜索到终点</li></ul><p><strong>BFS 遍历使用队列数据结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-的应用一：层序遍历"><a href="#BFS-的应用一：层序遍历" class="headerlink" title="BFS 的应用一：层序遍历"></a>BFS 的应用一：层序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">[102. 二叉树的层序遍历]</a></p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.jpg" alt="二叉树的层序遍历"></p><p>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg" alt="BFS 遍历与层序遍历的输出结果不同"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif" alt="BFS 遍历的过程（动图）"></p><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 nn（也就是这一层的结点数量），然后一口气处理完这一层的 nn 个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">//变量i无实际意义只是为了循环n次</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif" alt="img"></p><p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p><p>最终我们得到的题解代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">       <span class="keyword">int</span> n = queue.size();</span><br><span class="line">       List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           level.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.add(level);</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-的应用二：最短路径"><a href="#BFS-的应用二：最短路径" class="headerlink" title="BFS 的应用二：最短路径"></a>BFS 的应用二：最短路径</h3><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/01a3617511b1070216582ae59136888072116ccba360ab7c2aa60fc273351b85.jpg" alt="层序遍历与最短路径"></p><p>要解最短路径问题，我们首先要写出层序遍历的代码，仿照上面的二叉树层序遍历代码，类似地可以写出网格层序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网格结构的层序遍历</span></span><br><span class="line"><span class="comment">// 从格子 (i, j) 开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span>[] node = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r = node[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = node[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r-<span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r+<span class="number">1</span> &lt; N &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r+<span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r][c-<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c+<span class="number">1</span> &lt; N &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r][c+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的层序遍历代码有几个注意点：</p><p>队列中的元素类型是 int[] 数组，每个数组的长度为 2，包含格子的行坐标和列坐标。<br>为了避免重复遍历，这里使用到了和 DFS 遍历一样的技巧：把已遍历的格子标记为 2。注意：我们在将格子放入队列之前就将其标记为 2。想一想，这是为什么？<br>在将格子放入队列之前就检查其坐标是否在网格范围内，避免将「不存在」的格子放入队列。<br>这段网格遍历代码还有一些可以优化的地方。由于一个格子有四个相邻的格子，代码中判断了四遍格子坐标的合法性，代码稍微有点啰嗦。我们可以用一个 moves 数组存储相邻格子的四个方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">    &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后把四个 if 判断变成一个循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[][] move : moves) &#123;</span><br><span class="line">    <span class="keyword">int</span> r2 = r + move[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c2 = c + move[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == <span class="number">0</span>) &#123;</span><br><span class="line">        grid[r2][c2] = <span class="number">2</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r2, c2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好了层序遍历的代码，接下来我们看看如何来解决本题中的最短路径问题。</p><p>这道题要找的是距离陆地最远的海洋格子。假设网格中只有一个陆地格子，我们可以从这个陆地格子出发做层序遍历，直到所有格子都遍历完。最终遍历了几层，海洋格子的最远距离就是几。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8e108e43731bd61a225f79cde11783ae0df17f171974896dc631bbdcda637aa9.gif" alt="从单个陆地格子出发的距离（动图）"></p><p>那么有多个陆地格子的时候怎么办呢？一种方法是将每个陆地格子都作为起点做一次层序遍历，但是这样的时间开销太大。</p><p>BFS 完全可以以多个格子同时作为起点。我们可以把所有的陆地格子同时放入初始队列，然后开始层序遍历，这样遍历的效果如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/0a7e2f150e95617c19ff7eddb9f2a8d795c23d02b8c1e51a1ff45920d493047b.gif" alt="从多个陆地格子出发的距离"></p><p>这种遍历方法实际上叫做「多源 BFS」。多源 BFS 的定义不是今天讨论的重点，你只需要记住多源 BFS 很方便，只需要把多个源点同时放入初始队列即可。</p><p>需要注意的是，虽然上面的图示用 1、2、3、4 表示层序遍历的层数，但是在代码中，我们不需要给每个遍历到的格子标记层数，只需要用一个 distance 变量记录当前的遍历的层数（也就是到陆地格子的距离）即可。</p><p>最终，我们得到的题解代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = grid.length;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将所有的陆地格子加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果地图上只有陆地或者海洋，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty() || queue.size() == N * N) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">        &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> distance = -<span class="number">1</span>; <span class="comment">// 记录当前遍历的层数（距离）</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        distance++;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span>[] node = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r = node[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = node[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] move : moves) &#123;</span><br><span class="line">                <span class="keyword">int</span> r2 = r + move[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c2 = c + move[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[r2][c2] = <span class="number">2</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r2, c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深度优先遍历（Depth First Search, 简称DFS）与广度优先遍历（Breath First Search，简称BFS）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫）、搜索引擎、爬虫等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://te</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="BFS" scheme="https://leslieaibin.github.io/tags/BFS/"/>
    
    <category term="DFS" scheme="https://leslieaibin.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前、中、后序遍历（递归和循环）</title>
    <link href="https://leslieaibin.github.io/2020/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF%EF%BC%89/</id>
    <published>2020-11-01T16:15:42.000Z</published>
    <updated>2020-11-02T15:43:30.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树节点结构"><a href="#二叉树节点结构" class="headerlink" title="二叉树节点结构"></a>二叉树节点结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p><strong>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</strong>  （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>前序遍历：1 2 4 6 7 8 3 5</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//一共到达三次root的节点</span></span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        <span class="comment">//返回root</span></span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">        <span class="comment">//返回root</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-c0aa74a23a4d357d.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val); <span class="comment">//先将节点加入结果队列</span></span><br><span class="line">                stack.push(root);  <span class="comment">//不断将该节点左子树入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">//栈顶节点出栈</span></span><br><span class="line">            root = root.right; <span class="comment">//转向该节点右子树的左子树（下一个循环）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p><strong>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</strong> （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>中序遍历 ：4 7 6 8 2 1 3 5</strong></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></p><h2 id="递归算法-1"><a href="#递归算法-1" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h2><p><img src="https://upload-images.jianshu.io/upload_images/2405011-c0aa74a23a4d357d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);  <span class="comment">//不断将该节点左子树入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">//栈顶节点出栈</span></span><br><span class="line">            res.add(root.val); <span class="comment">//将节点加入结果队列</span></span><br><span class="line">            root = root.right; <span class="comment">//转向该节点右子树的左子树（下一个循环）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h1><p><strong>后序遍历： 左子树 —&gt; 右子树 —&gt;根结点</strong>  （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>后序遍历：7 8 6 4 2 5 3 1</strong> </p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></p><h2 id="递归算法-2"><a href="#递归算法-2" class="headerlink" title="递归算法"></a>递归算法</h2><p><strong>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</strong>（根节点在 前中后 那个位置 就叫什么遍历）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>; <span class="comment">//pre节点用于记录前一次访问的节点</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root); <span class="comment">//不断将左节点压栈</span></span><br><span class="line">                root = root.left; </span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="keyword">null</span> || root.right==pre)&#123; <span class="comment">//若右节点为空 或右节点访问过</span></span><br><span class="line">                res.add(root.val); <span class="comment">//此时可以访问根结点啦</span></span><br><span class="line">                pre = root;</span><br><span class="line">                stack.pop();</span><br><span class="line">                root = <span class="keyword">null</span>; <span class="comment">//此时下一轮循环不要将左子树压栈，直接判断栈顶元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = root.right; <span class="comment">//先不出栈 把它右节点入栈</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="comment">//修改前序遍历代码中，节点写入结果链表的代码：将插入队尾修改为插入队首</span></span><br><span class="line"><span class="comment">//修改前序遍历代码中，每次先查看左节点再查看右节点的逻辑：变为先查看右节点再查看左节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.addFirst(root.val); <span class="comment">//插入队首</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right; <span class="comment">//先右后左</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树节点结构&quot;&gt;&lt;a href=&quot;#二叉树节点结构&quot; class=&quot;headerlink&quot; title=&quot;二叉树节点结构&quot;&gt;&lt;/a&gt;二叉树节点结构&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://leslieaibin.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Win10连接linux服务器的工具</title>
    <link href="https://leslieaibin.github.io/2020/10/31/%E5%B7%A5%E5%85%B7/win10%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://leslieaibin.github.io/2020/10/31/%E5%B7%A5%E5%85%B7/win10%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2020-10-31T15:40:42.000Z</published>
    <updated>2020-11-23T07:45:01.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的远程连接Linux工具"><a href="#常用的远程连接Linux工具" class="headerlink" title="常用的远程连接Linux工具"></a>常用的远程连接Linux工具</h2><p>常用的远程连接Linux工具有：Vscode、XShell、FinallShell等。下面重点介绍该三种工具：</p><h2 id="1-VsCode的Remote插件"><a href="#1-VsCode的Remote插件" class="headerlink" title="1 VsCode的Remote插件"></a>1 VsCode的Remote插件</h2><p>Vscode是一款开源的跨平台编辑器。默认情况下，vscode使用的语言为英文(us)</p><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h3><p>官方下载地址：<a href="https://links.jianshu.com/go?to=https://code.visualstudio.com/%23alt-downloads">https://code.visualstudio.com/#alt-downloads</a></p><p>选择自己的系统版本，安装时一直下一步即可，安装完成后直接运行code.exe</p><h3 id="1-2-修改vscode为中文环境"><a href="#1-2-修改vscode为中文环境" class="headerlink" title="1.2 修改vscode为中文环境"></a>1.2 修改vscode为中文环境</h3><ul><li><p>使用快捷键【Ctrl+Shift+X】，在搜索框中输入“chinese”，选择安装   中文（简体） install；</p></li><li><p> 再次使用快捷键【Ctrl+Shift+P】，在搜索框中输入“configure display language”，选择 zh-CN ，确认重启即可。</p></li></ul><h3 id="1-3-修改主题颜色"><a href="#1-3-修改主题颜色" class="headerlink" title="1.3 修改主题颜色"></a>1.3 修改主题颜色</h3><p>使用快捷键【Ctrl+K 】【Ctrl+T 】弹出选择框，选择自己喜欢的主题</p><h3 id="1-4-安装Remote-SSH"><a href="#1-4-安装Remote-SSH" class="headerlink" title="1.4 安装Remote-SSH"></a>1.4 安装Remote-SSH</h3><p>直接打开vscode中的插件搜索SSH找到Remote-SSH直接安装即可。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130400.png" alt="image-20201016130400637"></p><h3 id="1-5-配置Remote-SSH"><a href="#1-5-配置Remote-SSH" class="headerlink" title="1.5 配置Remote-SSH"></a>1.5 配置Remote-SSH</h3><p>​        安装完成后会出现一个远程资源管理器图标，其中可以选择SSH Targets。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130451.webp" alt="img"></p><p>然后点击配置：</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130523.webp" alt="img"></p><p>此时打开一个config配置文件，让你输入HostName和User：</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016131335.png" alt="image-20201016131326006"></p><h3 id="1-6-连接远程服务器"><a href="#1-6-连接远程服务器" class="headerlink" title="1.6 连接远程服务器"></a>1.6 连接远程服务器</h3><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132016.png" alt="image-20201016132016082"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132050.png" alt="image-20201016132050898"></p><p><strong>输入密码为test</strong></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132432.png" alt="image-20201016132252488"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132440.png" alt="image-20201016132323464"></p><p>打开文件夹 命令行</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016132600856.png" alt="image-20201016132600856"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016132650554.png" alt="image-20201016132650554"></p><h3 id="1-7安装插件"><a href="#1-7安装插件" class="headerlink" title="1.7安装插件"></a>1.7安装插件</h3><p>​        本机中的插件是无法在远程服务器中使用的，这就需要我们从新安装插件，这个也比较简单，在连接上远程服务器后在vscdoe的插件侧边栏中就可以看到一个专为远程服务器显示 安装插件的区域，此后的操作与本地安装基本一样。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016135335446.png" alt="image-20201016135335446"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016135433543.png" alt="image-20201016135433543"></p><h2 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h2><p>​        Xshell：是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。软件强大，在windows环境下使用用户多，非常重要的一点是：对个人、教育用户是免费的。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101034.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p>​        它的使用方式略有区别，第一次双击软件图标，打开后，需要先点击软件界面左上角的文件，点击新建，然后才能出来主机信息配置界面。输入主机别名、ip地址和端口，然后点击确定。就会弹到服务器列表，在列表中选择你刚才添加的服务器名称，然后点击连接。就开始自动连接对应的服务器。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101140.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101124.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101124.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p>​        输入用户名，点击确定，再输入密码。认证成功后就进入到了服务器的shell界面。显示你上一次的登录时间以及IP地址。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101212.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101220.png" alt="Windows下连接Linux的ssh工具有哪些"></p><h2 id="FinallShell"><a href="#FinallShell" class="headerlink" title="FinallShell"></a>FinallShell</h2><p>​        FinalShell一款很好用的ssh链接工具，标准免费版本就可以基本满足一般用户的需求，和xshell工具相比，虽然没有那么多绚丽多彩的功能，但是小巧实用，而且关键是免费。</p><p>​        xshell虽然也是免费，但是过了评估试用期还需要重新下载安装。</p><p>​        先来看一下FinalShell的链接界面。</p><p>​        界面简洁，但是基本上可以满足普通用户的基本需求了，因为在左侧可以一目了然服务器的基本情况。</p><p>​        磁盘使用情况，内存，cpu负载情况等等。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102020.png" alt="如何通过FinalShell连接linux服务器"></p><p>​        点击上方类似文件夹的图标，点开后，下方是我已经链接过的机器列表，如果是第一次使用，这个列表是空的。连接列表里面的机器，直接双击即可连接。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102103.png" alt="如何通过FinalShell连接linux服务器"></p><p>​            然后，点击第一个+号，在弹出的下拉列表处，选择ssh连接。这里可以看到有一个远程桌面链接（windows），FinalShell还是比较实用的。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102251.png" alt="如何通过FinalShell连接linux服务器"></p><p>​        在弹出的对话框中，写入要连接的服务器的ip地址和端口。名称可以随意填写，方便自己记忆。</p><p>可以直接在这个窗口填入用户名和密码。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102452.png" alt="如何通过FinalShell连接linux服务器"></p><p>​            当连接机器时，会提示输入用户名和密码的。也可以勾选保存，这样下次连接时就不用再次输入用户名和密码了。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102545.png" alt="如何通过FinalShell连接linux服务器"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102551.png"></p><p>​        如果是要连接已经连接的机器，打开列表框，双击某个记录就可以了。红框标出的就是我所有连接过的机器。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102621.png" alt="如何通过FinalShell连接linux服务器"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用的远程连接Linux工具&quot;&gt;&lt;a href=&quot;#常用的远程连接Linux工具&quot; class=&quot;headerlink&quot; title=&quot;常用的远程连接Linux工具&quot;&gt;&lt;/a&gt;常用的远程连接Linux工具&lt;/h2&gt;&lt;p&gt;常用的远程连接Linux工具有：Vscode</summary>
      
    
    
    
    <category term="Linux" scheme="https://leslieaibin.github.io/categories/Linux/"/>
    
    
    <category term="ssh" scheme="https://leslieaibin.github.io/tags/ssh/"/>
    
    <category term="Linux" scheme="https://leslieaibin.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-（6-11章）</title>
    <link href="https://leslieaibin.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%886-11%E7%AB%A0%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%886-11%E7%AB%A0%EF%BC%89/</id>
    <published>2020-10-29T16:15:42.000Z</published>
    <updated>2020-10-30T08:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6. HTTP首部"></a>6. HTTP首部</h1><h2 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf41c1eadc" alt="httpstructure"></p><p>上图是HTTP<strong>请求报文</strong>的结构</p><p>HTTP请求报文由方法、URI、HTTP版本、HTTP首部字段等组成。</p><p>请求报文首部信息实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>; WOW64; rv:<span class="number">13.0</span>) Gecko/<span class="number">2010010</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*; q=0</span></span><br><span class="line"><span class="comment">Accept-Language: ja,en-us;q=0.7,en;q=0.3</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">DNT: 1</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT</span></span><br><span class="line"><span class="comment">If-None-Match: &quot;45bae1-16a-46d776ac&quot;</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br></pre></td></tr></table></figure><p>HTTP响应报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段三部分组成。</p><p>下面是HTTP<strong>响应报文</strong>结构：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf4203c6ba" alt="httpresstructure"></p><p>响应报文的首部实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line">Date: Thu, <span class="number">07</span> Jun <span class="number">2012</span> <span class="number">07</span>:<span class="number">21</span>:<span class="number">36</span> GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Connection: close</span><br><span class="line">Etag: <span class="string">&quot;45bae1-16a-46d776ac&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h2><h3 id="6-2-1-HTTP首部字段结构"><a href="#6-2-1-HTTP首部字段结构" class="headerlink" title="6.2.1 HTTP首部字段结构"></a>6.2.1 HTTP首部字段结构</h3><p>HTTP首部字段传递重要信息，其结构基本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首部字段名： 字段值</span><br><span class="line">例如：</span><br><span class="line">Content-Type: text/html</span><br><span class="line">另外，有些首部字段可以有多个值，如下：</span><br><span class="line">    Keep-Alive:timeout=<span class="number">15</span>,max=<span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="6-2-2-HTTP首部字段类型"><a href="#6-2-2-HTTP首部字段类型" class="headerlink" title="6.2.2 HTTP首部字段类型"></a>6.2.2 HTTP首部字段类型</h3><p>HTTP首部字段根据实际用途被分为四种类型：</p><ul><li><strong>通用首部字段</strong>  请求报文和响应报文都会使用到的首部字段</li><li><strong>请求首部字段</strong>  从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级的信息。</li><li><strong>响应首部字段</strong>  从服务端向客户端发送响应报文时的首部。补充了响应的附加内容，也会要求客户端附加的内容信息。</li><li><strong>实体首部字段</strong>  针对请求报文和响应报文的实体部分 使用的首部。补充了资源内容更新时间等与实体内容相关的信息。</li></ul><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">逐跳首部、连接的管理</td></tr><tr><td align="center">Data</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末尾的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他 协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Authorization</td><td align="center">Web信息认证</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在的服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与If-Match相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体Byte的范围请求</td></tr><tr><td align="center">If-Unmodifield-Since</td><td align="center">比较实体标记（与If-Match相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中URL的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码优先级</td></tr><tr><td align="center">Use-Agent</td><td align="center">HTTP客户端程序的信息</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配资源</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的HTTP方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小（字节）</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的URI</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改时间</td></tr></tbody></table><p>以上就是最常用的一些 HTTP 首部字段。</p><p>其他还有一些非 HTTP/1.1 规范的首部字段也用的比较多，比如 Set-Cookie、Cookie 等等。</p><p>此外，HTTP 首部根据将定义成缓存代理和非缓存代理的行为，分成了两种类型——端到端首部（End-to-End Header）和逐跳首部（Hop-by-Hop Header）。</p><p>端到端首部类的首部字段会转发给请求/响应的最终接受对象，且必须保存在由缓存生成的响应中，另外规定它必须转发；</p><p>逐跳首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 之后的版本中使用逐跳首部需要提供 Connection 首部字段。</p><p>下面这些字段都属于逐跳首部字段：</p><ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><p>所有其余字段皆为端到端首部字段。</p><p>下面开始详细介绍各个首部字段。</p><h3 id="6-2-3-HTTP-1-1-通用首部字段"><a href="#6-2-3-HTTP-1-1-通用首部字段" class="headerlink" title="6.2.3  HTTP/1.1 通用首部字段"></a>6.2.3  HTTP/1.1 通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段Cache-Control,就能操作缓存的工作机制。</p><p>Cache-Control 的指令参数是可选的，多个指令之间通过逗号分开。该首部字段在请求和响应时都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:<span class="keyword">private</span>, max-age = <span class="number">0</span> , no-cache</span><br></pre></td></tr></table></figure><p><strong>Cache-Control 可用指令如下：</strong></p><p><strong>请求指令</strong></p><table><thead><tr><th align="center">指令</th><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">no-cache</td><td align="center">无</td><td align="center">强制向源服务器再次验证</td></tr><tr><td align="center">no-store</td><td align="center">无</td><td align="center">不缓存请求或响应的任何内容</td></tr><tr><td align="center">max-age=[秒]</td><td align="center">必需</td><td align="center">响应的最大 age 值</td></tr><tr><td align="center">max-stale(=[秒])</td><td align="center">可省略</td><td align="center">接受已过期的响应</td></tr><tr><td align="center">min-fresh=[秒]</td><td align="center">必需</td><td align="center">期望在指定的时间内的响应仍然有效</td></tr><tr><td align="center">no-transform</td><td align="center">无</td><td align="center">代理不可更改媒体类型</td></tr><tr><td align="center">only-if-cached</td><td align="center">无</td><td align="center">从缓存获得资源</td></tr><tr><td align="center">cache-extension</td><td align="center">-</td><td align="center">新指令标记（token）</td></tr></tbody></table><p><strong>响应指令</strong></p><table><thead><tr><th align="center">指令</th><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">无</td><td align="center">可向任意方提供响应的缓存</td></tr><tr><td align="center">private</td><td align="center">可省略</td><td align="center">仅向特定用户返回响应</td></tr><tr><td align="center">no-cache</td><td align="center">可省略</td><td align="center">缓存前必须确认其有效性</td></tr><tr><td align="center">no-store</td><td align="center">无</td><td align="center">不缓存请求或响应的任何内容</td></tr><tr><td align="center">no-transform</td><td align="center">无</td><td align="center">代理不可更改媒体类型</td></tr><tr><td align="center">must-revalidate</td><td align="center">无</td><td align="center">可缓存但必须再向源服务器进行确认</td></tr><tr><td align="center">proxy-revalidate</td><td align="center">无</td><td align="center">要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td align="center">max-age=[秒]</td><td align="center">必需</td><td align="center">响应的最大 age 值</td></tr><tr><td align="center">s-maxage=[秒]</td><td align="center">必需</td><td align="center">公共缓存服务器响应的最大 age 值</td></tr><tr><td align="center">cache-extension</td><td align="center">-</td><td align="center">新指令标记（token）</td></tr></tbody></table><p>规定是否缓存的指令：</p><p>**public指令 **  当指定使用public指令时 ，则明确表明其他用户也可以利用缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">public</span></span><br></pre></td></tr></table></figure><p>当指定使用public指令时，则明确表明其他用户也可以利用缓存。</p><p><strong>private指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">private</span></span><br></pre></td></tr></table></figure><p>当指定private指令后响应只以特定的用户作为对象，当该对象向服务器发起请求时，服务器会返回缓存的资源</p><p><strong>no-cache指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>该指令的目的是为了防止使用过期的缓存资源</p><p>如果客户端发送的请求包含no-cache指令，则表示客户端将不会接受过期的缓存过得响应。于是，中间的代理服务器必须把请求转发给原服务器。</p><p>如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器以后也将不在对缓存服务器请求中提出的资源有效性进行确认，且进制其对资源响应进行缓存操作。</p><p>控制可执行缓存对象的指令</p><p><strong>no-store指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p>当使用no-store指令时，按时请求或响应中包含机密信息。</p><p>因此该指令规定缓存不能在本地存储请求或响应的任一部分。</p><p><strong>s-maxage 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: s-maxage&#x3D;604800（单位：秒）</span><br></pre></td></tr></table></figure><p>该指令功能和max-age相同，不同点是s-maxage指令只适合于供多位用户使用的公共缓存服务器。当使用smax-age 指令之后，直接会忽略 Expires 字段及 max-age 指令的处理。</p><p><strong>max-age 指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=<span class="number">604800</span>（单位：秒）</span><br></pre></td></tr></table></figure><p><strong>当客户端发送的请求中包含 max-age 指令时</strong>，如果判定缓存资源的缓存时间数值比指定的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器（相当于是 no-cache）。</p><p><strong>当服务器返回的响应中包含 max-age 指令时</strong>，缓存服务器将不对资源的有效性再做确认，而 max-age 数值代表的是资源保存为缓存的最长时间。</p><p>应用 HTTP/1.1 版本的缓存的服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而应用 HTTP/1.0 版本的服务器则恰恰相反。</p><p><strong>min-fresh 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: min-fresh&#x3D;60（单位：秒）</span><br></pre></td></tr></table></figure><p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源（即指定时间过后仍然是未过期的资源）。</p><p><strong>max-stale 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-stale&#x3D;3600（单位：秒） </span><br></pre></td></tr></table></figure><p>使用 max-stale 表示接受过期的缓存资源，后面的值表示具体过期的时长，表示响应不能已经过时超过该给定的时间。如果不传递数值，则表示无论经过多久，客户端都能够接受。</p><p><strong>only-if-cached 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: only-if-cached</span><br></pre></td></tr></table></figure><p>使用该指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。即只接受已缓存的资源，并且不用向源服务器检查资源的有效性。若代理服务器本地缓存无响应，则返回 504 Gateway Timeout。</p><p><strong>must-revalidate 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure><p>使用该指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p><p>使用 must-revalidate 指令会忽略 max-stale 指令。</p><p><strong>proxy-revalidate 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: proxy-revalidate</span><br></pre></td></tr></table></figure><p>该指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再验证资源的有效性。</p><p><strong>no-transform 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure><p>该指令规定无论在请求还是响应中缓存都不能改变实体的媒体类型。</p><p>这样可以防止缓存或者代理压缩图片等类似操作。</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>这个首部字段有一下两个作用：</p><ul><li>控制不再转发给代理的首部自担</li><li>管理持久连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: 不再转发的首部字段名</span><br></pre></td></tr></table></figure><p>这条语句就表示指定的首部字段不再转发到下一级服务器（可能是代理）。</p><p><a href="https://github.com/zhongdeming428/MyMemorandum/blob/master/%E5%9B%BE%E8%A7%A3HTTP/pics/httpconn.png"><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf42172df1" alt="httpconn"></a></p><p>除了上面的功能以外，该首部还可以管理持久连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>该指令明确指定断开当前连接。（HTTP/1.1 的所有连接默认都是长连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>以上指令明确指定当前连接为长连接。（适用于 HTTP/1.1 版本之前）</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>该字段表明 HTTP 报文创建的日期和时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure><h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>该字段是 HTTP/1.1 版本的遗留字段，为了向后兼容而定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>功能一致。</p><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>该字段事先说明在报文主体后记录了哪些首部字段，可用于 HTTP/1.1 版本分块传输编码时。</p><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>该首部字段指定了在传输报文主体时所使用的编码方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>该首部字段用于检测 HTTP 协议及其他协议是否可以升级为更高版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>该首部字段是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p><p>报文经过代理或者网关时，会在首部字段 Via 中附加该服务器的信息，然后再进行转发。而且这个字段不仅可以用于追踪报文的转发，还可以避免请求回环发生。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf499ebbc8" alt="httpvia"></p><p>各个代理服务器会向 Via 添加自身服务器的信息。</p><p>其中 <code>1.0</code> 以及 <code>1.1</code> 的开头表示服务器的 HTTP 协议版本。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>该首部自担通常告诉用户一些缓存相关的问题的警告，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</span><br></pre></td></tr></table></figure><h3 id="6-2-4-HTTP-1-1-请求首部字段"><a href="#6-2-4-HTTP-1-1-请求首部字段" class="headerlink" title="6.2.4 HTTP/1.1 请求首部字段"></a>6.2.4 HTTP/1.1 请求首部字段</h3><p>请求首部字段是从客户端发往服务器端时请求报文中所使用的字段。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8</span></span><br></pre></td></tr></table></figure><p>该首部字段可以通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可以使用 <code>type/subtype</code> 的形式一次指定多种媒体类型。</p><p>常用媒体类型：</p><ul><li><p>文本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html,text&#x2F;plain,text&#x2F;css,application&#x2F;xhtml+xml,application&#x2F;xml...</span><br></pre></td></tr></table></figure></li><li><p>图片文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image&#x2F;jpg,image&#x2F;gif,image&#x2F;png...</span><br></pre></td></tr></table></figure></li><li><p>视频文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video&#x2F;mpeg,video&#x2F;quicktime...</span><br></pre></td></tr></table></figure></li><li><p>应用程序使用的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application&#x2F;octet-stream,application&#x2F;zip...</span><br></pre></td></tr></table></figure></li></ul><p>多个协议之间使用逗号分隔，分号之前代表媒体类型，分号之后代表权重。</p><p>当服务器提供多种内容时，会首先返回权重最高的媒体类型。</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5,unicode-1-1;q&#x3D;0.8</span><br></pre></td></tr></table></figure><p>该字段可用来通知服务器用户代理支持的字符集以及字符集的权重。</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br></pre></td></tr></table></figure><p>该字段用来告知服务器用户代理支持的内容编码及内容编码格式的优先级。</p><p>以下是最常用的几个内容编码格式：</p><ul><li><p>gzip</p><p>由文件压缩程序gzip(GNU zip)生成的编码 格式(RFC1952)</p></li><li><p>compress</p><p>由UNIX文件压缩程序compress生成的编码格式</p></li><li><p>deflate</p><p>组和使用zlib格式及有deflate压缩算法生成的编码格式</p></li><li><p>identity</p><p>不执行压缩或者不会变化的默认编码格式</p></li></ul><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>告知服务器能够处理的自然语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-cn,zh;q = <span class="number">0.7</span>, en-us,en; q = <span class="number">0.3</span></span><br></pre></td></tr></table></figure><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>该字段用于告知服务器用户代理的认证信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure><h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect: <span class="number">100</span>-<span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">From: info<span class="meta">@hackr</span>.jp</span><br></pre></td></tr></table></figure><p>该字段用来告知服务器使用用户代理的用户电子邮箱地址</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>很多时候一台服务器上部署了多个网站，对应着多个域名，当 DNS 解析到服务器之后，我们需要知道用户访问的是哪个网址，以便分配到对应的端口给对应的程序进行处理，所以 Host 就用来告知服务器端用户访问的主机名称和端口号。</p><p>Host 首部是唯一一个必须被包含在请求内的首部字段。</p><p>如果服务器未设定主机名，那么发送一个空值即可</p><h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>形如 If-xxx 的请求首部字段，都可以称为条件请求。服务器接收到条件请求之后，只有在判断条件为真时才会执行请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><p>该首部字段属于附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag，后面会讲）值。服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时才会执行请求。反之会返回状态码 412 Precondition Failed 的响应。</p><p>使用 <code>*</code> 时，服务器会匹配任意的 ETag 值。</p><h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p>该首部字段指定一个时间点，如果在该时间点之后有修改过资源，则会响应请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Thu, <span class="number">15</span> Apr <span class="number">2004</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> GMT </span><br></pre></td></tr></table></figure><p>如果在这个时间点之后没有修改过资源，则返回304 Not Modified状态码的响应</p><h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>该字段与If-Match的作用相反。当该字段的值不匹配资源的ETag时才会响应请求。</p><h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p>该字段的值若是跟 ETag 的值或更新的日期时间相匹配，那么就作为范围请求处理；如果无法匹配的话就返回全体资源。</p><h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure><p>该首部字段和 <code>If-Modified-Since</code> 作用相反，它的作用是告知服务器指定的资源只有在指定日期之后没有发生变更的情况下才处理请求，否则就返回 412 Precondition Failed 状态码。</p><h4 id="Max-Forward"><a href="#Max-Forward" class="headerlink" title="Max-Forward"></a>Max-Forward</h4><p>通过 TRACE 方法或者 OPTIONS 方法发送包含首部字段 Max-Forward 的请求时，该字段以十进制整数形式指定可经过的服务器的最大数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Forward: <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwObjkNLAGFfY5</span><br></pre></td></tr></table></figure><p>该字段告知服务器认证所需要的的信息。该认证行为发生在客户端与代理服务器之间。</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes = <span class="number">5001</span>-<span class="number">10000</span></span><br></pre></td></tr></table></figure><p>该字段适用于只获取部分资源的范围请求，他告知了服务器所需要的服务器资源的指定范围。</p><p>接收到携带该字段请求的服务器返回状态码为206  Partil Content的响应，如果无法处理该范围请求，则服务器会返回状态码为220 OK的响应以及全部资源。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http:<span class="comment">//www.hackr.jp/index.htm</span></span><br></pre></td></tr></table></figure><p>该首部字段告知服务器请求的原始资料的URI</p><h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip,deflate;q=<span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>该字段会告知服务器客户端能够处理的响应传世编码方式及相对的优先级，其功能和Transfer-Enconding的功能相似。</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko&#x2F;20100101 Firefox&#x2F;13.0.1</span><br></pre></td></tr></table></figure><p>该字段会将创建请求的浏览器和用户代理名称的相关信息发送给服务器。当爬虫发起请求时，有可能会在该字段添加作者的地址。</p><p>值得一提的是有些网站会做出反爬虫策略，他们会验证 User-Agent 字段是否来自于浏览器，如果不是的话就会拒绝爬虫的请求；所以如果要想继续拿到想要的信息的话就会通过该字段将爬虫伪造成浏览器。</p><h3 id="6-2-4-HTTP-1-1-响应首部字段"><a href="#6-2-4-HTTP-1-1-响应首部字段" class="headerlink" title="6.2.4 HTTP/1.1 响应首部字段"></a>6.2.4 HTTP/1.1 响应首部字段</h3><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求信息等。</p><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p>该字段用于告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。当服务器能够处理客户端的范围请求时，其值为 bytes，反之为 none。</p><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aag: 600</span><br></pre></td></tr></table></figure><p>该首部字段告知客户端<strong>源服务器</strong>在多久之前创建了响应，字段的值的单位为秒。</p><p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到再次认证完成的时间值。</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure><p>首部字段 ETag 能告知客户端实体标志。它是一种能够将资源以字符串形式做唯一性标志的方式。服务器会为每份资源分配对应的 ETag 值。</p><p>当资源更新时，ETag 值也要更新。完成 ETag 值时，并没有统一的算法规则，仅仅由服务器分配。</p><p>访问某个资源的 URI 一般不会发生改变，但是当资源本身发生了变化时，资源对应的 ETag 也会更新。</p><p><strong>强 ETag 和弱 ETag</strong></p><p>ETag 值有强弱之分，强 ETag 值不管资源发生多么细微的变化都会随之变化，而弱 ETag 值只有在资源发生了根本改变并产生差异时才会发生变化。</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Location</span>: http://www.usagidesign.jp/sample.html</span><br></pre></td></tr></table></figure><p>该首部字段可以将接受响应的客户端引导到某一个与其请求 URI 位置不同的资源。</p><p>基本上该字段会配合 3xx 重定向状态码一起使用。</p><h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>该首部字段会把代理服务器所要求的认证信息发送给客户端。</p><h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry After"></a>Retry After</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Retry-After：120</span></span><br></pre></td></tr></table></figure><p>该首部字段告知客户端在多久之后再次发起请求。该字段可以指定为具体的时间或者创建响应后的秒数。</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>该首部字段会告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</span><br></pre></td></tr></table></figure><h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Vary</span>: Accept-Language</span><br></pre></td></tr></table></figure><p>该首部字段可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p><p>具体来说，该首部字段会指定一个其他的首部字段，比如上面的 Accept-Encoding，当指定字段的值未发生变化时，则使用缓存资源；如果指定字段的值发生了变化时，则需要向源服务器请求最新的资源。</p><p>这个字段可以指定 User-Agent，防止移动端浏览器访问页面时访问了 PC 端页面的缓存。</p><p>当该字段指定为 <code>*</code> 时，所有的请求都会被视为唯一的并且会被缓存。</p><h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>该首部字段用于 HTTP 访问认证。</p><h3 id="6-2-4-HTTP-1-1-实体首部字段"><a href="#6-2-4-HTTP-1-1-实体首部字段" class="headerlink" title="6.2.4 HTTP/1.1 实体首部字段"></a>6.2.4 HTTP/1.1 实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间和实体相关的信息。</p><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Allow：GET，HEAD</span></span><br></pre></td></tr></table></figure><p>该首部字段用于通知客户端服务器能够支持的 HTTP 方法，当服务器接收到不支持的请求方法时，会返回 405 Not Allowed 状态码。</p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding：gzip</span></span><br></pre></td></tr></table></figure><p>该首部字段会告知客户端对实体的主体部分所使用的内容编码格式。</p><p>具体编码格式可以参考 2.5.3 Accept-Encoding。</p><h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language； zh-CN</span><br></pre></td></tr></table></figure><p>该首部字段用于通知客户端实体主体所使用的自然语言。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length：15000</span></span><br></pre></td></tr></table></figure><p>该首部字段表明了实体主体的大小（单位是字节）。</p><p>如果对实体主体采用了内容编码传输时，不能再使用 Content-Length 首部字段。</p><h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Location：http://www.hackr.jp/index-ja.html</span></span><br></pre></td></tr></table></figure><p>该首部字段给出与报文主体相对应的 URI。当返回的页面内容与请求的实际对象不相同时，首部字段 Content-Location 会写明 URI。</p><h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure><p>客户端会对接收到的报文主体采用 MD5 算法进行散列计算，然后与 Content-MD5 的值进行比较以对接收到的主体内容进行完整性校验。</p><p>散列算法进行计算的做法主要用于防止传输内容被篡改，因为同一个输入通过散列算法计算以后得到的结果是相同的，不同的输入经过散列算法计算之后得到的结果基本不会重复。这也是许多提供资源下载的网站同时会给出资源对应 HASH 值的原因。</p><p>但是 Content-MD5 并不可靠，因为如果传输主体的内容可以被修改的话，Content-MD5 的值同样也可能被修改过，所以并不可靠。为了确保资源不被篡改，最好还是使用 HTTPS。</p><h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure><p>针对范围请求，该首部字段告知客户端返回的响应的实体的哪些部分符合范围请求，单位为字节。</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>该首部字段说明了实体主体内的媒体类型。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><p>该首部字段将资源失效的日期告知客户端。</p><p>当首部字段 Cache-Control 有指定 max-age 指令时，会优先处理 max-age 指令。</p><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure><p>该首部字段指明了资源的最终修改时间。</p><h3 id="Cookie-服务的首部字段"><a href="#Cookie-服务的首部字段" class="headerlink" title="Cookie 服务的首部字段"></a>Cookie 服务的首部字段</h3><p><strong>Cookie 的工作机制是用户识别及状态管理</strong>。</p><p>为 cookie 服务的首部字段：</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的 Cookie 信息</td><td>请求首部字段</td></tr></tbody></table><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><p>当服务器开始准备管理客户端的状态时，会实现告知各种信息。</p><p>下面的表格列举了 Set-Cookie 的字段值。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予 Cookie 的键和对应值</td></tr><tr><td>expires=DATE</td><td>Cookie 的有效期</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）</td></tr><tr><td>domain=域名</td><td>作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td></tr><tr><td>Secure</td><td>仅在 HTTPS 安全通信时才发送 Cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使 Cookie 不能被 JavaScript 所访问</td></tr></tbody></table><p>下面详细讲讲 Cookie 的各个属性。</p><ul><li><p><code>expires</code>：该属性指定浏览器可以发送 Cookie 的有效期。当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器关闭之前。</p><p>另外需要注意的是一旦 Cookie 从服务器端发送到客户端，服务器端就不存在可以显式删除 Cookie 的方法。只能通过覆盖已有的 Cookie 来达到删除的目的。</p></li><li><p><code>path</code>：该属性用于限定指定 Cookie 的发送范围的文件目录。但是有其他办法可以避开这个限制，所以不要对它抱有太大期望。</p></li><li><p><code>domain</code>：该属性的域名可做到与结尾匹配一致，比如指定 domain 为 example.com，此时 <a href="http://www.example.com/">www.example.com</a> 和 www2.example.com 也都可以访问 Cookie。所以不指定域名的情况下更加安全，因为默认只有当前响应的服务器的域名可以访问 Cookie。</p></li><li><p><code>secure</code>：该属性限制 Web 页面仅在 HTTPS 安全连接时才发送 Cookie。当省略该属性时，HTTP 和 HTTPS 协议的指定域名都可以访问 Cookie。</p></li><li><p><code>HttpOnly</code>：该属性使得 JavaScript 无法对 Cookie 进行读取操作。</p></li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie：status=enable</span><br></pre></td></tr></table></figure><p>首部字段 Cookie 会告知服务器，当客户端想要获得 HTTP 状态管理的支持时，就会在请求中包含从服务器中获取到的 Cookie。</p><h3 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h3><p>HTTP 首部字段是可以自行扩展的，所以在 Web 服务器和浏览器的应用上，会出现一些非标准的首部字段。</p><p>下面是比较常用的非标准首部字段：</p><ul><li>X-Frame-Options</li><li>X-XSS-Protection</li><li>DNT</li><li>P3P</li></ul><h4 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Frame-Options</span>: DENY</span><br><span class="line">此处的 Frame 包括 iframe、frame、object 等标签</span><br></pre></td></tr></table></figure><p>该首部字段属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是防止点击劫持攻击（clickjacking）。</p><p>该字段可以指定三类值：</p><ul><li><code>DENY</code>：拒绝被嵌套到 Frame，即使是相同域名下的页面也不行</li><li><code>SAMEORIGIN</code>：该页面只可以被嵌入到相同域名页面的 Frame 中</li><li><code>ALLOW-FROM uri</code>：表示可以在指定来源的页面中被嵌套</li></ul><h4 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h4><p>该字段属于响应首部，是针对跨域脚本攻击的一种策略，用于控制浏览器 XSS 防护机制的开关。</p><p>该字段可以设置一下了两个值：</p><ul><li>0：将 XSS 过滤设置成无效状态</li><li>1：将 XSS 过滤设置成有效状态</li></ul><h4 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">DNT：1</span></span><br></pre></td></tr></table></figure><p>该首部字段属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，表示拒绝个人信息被收集。</p><p>0 表示同意被追踪，1 表示拒绝被追踪。</p><h4 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h4><p>该首部字段属于响应首部，通过利用 P3P 技术让网站上的个人隐私变成仅供程序可理解的形式。</p><h1 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h1><h2 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h2><p>HTTP在通信过程中会面临以下三种安全问题：</p><ul><li>通信使用明文（不加密），内容可能会被监听</li><li>不验证通信方的身份，可能会遭遇伪装</li><li>无法验证报文的完整性，可能已经被篡改</li></ul><p><strong>谷歌浏览器强制要求https</strong></p><h3 id="7-1-1-窃听"><a href="#7-1-1-窃听" class="headerlink" title="7.1.1 窃听"></a>7.1.1 窃听</h3><p>HTTP本身不具备加密功能，所以传输的过程中都是以明文 方式发送</p><p>由于在网络的传输过程中，我们所发送的信息要 经过许多的网络节点和设备，在这个过程中这些设备是可能会拦截我们的信息并且进行窃听的，直接通过一些常用的抓包工具就可以窃听未加密的网络传输信息。</p><p><strong>通过加密防止窃听</strong></p><ul><li><p><strong>通信的加密</strong>  为了防止传输内容被窃听，我们采取的方式之一就是通信加密，HTTP本身没有加密机制，但是我们可以通过将HTTP和SSL（Secure Socket Layer 安全套接层） 或者 TLS（Transport Layer Security 安全传输协议）组和使用来加密传输内容。</p><p>用 SSL 建立安全通信线路以后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure）</p></li><li><p><strong>内容的加密</strong>  还有一种方式就是将参与通信的内容本身进行加密。这样的话就需要客户端对HTTP报文加密后再请求发送。由于该方式不同于HTTPS将整个通信线路加密的方式，所以内容仍然会有被篡改的风险。</p></li></ul><h3 id="7-1-2-伪装"><a href="#7-1-2-伪装" class="headerlink" title="7.1.2 伪装"></a>7.1.2 伪装</h3><p>HTTP 协议本身并不会对通信的另一方进行身份验证，所以任何人都能对服务器发起请求。</p><p>不验证通信方可能就会存在各种安全隐患：</p><ul><li>客户端无法确认自己的请求是否发送到了目标服务器或者返回响应的服务器是否是目标服务器，有可能是伪装了的服务器。</li><li>服务器无法确认向自己发起请求的客户端以及自己返回响应的客户端是否是目标中的客户端。</li><li>无法确认通信方是否具备访问权限，因为某些服务器只想给特定的用户访问。</li><li>即使是无意义的请求也会照单全收，使得服务器可能遭受到 DDoS 攻击。</li></ul><p><strong>通过查明对方证书来防止伪装</strong></p><p>SSL不仅提供加密处理，而且使用了一种称为证书的手段，可用于确认对方身份。</p><p><strong>证书由第三方机构颁发，用以证明服务器的客户端是实际存在的。</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38aa5f65f" alt="httpcert"></p><p>通过使用证书可以证明通信方就是意料中的服务器。对使用者而言，也减少了个人信息泄露的风险。</p><p>另外，客户端持有证书即可完成个人身份的认证，也可用于对网站的认证环节。</p><h3 id="7-1-3-篡改"><a href="#7-1-3-篡改" class="headerlink" title="7.1.3 篡改"></a>7.1.3 篡改</h3><p>HTTP协议通常无法确认信息的完整性，一旦传输的信息被篡改，那么信息就失去了准去性，导致信息有误。比如你想在某一个网站的下载一个资源，而你的资源传输已经被被人劫持，在你发起下载请求的时候，你所接收到的资源正在被人修改，所以你下载到的资源就不是你想要的那个了。</p><p>像这样，请求或者响应在传输途中遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack, MitM）。</p><p><strong>如何防止篡改</strong></p><p>之前的章节有提到过Content-MD5 实体首部字段可用于确认实体内容是否完整，但是由于Content-MD5本身的值也有可能被篡改，所以这个字段并不可靠，所以需要其他方法来确保传输的内容不被篡改。</p><p>通过其他散列算法来计算传输内容是否完整也不可靠，那么我们最终还是需要HTTPS来帮我解决这个问题。SSL提供认证和加密处理以及<strong>摘要功能</strong>。</p><h2 id="7-2-HTTPS"><a href="#7-2-HTTPS" class="headerlink" title="7.2 HTTPS"></a>7.2 HTTPS</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPS = HTTP + 加密 + 认证 + 摘要</span><br></pre></td></tr></table></figure><h3 id="7-2-1-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-1-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.1 HTTPS是身披SSL外壳的HTTP"></a>7.2.1 HTTPS是身披SSL外壳的HTTP</h3><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 的时候，就先和 SSL 通信，再由 SSL 和 TCP 通信了。所以简而言之，HTTPS 就是身披 SSL 外壳的 HTTP 协议。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38ab5952f" alt="https"></p><p>在采用 SSL 以后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护功能了。</p><p>SSL 协议是独立于 HTTP 的协议，所以其他协议也可以采用 SSL 协议，它是当今世界上应用最广泛的网络安全技术</p><h3 id="7-2-2-相互交换秘钥的公开秘钥加密技术"><a href="#7-2-2-相互交换秘钥的公开秘钥加密技术" class="headerlink" title="7.2.2 相互交换秘钥的公开秘钥加密技术"></a>7.2.2 相互交换秘钥的公开秘钥加密技术</h3><p>在将SSL之前可以了解一下加密技术，SSL采用一种叫做公开秘钥加密（Public-key Cryptography）的加密处理技术。</p><p>近代的加密方法中，加密算法是公开的，但是秘钥是保密的。加密和解密都会用到秘钥。没有秘钥无法对秘钥进行解密。反过来说没任何人只要拿到秘钥就可以解密信息。如果秘钥被攻击者获得，那加密就失去了意义</p><ul><li><p><strong>共享密钥加密的困境</strong></p><p><strong>加密和解密使用同一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密</strong>。</p><p>采用共享密钥加密方式加密时，需要将密钥一起发送给通信方，所以有需要考虑密钥传输的安全性，需要设法安全地保管密钥，这便是共享密钥加密方式的困扰。</p></li><li><p><strong>使用两把秘钥加密的公开秘钥加密方式</strong></p><p>公开密钥加密方式很好的解决了共享密钥加密方式的困扰。</p><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能被其他任何人知道，而公开密钥则可以仁任意传播，任何人都可以拿到。</p><p>使用公开密钥加密方式（非对称加密），发送密文的一方使用公钥进行加密处理，而接收方拿到被加密后的信息之后再使用自己的私钥进行解密。利用这种方式进行传输，就不需要发送密钥，也就不用担心密钥被攻击者拿走了。</p></li><li><p><strong>HTTPS采用混合加密机制</strong></p><p>HTTPS采用共享秘钥加密方式和公开秘钥加密方式混合的加密方式。</p><p>如果秘钥可以被安全传输，则HTTPS会考虑采用共享加密方式，否则将采用公开秘钥加密方式。这是因为公开密钥加密方式的速度比共享密钥加密方式要慢。HTTPS充分地利用了两者的有点，将多种方法组合起来用于通信。<strong>在使用公开密钥加密方式交换密钥之后，之后的信息传输使用共享密钥加密方式</strong>。</p></li></ul><h3 id="7-2-3-证明公开密钥正确性的证书"><a href="#7-2-3-证明公开密钥正确性的证书" class="headerlink" title="7.2.3 证明公开密钥正确性的证书"></a>7.2.3 证明公开密钥正确性的证书</h3><p>遗憾的是公开密钥加密方式本身也是有缺陷的，那就是无法证明公开的密钥本身是货真价实的。</p><p>为了解决上面说到的问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机构颁发的公开密钥证书。</p><p>数字证书认证机构处于客户端与服务端双方都信赖的第三方机构的立场上，威瑞新（VeriSign）就是其中一家非常有名的数字证书认证机构。</p><p>下面讲解一下数字证书认证机构的业务流程：</p><p>首先，服务器的运营人员会向数字机构提出公开密钥申请，CA 在认证申请者的身份信息之后，会对已申请的公开密钥进行数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书之后绑定在一起。</p><p>服务器会将这份 CA 颁发的公钥证书发送给客户端，以进行公钥加密方式通信，公钥证书也可叫做数字证书或者直接称为证书。</p><p>接到证书的客户端可使用 CA 的公钥对证书的数字签名进行认证，一旦验证通过，客户端便可确认两件事：</p><ul><li>认证服务器公钥的机构是真实有效的 CA 机构</li><li>服务器的公钥是值得信任的</li></ul><p>于是这就达到了确认公钥真实有效性的目的。</p><p>安全地转交 CA 机构的密钥给客户端是一件困难的事，因此多数浏览器会在内部植入常用认证机构的公钥。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd850947bf0" alt="httpskey"></p><ul><li><p>可证明组织真实性的 EV SSL 证书</p><p>证书的一个作用是证明作为通信一方的服务器是否符合规范，另一个作用是确认服务器运营商企业是否真实存在。能够证明企业真实性的正式就是 EV SSL 证书（Extended Validation SSL Certificate）。</p><p>该证书的目的是为了防止钓鱼攻击（Phishing）。</p></li><li><p>用以确认客户端的客户端证书</p><p>HTTPS 中还可以使用客户端证书对客户端进行认证。</p></li></ul><h2 id="7-4-HTTPS的安全通信机制"><a href="#7-4-HTTPS的安全通信机制" class="headerlink" title="7.4 HTTPS的安全通信机制"></a>7.4 HTTPS的安全通信机制</h2><p>为了更好的理解 HTTPS，我们来观察一下 HTTPS 的通信步骤。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-3badd05d6f7e3d84.png" alt="img"></p><ul><li>步骤1：客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li><li>步骤2：服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>步骤3：之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li><li>步骤4：最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</li><li>步骤5：SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li><li>步骤6：接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret密钥加密。</li><li>步骤7：客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>步骤8：服务器同样发送 Change Cipher Spec 报文。</li><li>步骤9：服务器同样发送 Finished 报文。</li><li>步骤10：服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完毕。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</li><li>步骤11：应用协议通信，即发送 HTTP 响应。</li><li>步骤12：最后由客户端断开连接。断开连接时，发送 close_notify 报文。</li></ul><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><p>下面是对整个流程的图解。图中说明了从仅适用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022150748120.png" alt="image-20201022150748120"></p><h3 id="SSL-速度慢吗"><a href="#SSL-速度慢吗" class="headerlink" title="SSL 速度慢吗"></a>SSL 速度慢吗</h3><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p><p>SSL 的慢是分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p><p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求/响应外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。</p><p>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。</p><p>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。</p><h3 id="为什么不一直使用-HTTPS"><a href="#为什么不一直使用-HTTPS" class="headerlink" title="为什么不一直使用 HTTPS"></a>为什么不一直使用 HTTPS</h3><ol><li>因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量也必然减少。因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。</li><li>除此之外，想要节约购买证书的开销也是原因之一。</li></ol><h1 id="8-确认访问用户身份的认证"><a href="#8-确认访问用户身份的认证" class="headerlink" title="8. 确认访问用户身份的认证"></a>8. 确认访问用户身份的认证</h1><h2 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h2><p>计算机本身无法判断坐在显示器前的使用者的身份，为了确认是谁在访问服务器，需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。核对的信息通常是指以下这些：</p><ul><li>密码：只有本人才会知道的字符串信息。</li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。</li><li>数字证书：仅限本人（终端）持有的信息。</li><li>生物认证：指纹和虹膜等本人的生理信息</li><li>IC 卡等：仅限本人持有的信息。</li></ul><p> <strong>HTTP/1.1 使用的认证方式如下所示：</strong></p><ul><li>BASIC认证（基本认证）</li><li>DIGEST认证（摘要认证）</li><li>SSL 客户端认证</li><li>FormBase 认证（基于表单认证）</li></ul><h2 id="8-2-BASIC-认证"><a href="#8-2-BASIC-认证" class="headerlink" title="8.2 BASIC 认证"></a>8.2 BASIC 认证</h2><p>BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022151634964.png" alt="image-20201022151634964"></p><p>步骤1：当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm）。</p><p>步骤2：接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（：）连接后，再经过 Base64 编码处理。将编码后的字符串写入首部字段 Authorization 后，发送请求。</p><p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。</p><p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解密。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。</p><p>另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。</p><p>BASIC 认证使用上不够灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。</p><h2 id="8-3-DIGEST-认证"><a href="#8-3-DIGEST-认证" class="headerlink" title="8.3 DIGEST 认证"></a>8.3 DIGEST 认证</h2><p>为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。DIGEST 认证同样使用质询/响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。</p><p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的咨询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-bb8255a4cfc8db60.png" alt="img"></p><p>因为发送给对方的只是响应摘要及由知讯码产生的计算结果，所以比起 BASIC 认证，密码泄露的可能性就降低了。</p><ul><li>DIGEST 认证的认证步骤</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-37e273e40111f18a.png" alt="img"></p><p>步骤1：请求需认证的资源时，服务器会随着状态码 401 Authorication Required，返回带  WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需要的临时咨询码（随机数，nonce）。</p><p>首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。</p><p>nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现</p><p>步骤2：接收到401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息，其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。</p><p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则会返回包含 Request-URI 资源的响应。</p><p>并且这时会在首部字段 Authorization-Info 写入一些认证成功的相关信息。</p><h2 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h2><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自登录的客户端。</p><ul><li>SSL 客户端认证的认证步骤</li></ul><p>为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。</p><p>步骤1：接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</p><p>步骤2：用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p><p>步骤3：服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</p><ul><li>SSL 客户端认证采用双因素认证</li></ul><p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p><p>换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。</p><ul><li>SSL 客户端认证必要的费用</li></ul><p>使用 SSL 客户端认证需要用到客户端证书，而客户端证书需要支付一定费用才能使用。</p><h2 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h2><p>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果认证。</p><p>多数情况下，输入已事先登录的用户 ID 和密码等登录信息后，发送给 Web 应用程序，基于认证结果来决定认证是否成功。</p><h4 id="8-5-1-Session-管理及-Cookie-应用"><a href="#8-5-1-Session-管理及-Cookie-应用" class="headerlink" title="8.5.1 Session 管理及 Cookie 应用"></a>8.5.1 Session 管理及 Cookie 应用</h4><p>第八章要讲的内容不多，所以把最重要的一点挪到了这一篇笔记。</p><p>关于用户身份的认证，现在多数是采用表单认证，一般会采用 Cookie 来管理 Session（会话）。</p><p>大致流程如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38ab3ca24" alt="httpsession"></p><p>具体步骤如下：</p><ul><li>客户端把用户的 ID 密码等登录信息放入报文的实体部分，通常用 POST 方法发送至服务器端。</li><li>服务器生成并发放用来识别客户的 Session ID，这个 Session ID 同时会在服务器端保存，然后通过 Set-Cookie 字段绑定到客户端。顺便可以使用 <code>httponly</code> 属性来禁止 JavaScript 修改 Cookie，防止跨站脚本攻击。</li><li>客户端把 Session ID 保存在本地 Cookie，下次访问时再带上。服务器端通过验证接收到的 Session ID 来识别用户，从数据库中可以顺便取到与用户相关的一系列信息。</li></ul><h1 id="9-基于-HTTP-的功能追加协议"><a href="#9-基于-HTTP-的功能追加协议" class="headerlink" title="9.基于 HTTP 的功能追加协议"></a>9.基于 HTTP 的功能追加协议</h1><h2 id="9-1-基于-HTTP-的协议"><a href="#9-1-基于-HTTP-的协议" class="headerlink" title="9.1 基于 HTTP 的协议"></a>9.1 基于 HTTP 的协议</h2><p>HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。</p><h2 id="9-2-消除-HTTP-瓶颈的-SPDY"><a href="#9-2-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="9.2 消除 HTTP 瓶颈的 SPDY"></a>9.2 消除 HTTP 瓶颈的 SPDY</h2><p>Google 在 2010 年发布了 SPDY，其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p><h3 id="9-2-1-HTTP-的瓶颈"><a href="#9-2-1-HTTP-的瓶颈" class="headerlink" title="9.2.1 HTTP 的瓶颈"></a>9.2.1 HTTP 的瓶颈</h3><p>HTTP 存在以下缺点和不足：</p><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收除响应以外的指令</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制压缩发送</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154013733.png" alt="image-20201022154013733"></p><ol><li>Ajax 的解决办法</li></ol><p>Ajax 是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少。</p><p>而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154032725.png" alt="image-20201022154032725"></p><ol><li>Comet 的解决办法<br> 一旦服务器有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延时应答，模拟实现服务器向客户端推送的功能。</li></ol><p>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154055953.png" alt="image-20201022154055953"></p><h3 id="9-2-2-SPDY-的设计与功能"><a href="#9-2-2-SPDY-的设计与功能" class="headerlink" title="9.2.2 SPDY 的设计与功能"></a>9.2.2 SPDY 的设计与功能</h3><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p><p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法，Cookie 以及 HTTP 报文等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154125271.png" alt="image-20201022154125271">spdy.png</p><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><ul><li>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</li><li>赋予请求优先级：SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li>压缩 HTTP 首部：压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了</li><li>推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</li><li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。</li></ul><h3 id="9-2-3-SPDY-消除-Web-瓶颈了吗"><a href="#9-2-3-SPDY-消除-Web-瓶颈了吗" class="headerlink" title="9.2.3 SPDY 消除 Web 瓶颈了吗"></a>9.2.3 SPDY 消除 Web 瓶颈了吗</h3><p>因为 SPDY 基本上只是将多个域名（IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会收到限制。</p><h2 id="9-3-使用浏览器进行全双工通信的-WebSocket9"><a href="#9-3-使用浏览器进行全双工通信的-WebSocket9" class="headerlink" title="9.3 使用浏览器进行全双工通信的 WebSocket9"></a>9.3 使用浏览器进行全双工通信的 WebSocket9</h2><p>WebSocket 是为解决 HTTP 协议所面临的困难的一种新的协议及 API。</p><h3 id="9-3-1-WebSocket-的设计与功能"><a href="#9-3-1-WebSocket-的设计与功能" class="headerlink" title="9.3.1 WebSocket 的设计与功能"></a>9.3.1 WebSocket 的设计与功能</h3><p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。</p><h3 id="9-3-2-WebSocket-协议"><a href="#9-3-2-WebSocket-协议" class="headerlink" title="9.3.2 WebSocket 协议"></a>9.3.2 WebSocket 协议</h3><p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可相互发送 JSON、XML、HTML 或图片等任意格式的数据。</p><p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p><p>下面我们列举一下 WebSocket 协议的主要特点：</p><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应较少了。</li></ul><p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次 “握手” 的步骤。</p><ol><li>握手·请求<br> 为了实现 WebSocket 通信，需要用到 HTTP 的 <code>Upgrade</code> 首部字段，告知服务器通信协议发送改变，已达到握手的目的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“GET /chat HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span>”</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Protocol</code> 字段内记录着握手过程中必不可少的键值，<code>Sec-WebSocket-Protocol</code> 字段内记录使用的子协议。</p><p>子协议按 <code>WebSocket</code> 协议标准在连接分开使用时，定义那些连接的名称。</p><ol><li>握手·响应<br> 对于之前的请求，返回状态码 <code>101 Switching Protocols</code> 的响应。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat”</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Accept</code> 的字段值是由握手请求中的 <code>Sec-WebSocket-Accept</code> 的字段值生成的。</p><p>成功握手确立 <code>WebSocket</code> 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154245807.png" alt="image-20201022154245807"></p><h2 id="9-4-期盼已久的-HTTP-2-0"><a href="#9-4-期盼已久的-HTTP-2-0" class="headerlink" title="9.4 期盼已久的 HTTP/2.0"></a>9.4 期盼已久的 HTTP/2.0</h2><p>HTTP/2.0 在 2014 年 11 月实现标准化。</p><ul><li>HTTP/2.0 的特点<br> HTTP/2.0 的目标是改善用户在使用 Web 时的速断体验。</li></ul><p>HTTP/2.0 围绕着主要的 7 项技术进行讨论。</p><table><thead><tr><th align="center">压缩</th><th align="center">SPDY、Friendly</th></tr></thead><tbody><tr><td align="center">多路复用</td><td align="center">SPDY</td></tr><tr><td align="center">TLS 义务化</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">协商</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">客户端拉拽</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">流量控制</td><td align="center">SPDY</td></tr><tr><td align="center">WebSocket</td><td align="center">Speed + Mobility</td></tr></tbody></table><h1 id="11-常见的Web攻击技术"><a href="#11-常见的Web攻击技术" class="headerlink" title="11.常见的Web攻击技术"></a>11.常见的Web攻击技术</h1><h2 id="11-1-跨站脚本攻击"><a href="#11-1-跨站脚本攻击" class="headerlink" title="11.1 跨站脚本攻击"></a>11.1 跨站脚本攻击</h2><p>跨站脚本攻击(Cross-Site Scripting , XSS) 是指通过存在安全漏洞的web网站注册用户的浏览器运行非法的HTML标签或者JavaScrip代码的一种攻击方式。动态创建的HTML可能存在安全漏洞。</p><p>该攻击可能造成以下影响：</p><ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li><li>显示伪造的文章或者图片</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bf024b37126" alt="xss"></p><p>上图的表单输入以后直接把输入内容当做 HTML 展示在页面上，所以存在着安全漏洞，攻击者可以直接在输入框内编辑危险的代码，然后就会在页面上运行。</p><h2 id="11-2-SQL-注入攻击"><a href="#11-2-SQL-注入攻击" class="headerlink" title="11.2 SQL 注入攻击"></a>11.2 SQL 注入攻击</h2><p>SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的安全威胁，有时会直接导致个人信息及机密信息的泄露。</p><p>SQL 注入可能会导致如下影响：</p><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><p>如果我们不对输入进行验证就直接拿去拼接 SQL 的话，是可能会被执行 SQL 注入攻击的。</p><h2 id="11-3-目录遍历攻击"><a href="#11-3-目录遍历攻击" class="headerlink" title="11.3 目录遍历攻击"></a>11.3 目录遍历攻击</h2><p>目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也被叫做路径遍历攻击（Path Traversal）。</p><h2 id="11-4-会话劫持"><a href="#11-4-会话劫持" class="headerlink" title="11.4 会话劫持"></a>11.4 会话劫持</h2><p>会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</p><p>具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理认证状态的主流方式。会话 ID 中记录客户端的 Cookie 等信息，服务器端将会话 ID 与认证状态进行一对一匹配管理。</p><p>攻击者可能通过以下方式获得会话 ID：</p><ul><li>通过非正规的生成方法推测会话 ID</li><li>通过窃听或 XSS 攻击盗取会话 ID</li><li>通过会话固定攻击（Session Fixation）强行获取会话 ID</li></ul><p>通常情况下攻击者在发现网站存在的 XSS 攻击漏洞之后，会注入一段 JavaScript 代码，通过 <code>document.cookie</code> 盗取到会话 ID，之后植入到自己的浏览器，就可以伪装成被盗窃的用户访问被攻击的网站。</p><h2 id="11-5-跨站点请求伪造"><a href="#11-5-跨站点请求伪造" class="headerlink" title="11.5 跨站点请求伪造"></a>11.5 跨站点请求伪造</h2><p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</p><p>最常见的例子就是在一个需要登录才能进行操作的网站，攻击者在该网站伪造了一个可以触发危险操作的内容（比如 a 和 button 标签），用户在不经意间点击这些伪造的内容后就自动发起了请求，而这些请求如果是指向当前网站的话，用户的会话 ID 等信息也会被带上，使得被攻击者不经意之间完成了一次可能极为危险的操作。</p><h2 id="11-6-点击劫持"><a href="#11-6-点击劫持" class="headerlink" title="11.6 点击劫持"></a>11.6 点击劫持</h2><p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱导用户在不知情的情况下点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</p><p>这种攻击最常见的案例就是某些小网站……</p><h2 id="11-7-DoS-攻击"><a href="#11-7-DoS-攻击" class="headerlink" title="11.7 DoS 攻击"></a>11.7 DoS 攻击</h2><p>DoS 攻击（Denial of Service Attack）是一种让运行中的服务呈停止状态的攻击。有时也叫作停止服务攻击或者拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。</p><p>DoS 主要有以下两种攻击方式：</p><ul><li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态</li><li>通过攻击安全漏洞是服务停止</li></ul><p>由此可见所有使得服务停止的攻击都可以称为 DoS 攻击。</p><p>DoS 攻击在中国前端届比较著名的案例就是阮一峰老师的博客遭到过的一次攻击：<a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html">DDOS 攻击的防范教程</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-HTTP首部&quot;&gt;&lt;a href=&quot;#6-HTTP首部&quot; class=&quot;headerlink&quot; title=&quot;6. HTTP首部&quot;&gt;&lt;/a&gt;6. HTTP首部&lt;/h1&gt;&lt;h2 id=&quot;6-1-HTTP报文首部&quot;&gt;&lt;a href=&quot;#6-1-HTTP报文首部&quot; c</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://leslieaibin.github.io/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-（1-5章）</title>
    <link href="https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%881-5%E7%AB%A0%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%881-5%E7%AB%A0%EF%BC%89/</id>
    <published>2020-10-29T12:15:42.000Z</published>
    <updated>2020-10-30T08:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-了解Web及网络基础"><a href="#1-了解Web及网络基础" class="headerlink" title="1.了解Web及网络基础"></a>1.了解Web及网络基础</h1><h2 id="1-1-Web基于HTTP通信"><a href="#1-1-Web基于HTTP通信" class="headerlink" title="1.1 Web基于HTTP通信"></a>1.1 Web基于HTTP通信</h2><p>​        Web使用一种名为HTTP（HyperText Transfer Protocol,超文本传输协议，“超文本转义协议”）的协议作为规范，完成从客户端到服务端等一系列运作流程。而协议是规则的约定。可以说，Web是建立在HTTP协议上通信的。</p><h2 id="1-2-HTTP的诞生"><a href="#1-2-HTTP的诞生" class="headerlink" title="1.2 HTTP的诞生"></a>1.2 HTTP的诞生</h2><h3 id="1-2-1-HTTP的诞生"><a href="#1-2-1-HTTP的诞生" class="headerlink" title="1.2.1 HTTP的诞生"></a>1.2.1 HTTP的诞生</h3><p>​        这一节主要讲 HTTP 的诞生背景，了解 HTTP 协议的诞生背景有利于我们学习理解 HTTP 协议。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201015235336.webp" alt="httpbackground"></p><p>​        HTTP起初的诞生是为了知识共享，最初的设想是借助多文档之间的相互关联行程超文本，连成可相互参阅的WWW（word wide Web,万维网）</p><p>​        现在已经提出了三项构建技术：</p><ul><li>把SGML,即Standard Generalized Markup Language(标准通用标记语言)作为页面的文本标记语言的HTML(HyperText Markup Language,超文本标记语言)</li><li>作为文本传输协议的HTTP</li><li>指定文档所在地址的URL（Uniform Resource Location,统一资源定位符）</li></ul><p>可以看出上面的三项分别构成只是共享的内容（HTML)、知识共享的方式（HTTP传输）和知识共享位置。</p><h3 id="1-2-2-发展缓慢的HTTP"><a href="#1-2-2-发展缓慢的HTTP" class="headerlink" title="1.2.2 发展缓慢的HTTP"></a>1.2.2 发展缓慢的HTTP</h3><p><strong>HTTP/0.9</strong></p><p>​        HTTP诞生于<strong>1990年</strong>，此时还没有正式的标准，此时的HTTP含有HTTP/1.0之前版本的意思所以称为HTTP/0.9</p><p><strong>HTTP/1.0</strong></p><p>​        <strong>1996年5月</strong>，HTTP被正式作为标准，版本被命名为HTTP/1.0。</p><p><strong>HTTP/1.1</strong></p><p>​        <strong>1997年1月</strong>发布了HTTP/1.1版本，至今任然是主流的HTTP协议。</p><p>​        由此可见，作为 Web 文档传输协议的 HTTP 协议版本更新十分缓慢，新一代的 HTTP 2.0 还在制定中，但是要大规模覆盖，还需要假以时日。</p><h2 id="1-3-网络基础TCP-IP"><a href="#1-3-网络基础TCP-IP" class="headerlink" title="1.3 网络基础TCP/IP"></a>1.3 网络基础TCP/IP</h2><p>​        计算机之间要进行通信，需要基本相同的方法，比如如何探测目标，那一边先发起通信，使用什么语言通信，什么时候结束通信等等。所有的这一切都需要事前约定好，所以约定的规则就别成为协议（protocol)。</p><p>​        一种说法认为TCP/IP指的是TCP和IP两种协议，另一种说法认为只在IP协议通信的过程中所用到的协议族的统称，该书偏向后一种说法。</p><h3 id="1-3-1-TCP-IP的分层管理"><a href="#1-3-1-TCP-IP的分层管理" class="headerlink" title="1.3.1 TCP/IP的分层管理"></a>1.3.1 TCP/IP的分层管理</h3><p>​        TCP/IP协议族最重要的一点就是分层管理，通常来说分为四层：<strong>应用层、传输层、网络层和数据链路层</strong>。</p><p>​        分层管理的最大好处就是将各个阶段的书记进行隔离解耦，类似编程时的模块化。处于某一层的应用只需要考虑该层所需要完成的任务，而不用管其他多余的事情。这样做使得各层协议的实现变得自由了，要修改某一层的协议时，只需要修改该层的协议而不用设计到其他层级的协议。</p><p>各层的作用如下：</p><ul><li><strong>应用层</strong>     决定向用户提供应用服务时的通信活动。HTTP、FTP（File Transfer Protocol,文件传输协议）和DNS（Domain Name System,域名解析系统）都属于该层。</li><li><strong>传输层</strong>    相较于上一层的应用层，该层提供处于网络连接中的两台计算机的数据传输。该层协议主要是TCP（Transmission Control Protocol) 和 UDP（User Data Protocol)。</li><li><strong>网络层</strong>    用于处理网络上流动的数据包（数据传输的最小单位），该层规定了通过怎样的路径到达对方计算机，并将数据传送给对方。该层协议主要是IP协议和APR（Address Solution Protocol)协议。</li><li><strong>链路层</strong>    用于处理网络连接的硬件部分，包括操作系统，设备驱动等，硬件上的范畴基本都在链路层的范围内。该层主要洗衣为以太网协议（Ethernet)</li></ul><h3 id="1-3-2-TCP-IP通信传输流"><a href="#1-3-2-TCP-IP通信传输流" class="headerlink" title="1.3.2 TCP/IP通信传输流"></a><strong>1.3.2 TCP/IP通信传输流</strong></h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7f659bb6b" alt="httpstream"></p><p>​        利用TCP/IP通信时，会通过分层顺序与对方进行通信。发送方的数据流从上往下走，接收方的数据流从下往上走。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7b2367900" alt="httptransfer"></p><p>​        在传输过程中的每一层中国，都会对数据进行<strong>装箱和拆箱</strong>。发送端在层与层之间传输数据时，每经过一层时，必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。</p><p>​        这种把数据信息包装起来的做法成为封装。</p><h3 id="1-3-3-与-HTTP-关心密切的协议：IP、TCP-和-DNS"><a href="#1-3-3-与-HTTP-关心密切的协议：IP、TCP-和-DNS" class="headerlink" title="1.3.3 与 HTTP 关心密切的协议：IP、TCP 和 DNS"></a>1.3.3 与 HTTP 关心密切的协议：IP、TCP 和 DNS</h3><p><strong>IP 协议</strong></p><p>​        IP协议负责网络传输，处于网络层。IP不是IP地址，我们通常说的IP是一种协议。IP地址指明了节点被分配到的地址，MAC地址是网卡所属的固定地址，每块网卡出厂时，都有一个世界独一无二的MAC地址，长度是48位二进制位，用12个十六进制位数表示。IP地址可以和MAC地址配对，但同一个机器IP地址可能会变，MAC是固定不变的。</p><p>​        IP间的通信依赖MAC地址，实际生活中同一局域网内的网络通信比较少，大部分都是广域网的通信，数据需要经过多个节点路由的转发才能到达目的地。而在中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时会采用ARP协议（Address Resolution Protocol), 根据对方的IP地址即可查出对应的MAC地址，但这个两台设备必须在同一个子网内。</p><p>​        数据在网络中的传输类似于现实生活中的快递传输，中转设备就类似于物流中转中心。快递到达一个中转站之后，中转站会哦按标段下一个中转站的地址然后接续派送，直到到达客户所在的中转站。</p><p><strong>TCP协议</strong></p><p>​        TCP 位于传输层，提供可靠的字节流服务。</p><p>​        字节流服务（Byte Stream Service）是指为了传输方便，把大块的数据切割成以报文段（segment）为单位的数据包进行管理。TCP 的可靠之处在于它会确保数据被送到了接收方。</p><p>​        为了确保数据被准确无误地送到了接收方，TCP 采用了三次握手（three-way handshaking）的策略。握手过程中包含了两个重要的标志（flag）——SYN（synchronize）和 ACK（acknowledgement）。</p><p>​        发送端会先发送一个带有 SYN 的数据包给对方，接收端接收到数据之后返回一个 带有 SYN/ACK 标志的数据包给发送端，最后发送端再传回一个带有 ACK 标志的数据包表示“握手”结束。如果握手意外结束，那么 TCP 协议会再次以相同的顺序发送相同的数据包。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7c3199713" alt="tcphandshaking"></p><p>​        除了以上三次握手，TCP 还有其他方法确保可靠性。</p><p><strong>DNS</strong></p><p>​        DNS 也位于应用层，它提供域名解析服务。能够把域名解析为 IP 地址。</p><p>​        各种协议与 HTTP 之间的关系：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7cd972a8c" alt="relationship"></p><h3 id="1-3-4-URI-和URL"><a href="#1-3-4-URI-和URL" class="headerlink" title="1.3.4 URI 和URL"></a>1.3.4 URI 和URL</h3><p>​        URI（Uniform Resource Identifier，统一资源标识符）RFC2396 对名称中的三个单词做了解释：</p><ul><li><p>Uniform，规定统一的格式可方便处理不同的资源，而不用根据上下文环境来识别资源指定的访问方式，另外加入新的协议（http、ftp）也更容易。</p></li><li><p>Resource，指任何可标识的东西。不仅限于文档、图片或服务。</p></li><li><p>Identifier，表示可标识的对象，也称为标识符。</p><p>除了 HTTP 外，URI 还可以使用 mailto、ftp、telnet 等协议方案。</p><p>URI 用字符串标识某一互联网资源，而 URL 用字符串标识资源的地点。所以 URL 是 URI 的子集。</p></li></ul><p><strong>URI 的格式</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7ae4bccff" alt="urlformat"></p><p>其中：</p><ul><li><strong>登录信息（认证）</strong> 指定用户名密码作为从服务端获取资源时的登录信息，此项可选。</li><li><strong>服务器地址</strong>，可以是域名、IP。</li><li><strong>服务器端口号</strong>，指定服务器连接的网络端口号，此项可选，省略时用默认端口号。</li><li><strong>带层次的文件路径</strong>，指定服务器上资源的文件路径。</li><li><strong>查询字符串</strong>，通过查询字符串可以传入参数。</li><li><strong>片段标识符</strong>，指定已获取资源中的子资源（文档内的某个位置）。</li></ul><h1 id="2-简单的HTTP协议"><a href="#2-简单的HTTP协议" class="headerlink" title="2. 简单的HTTP协议"></a>2. 简单的HTTP协议</h1><p>在两台计算机之间使用HTTP协议进行通讯时，在一条通讯线路上必定有一端是客户端，另一端则是服务器端。请求访问文本或图像等资源的一端成为客户端，而提供资源相应的一端成为服务器端。HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p><h2 id="2-1-请求和相应报文的组成"><a href="#2-1-请求和相应报文的组成" class="headerlink" title="2.1 请求和相应报文的组成"></a>2.1 请求和相应报文的组成</h2><p>某个客户端发出的请求如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.htm HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure><p>其中，GET表示请求访问服务器的类型，称为方法（Method)。随后的字符串/index.htm表示请求访问的资源对象，也叫做请求URL。最后的HTTP/1.1表示有所使用的HTTP版本号，用于提示客户端所使用的HTTP版本。</p><p>所以上面这段请求表示使用GET方法请求hackr.jp服务器上的Index.htm资源，客户端使用的是HTTP版本是1.1.</p><p><strong>总结而言</strong>  请求报文是由请求方法，请求URL，协议版本，可选的请求首部字段和内容实体构成的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000cf6d936261" alt="requestcontent"></p><p>上图 解释了请求报文的组成。</p><p>接收到请求的服务器，返回了如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Tue, <span class="number">10</span> Jul <span class="number">2012</span> <span class="number">06</span>:<span class="number">50</span>:<span class="number">15</span> GMT</span><br><span class="line">Content-Length: <span class="number">362</span></span><br><span class="line">Content-Type: text/html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其中，HTTP/1.1 表示服务器对应的 HTTP 版本；后面的200K 表示请求的处理结果的状态码（status code）。下一行表示响应创建的时间，是响应首部字段（header field）的一个属性。空一行之后的内容表示资源主体的实体（entity body）。</p><p>总结：<strong>响应报文基本上由协议版本、状态码（表示请求成功或者失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成</strong>。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000cf6c6630a4" alt="responsecontent"><br>    上图是响应报文的组成。</p><h2 id="2-2-HTTP-是无状态协议"><a href="#2-2-HTTP-是无状态协议" class="headerlink" title="2.2 HTTP 是无状态协议"></a>2.2 HTTP 是无状态协议</h2><p>HTTP 是一种不保存状态，即无状态（stateless）的协议。HTTP 自身不对请求和响应之间的通信状态进行保存。每次有新的请求建立时，就会有对应的响应产生，与之前或者之后的请求都没有任何关系。</p><p>HTTP 的无状态特点，既有好处也有坏处。好处在于无状态的特点使得 HTTP 不用维护客户端状态，大大简化了协议内容和服务器的工作，确保了协议的可伸缩性。坏处在于随着 Web 的发展，网站应用越来越复杂，无状态的协议需要通过其他手段维持客户端状态（登录信息），比如 Cookie 技术，就是从 HTTP 1.1 开始引入的维持状态的手段。</p><h2 id="2-3-告知服务器意图的HTTP方法"><a href="#2-3-告知服务器意图的HTTP方法" class="headerlink" title="2.3 告知服务器意图的HTTP方法"></a>2.3 告知服务器意图的HTTP方法</h2><p>HTTP 1.1 主要包含了以下可以使用的方法。</p><ul><li><p><strong>GET方法</strong>用来请求访问已被URL识别的资源。指定的资源经过服务器解析后返回响应内容。</p></li><li><p><strong>POST方法</strong>用来传输实体的主体。虽然用GET的方法也可以传输实体的主体，但是一般不用GET方法。虽说POST方法的功能和GET相似，但是POST的主要目的并不是获取响应的主体内容。</p></li><li><p><strong>DELETE</strong> 方法主要用于删除服务器上的文件，与 PUT 相反，DELETE 方法删除 URI 指定的服务器文件。同样由于存在安全隐患，所以一般不采用 DELETE 方法。</p></li><li><p><strong>HEAD</strong> 方法主要用于确认 URI 的有效性及资源更新的日期时间等，不会返回报文的主体内容。</p></li><li><p><strong>OPTIONS</strong> 方法用来查询针对请求 URI 指定的资源所支持的方法。</p></li><li><p><strong>TRACE</strong> 方法用来追踪路径，发送请求时，在请求首部字段中加入 <code>Max-Forwards</code> 字段，值为数字，每经过一个服务器，该字段就会减一，当到达某个使该字段为 0 的服务器时，就会返回状态码为 200 OK 的响应。通过 TRACE 方法可以查询发送出去的请求是怎样被加工/篡改的。TRACE 方法本身使用场景较少，而且存在跨站追踪攻击的隐患，所以使用场景更加少了。</p></li><li><p><strong>CONNECT</strong> 方法表示要求用隧道协议连接代理。在与代理服务器通信时，实现用隧道协议进行 TCP 通信，主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016233414113.png" alt="image-20201016233414113"></p></li></ul><p><strong>GET 相对 POST 的优势是什么</strong></p><p>最大的优势是， GET 的URL可以人肉手输啊。。。你在地址栏打个POST给我看看。本质上面， GET 的所有信息都在URL， 所以很方便的记录下来重复使用。</p><p>所以如果你希望<br>                －  请求中的URL可以被手动输入<br>                － 请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。<br>                － 请求中的URL是可以被搜索引擎收录的。<br>                － 带云压缩的浏览器，比如Opera mini/Turbo 2, 只有GET才能在服务器端被预取的。<br>                － 请求中的URL可以被缓存。</p><p>请使用GET. </p><p>大家有没有注意到，其实这里面很多方面的要求是和网站的运营相关的，而不是技术相关的。任何的技术行为中，其实多多少少都能看到商业的影子。</p><p>反之，就用POST. 特别是有一些东西你是不想让人家可以在浏览器地址栏里面可以输入的。比如，如果你设计一个blog系统, 设计这样一个URL来删掉所有帖子。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://myblog.com/?action=delete_all</span><br></pre></td></tr></table></figure><p>我只能说很快你就知道什么叫不作死就不会死这个道理了，搜索引擎的爬虫分分钟教你做人。另外一个准则是，可以重复的交互，比如取个数据，跳个页面， 用GET不可以重复的操作， 比如创建一个条目/修改一条记录， 用POST, 因为POST不能被缓存，所以浏览器不会多次提交.</p><h2 id="2-4-持久连接"><a href="#2-4-持久连接" class="headerlink" title="2.4 持久连接"></a>2.4 持久连接</h2><p>我们知道HTTP协议基于TCP协议，而TCP协议每次建立之前都会进项“三次握手”，所以如果每次发送HTTP请求都要建立TCP连接的话，会造成过多的“握手”浪费服务器资源。而HTTP协议的初始版本中，每次HTTP通信都需要建立TCP请求，这个是一个很大的缺点。</p><p>为了解决的而上述问题，HTTP1.1引入了持久连接（HTTP Persistent Connections,也成为HTTP keep-alive 或者 HTTP connection reuse)。持久连接的特点是只要任意一方没有提出断开TCP连接，就会一直维持TCP的连接状态。</p><p>持久连接的好处杂鱼减少了TCP连接的重复建立和断开所造成的额外开销，减轻了么服务器的负载。在HTTP1.1中，所哟普的连接默认都是持久连接。</p><h2 id="2-5-管线化"><a href="#2-5-管线化" class="headerlink" title="2.5 管线化"></a>2.5 管线化</h2><p>持久连接使得多数请求以管线化（pipeline)方式成为可能，以前发送请求后需要等待响应之后次啊能发送下一个请求，但是管线化技术出现后，不用等待响应，就可以发送下一个请求。这样能够做到多个请求并行发送，大大减少了页面加载的时间。</p><h2 id="2-6-使用Cookie管理状态"><a href="#2-6-使用Cookie管理状态" class="headerlink" title="2.6 使用Cookie管理状态"></a>2.6 使用Cookie管理状态</h2><p>之前提到过 HTTP 是无状态协议，我们通过 Cookie 维持客户端状态。</p><p>Cookie 会根据从服务端发送的响应报文内的一个叫做 <code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器发现从客户端发送过来的 Cookie 之后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p>设置 Cookie 的响应报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Thu, <span class="number">12</span> Jul <span class="number">2012</span> <span class="number">07</span>:<span class="number">12</span>:<span class="number">20</span> GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid=<span class="number">1342077140226724</span>; path=/; expires=Wed,</span><br><span class="line"><span class="number">10</span>-Oct-<span class="number">12</span> <span class="number">07</span>:<span class="number">12</span>:<span class="number">20</span> GMT&gt;</span><br><span class="line">Content-Type: text/plain; charset=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>携带有 Cookie 信息的请求报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /image/ HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=<span class="number">1342077140226724</span></span><br></pre></td></tr></table></figure><h1 id="3-HTTP报文内的HTTP信息"><a href="#3-HTTP报文内的HTTP信息" class="headerlink" title="3. HTTP报文内的HTTP信息"></a>3. HTTP报文内的HTTP信息</h1><h2 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h2><p>用于HTTP协议交互的信息被称为HTTP报文，客户端的HTTP报文叫做请求报文，服务端的叫做响应报文。</p><p>HTTP报文大致可分为报文首部和报文主体两块，两者通过空行划分（CR+LF),通常并不一定要有报文主体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CR：Carriage Return，回车符，<span class="number">16</span> 进制的 <span class="number">0x0d</span></span><br><span class="line"></span><br><span class="line">LF：Line Feed，换行符，<span class="number">16</span> 进制的 <span class="number">0x0a</span></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c00170b6e361f3" alt="httpbody"></p><p>下图展示了请求报文和响应报文的结构：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c00170b429fc43" alt="bodystructure"></p><p>其中：</p><ul><li>请求行 包括用于请求的方法，请求URL和HTTP版本</li><li>状态行 包含表明响应结果的状态码，原因短语和HTTP版本</li><li>首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般抱哈通用首部，请求首部，响应首部和实体首部。</li><li>其他 包含一些未在RFC中的定义的首部（Cookie等）</li></ul><h2 id="3-2-通过编码提升传输速度"><a href="#3-2-通过编码提升传输速度" class="headerlink" title="3.2 通过编码提升传输速度"></a>3.2 通过编码提升传输速度</h2><p>HTTP在传输时可以按照原始数据直接传输，也可以预先将数据进行压缩后在传输。编码压缩后可以减少传输的数据量，能够提升传输速率，但是压缩过程会消耗更多的CPU资源。</p><h3 id="3-2-1-报文主体和实体主体的差异"><a href="#3-2-1-报文主体和实体主体的差异" class="headerlink" title="3.2.1  报文主体和实体主体的差异"></a>3.2.1  报文主体和实体主体的差异</h3><ul><li>报文（message) 是HTTP通信过程中的基本单位，由八位组字节流组成，通过HTTP传输。</li><li>实体（entiy) 作为请求或者相应的有效载荷数据被传输，其内容由实体首部和实体主体构成。</li></ul><p>HTTP报文的主体用于传输实体的主体（请求或者响应的）</p><p>通常情况下，报文主体就是实体主体。但是在进行编码压缩时，实体主体部分会被编码，导致与报文主体不同。</p><h3 id="3-2-2-压缩传输的内容编码"><a href="#3-2-2-压缩传输的内容编码" class="headerlink" title="3.2.2 压缩传输的内容编码"></a>3.2.2 压缩传输的内容编码</h3><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，压缩之后的内容在客户端被接受之后会进行解码还原。</p><p>常用的内容编码有以下几种：</p><ul><li><p>GZIP (GNU zip)</p></li><li><p>compress (UNIX系统的标准压缩)</p></li><li><p>deflate (zlib)</p></li><li><p>identity (不进行编码)</p></li></ul><p>现在还有一种新型的优秀算法——Brotli，但是目前还没有被广泛采用。</p><h3 id="3-2-3-分块传输编码"><a href="#3-2-3-分块传输编码" class="headerlink" title="3.2.3 分块传输编码"></a>3.2.3 分块传输编码</h3><p>在传输容量数据是，通过把数据分块成多块，能够让浏览器初步显示页面。这种功能称为分块传输编码（Chunked Transfer Coding)。</p><p>分块传输会将实体主体分割成多个块（chunk）来传输，每一个块都用十六进制来标记块的大小，而实体主体的最后一块会使用’0 (CR+LF)’ 来标记。</p><h2 id="3-3-发送多种数据的多部分对象集合"><a href="#3-3-发送多种数据的多部分对象集合" class="headerlink" title="3.3 发送多种数据的多部分对象集合"></a>3.3 发送多种数据的多部分对象集合</h2><p>邮件附件能够同时传送多种内容的数据，是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多种类型的数据。相应的，HTTP 也采纳了部分多部分对象集合。</p><p>多部分对象集合包含的对象如下：</p><ul><li>multipart/from-data: 在Web表单上传使用。</li><li>multipart/byteranges：状态码206(Partial Content，部分内容)响应报文包含了多个范围的内容时使用。</li></ul><p>可以通过制定Content-Type 请求头来使用多部分对象结合。</p><h2 id="3-4-获取部分内容的范围请求"><a href="#3-4-获取部分内容的范围请求" class="headerlink" title="3.4 获取部分内容的范围请求"></a>3.4 获取部分内容的范围请求</h2><p>指定范围发送的请求叫做范围请求（Range Request)。</p><p>对于一份10000字节大小的资源，可以通过范围请求一次只请求5001—10000字节的资源。</p><p>执行范围请求时，会通过Range首部字段来指定资源的byte范围，比如：</p><ul><li><p>5000—10000字节：</p><p>Range: bytes = 5001-10000</p></li><li><p>5000字节之后的所有内容：</p><p>Range: bytes = 5000-</p></li><li><p>从1开始到30000字节和5000字节到7000字节：</p><p>Range: byte=0-3000,5000-7000</p></li></ul><p>针对范围请求，响应会返回状态码为206 Partial Content的响应报文</p><p>对于多重范围的范围请求，响应会在首部字段Content-Tupe标明，multipart/byteranges后返回。</p><h2 id="3-5-内容协商发返回最合适的内容"><a href="#3-5-内容协商发返回最合适的内容" class="headerlink" title="3.5 内容协商发返回最合适的内容"></a>3.5 内容协商发返回最合适的内容</h2><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。</p><p>内容协商会以语言、字符集、编码方式等为基准判断响应的资源。</p><p>包含在请求报文中的一些首部字段就是服务端响应的判断标准：</p><ul><li><strong>Accept</strong></li><li><strong>Accept-Charset</strong></li><li><strong>Accept-Encoding</strong></li><li><strong>Accept-Language</strong></li><li><strong>Content-Language</strong></li></ul><h1 id="4-HTTP状态码"><a href="#4-HTTP状态码" class="headerlink" title="4. HTTP状态码"></a>4. HTTP状态码</h1><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，我们可以了解这次请求是否在服务器端得到正确的处理。</p><p>状态码可有分为五种：</p><table><thead><tr><th></th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td>1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接受的请求正在处理</td></tr><tr><td>2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td>3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td>5XX</td><td align="center">Server Error（服务端错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><p>下面介绍一下常用的一些状态码。</p><h2 id="4-1-2XX-成功"><a href="#4-1-2XX-成功" class="headerlink" title="4.1 2XX 成功"></a>4.1 2XX 成功</h2><ul><li><p><strong>200 OK</strong></p><p>表示从客户端发送的请求被服务器正常处理了</p></li><li><p><strong>204 No Content</strong> </p><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p></li><li><p><strong>206 Partial Content</strong></p><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的GET请求。响应报文中包含了有Contenet-Range指定范围的实体内容。</p></li></ul><h2 id="4-2-3XX-重定向"><a href="#4-2-3XX-重定向" class="headerlink" title="4.2 3XX 重定向"></a>4.2 3XX 重定向</h2><p>3XX响应状态码表示浏览器需要执行某些特殊的处理以正确处理请求。</p><ul><li><p><strong>301 Moved Permanently</strong></p><p>永久性重定向。</p><p>该状态码表示请求的资源已经被分配到新的URI,以后应使用资源指定的URI。新的URI会在HTTP响应头中的Location首部字段指定。</p></li><li><p><strong>302 Found</strong></p><p>临时重定向。</p><p>该状态码表示请求的资源被分配到了新的URI，希望本次能使用新的URI访问资源。和301 Moved Permanently 状态码相似，但是302 代表的资源不是被永久重定向，只是临时性质的。</p></li><li><p><strong>303 See Other</strong></p><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302Found状态码有着相似的功能，但是303状态码明确表示客户端应当采用GET方法获取资源。</p><p>当301、302、303响应状态码返回时，几乎所有的浏览器都会吧POST改成GET，并删除清秋月报文内的主体，之后请求会再次自动发送。301、302标准是进制将POST方法变成GET方法的，但实际大家都会这样做。</p></li><li><p><strong>304 Not Modified</strong></p><p>该状态码表示客户端发送附带条件的请求时（GET 请求包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部）服务端允许访问请求访问资源，但因为请求没有满足条件，所以发生 304 Not Modified 重定向，直接使用客户端缓存的资源。</p></li><li><p><strong>307 Temporary Redirect</strong></p><p>临时重定向。</p><p>该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p></li><li><p><strong>307 会遵守浏览器标准，不会从 POST 变成 GET</strong>。</p><p>但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。</p></li></ul><h2 id="4-3-4XX客户端错误"><a href="#4-3-4XX客户端错误" class="headerlink" title="4.3  4XX客户端错误"></a>4.3  4XX客户端错误</h2><p>​    4XX的结果表明客户端是发生错误的原因所在</p><ul><li><p><strong>400 Bad Request</strong></p><p>该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。</p></li><li><p><strong>401 Unauthorized</strong></p><p>该状态码表示请求需要通过认证。</p></li><li><p><strong>403 Forbidden</strong></p><p>该状态码表明请求资源的访问被服务器拒绝，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明</p></li><li><p><strong>404 Not Found</strong></p><p>该状态码表明服务器尚无法找到请求的资源。</p></li></ul><h2 id="4-4-5XX服务端错误"><a href="#4-4-5XX服务端错误" class="headerlink" title="4.4 5XX服务端错误"></a>4.4 5XX服务端错误</h2><p>5XX的响应结果表明服务端本省发生了错误</p><ul><li><p><strong>500 Internet Server Error</strong> </p><p>该状态码表明服务端在执行请求时存在错误，越有可能是web应用存在Bug或者某些临时故障</p></li><li><p><strong>503 Service Unavailable</strong></p><p>该状态码表明服务器暂时处于超负载或者正在进行停机维护，现在无法处理请求。</p></li></ul><h1 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5. Web服务器"></a>5. Web服务器</h1><h2 id="5-1-用单台虚拟机实现多个域名"><a href="#5-1-用单台虚拟机实现多个域名" class="headerlink" title="5.1 用单台虚拟机实现多个域名"></a>5.1 用单台虚拟机实现多个域名</h2><p>基于虚拟主机的功能，可以只使用一台物理机实现多个域名的网站部署，在互联上，域名通过DNS域名解析系统可以映射到具体的IP上，多个域名可以映射到同一个IP，但是一个域名只能映射到一个IP上。如果服务器想知道请求来自哪个域名，可以通过请求头中的Host首部字段获取。</p><h2 id="5-2-代理、网关和隧道"><a href="#5-2-代理、网关和隧道" class="headerlink" title="5.2 代理、网关和隧道"></a>5.2 代理、网关和隧道</h2><p>HTTP通信时，除了服务端和客户端以外，还有一些用于通信数据转发处理的应用程序，例如代理、网关和隧道。他们可以配合服务器工作。</p><ul><li>代理是一种具有转发功能的应用程序，扮演着服务器和客户端的中间人的角色。代理接受客户端的请求转发给服务器，然后接受服务器的响应转发给客户端。</li><li>网管是转发其他服务器通信数据的服务器，接受从客户端发送来的请求时，他就想自己拥有资源的源服务器一样对请求进行处理。</li><li>隧道是在相隔甚远的客户端和服务器之间进行中转并保存双方连接的应用程序。</li></ul><h3 id="5-2-1-代理"><a href="#5-2-1-代理" class="headerlink" title="5.2.1 代理"></a>5.2.1 代理</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a37a349072" alt="webproxy"></p><p>代理服务器的基本行为就是在客户端和服务端之间转发请求和响应，代理不改变请求 URI，会直接发送给持有资源的服务器（称为<strong>源服务器</strong>）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a380be8c6c" alt="multihttpproxy"></p><p>每次通过代理转发请求或者响应时，会追加写入 Via 首部字段，该字段会标记处经过的代理主机信息。</p><p>使用代理服务器的理由包括利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，获取访问日志等。</p><p>代理的使用方式可以按照是否使用缓存和是否修改报文来进行分类。</p><p><strong>缓存代理</strong>：代理转发响应时，会把资源保存在代理服务器上，当代理再接收到相同的资源请求时，会返回之前缓存的资源。</p><p><strong>透明代理</strong>：转发请求或者响应时，不对报文进行任何修改的代理类型称为透明代理，反之称为非透明代理。</p><h3 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2 网关"></a>5.2.2 网关</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a377ec7432" alt="httpgateway"></p><p>网关的工作机制和代理十分相似，但是网管可以使通信线路上的服务器提供非HTTP协议服务。</p><p>利用网关能提高通信的安全性，因为可以再客户端和网关之间的通信线路上加密以确保连接的安全性。</p><h3 id="5-2-3-隧道"><a href="#5-2-3-隧道" class="headerlink" title="5.2.3 隧道"></a>5.2.3 隧道</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201018191451384.png" alt="image-20201018191451384"></p><p>隧道可以按照要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。<strong>隧道的目的是确保客户端与服务端能够进行安全的通信</strong></p><h2 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h2><p>缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。利用缓存可以减少对源服务器的访问，可以减少通信流量和通信时间，缓存服务器是代理服务器的一种，并归类在缓存代理类型中。</p><h4 id="5-3-1-缓存的有效期限"><a href="#5-3-1-缓存的有效期限" class="headerlink" title="5.3.1 缓存的有效期限"></a>5.3.1 缓存的有效期限</h4><p>即使存在缓存，也会因为客户端的要求，缓存的有效期等因素向源服务器确认资源的有效性。若缓存失效，缓存服务器会再次向源服务器获取’新的’资源。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a3846040ad" alt="httpcache"></p><h3 id="5-3-2-客户端缓存"><a href="#5-3-2-客户端缓存" class="headerlink" title="5.3.2 客户端缓存"></a>5.3.2 客户端缓存</h3><p>除了带来服务器内的缓存以外，客户端的浏览器也可以缓存。同时的客户端也会向源服务器确定资源的有效性，然后再返回有效的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-了解Web及网络基础&quot;&gt;&lt;a href=&quot;#1-了解Web及网络基础&quot; class=&quot;headerlink&quot; title=&quot;1.了解Web及网络基础&quot;&gt;&lt;/a&gt;1.了解Web及网络基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-Web基于HTTP通信&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://leslieaibin.github.io/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>从新开始</title>
    <link href="https://leslieaibin.github.io/2020/10/28/Reboot/"/>
    <id>https://leslieaibin.github.io/2020/10/28/Reboot/</id>
    <published>2020-10-28T12:15:42.000Z</published>
    <updated>2020-10-30T08:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="天下熙熙，皆为利来；天下攘攘，皆为利往。"><a href="#天下熙熙，皆为利来；天下攘攘，皆为利往。" class="headerlink" title="天下熙熙，皆为利来；天下攘攘，皆为利往。"></a>天下熙熙，皆为利来；天下攘攘，皆为利往。</h2><p>周书曰：「农不出则乏其食，工不出则乏其事，商不出则三宝绝，虞不出则财匮少。」财匮少而山泽不辟矣。此四者，民所衣食之原也。原大则饶，原小则鲜。上则富国，下则富家。贫富之道，莫之夺予，而巧者有馀，拙者不足。故太公望封於营丘，地潟卤，人民寡，於是太公劝其女功，极技巧，通鱼盐，则人物归之，繦至而辐凑。故齐冠带衣履天下，海岱之间敛袂而往朝焉。其後齐中衰，管子修之，设轻重九府，则桓公以霸，九合诸侯，一匡天下；而管氏亦有三归，位在陪臣，富於列国之君。是以齐富彊至於威、宣也。</p><p>故曰：「仓廪实而知礼节，衣食足而知荣辱。」礼生於有而废於无。故君子富，好行其德；小人富，以適其力。渊深而鱼生之，山深而兽往之，人富而仁义附焉。富者得埶益彰，失埶则客无所之，以而不乐。夷狄益甚。谚曰：「千金之子，不死於市。」此非空言也。故曰：「天下熙熙，皆为利来；天下壤壤，皆为利往。」夫千乘之王，万家之侯，百室之君，尚犹患贫，而况匹夫编户之民乎！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;天下熙熙，皆为利来；天下攘攘，皆为利往。&quot;&gt;&lt;a href=&quot;#天下熙熙，皆为利来；天下攘攘，皆为利往。&quot; class=&quot;headerlink&quot; title=&quot;天下熙熙，皆为利来；天下攘攘，皆为利往。&quot;&gt;&lt;/a&gt;天下熙熙，皆为利来；天下攘攘，皆为利往。&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
