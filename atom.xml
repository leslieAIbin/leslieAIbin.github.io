<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>春暖花开去见你</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2021-05-14T06:56:39.739Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>7.JVM —— 堆</title>
    <link href="https://leslieaibin.github.io/2021/05/14/Java/JVM/9.%E5%A0%86/"/>
    <id>https://leslieaibin.github.io/2021/05/14/Java/JVM/9.%E5%A0%86/</id>
    <published>2021-05-13T21:15:42.000Z</published>
    <updated>2021-05-14T06:56:39.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概念"><a href="#堆的核心概念" class="headerlink" title="堆的核心概念"></a>堆的核心概念</h2><p>堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706195127740.png" alt="image-20200706195127740"></p><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间的大小也就确定了，是JVM管理的最大一块内存空间。</p><ul><li>堆内存大小是可以调节的。</li></ul><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内训空间中，但在逻辑上它应该被视为连续的。</p><p>所有线程共享Java堆，在这里还可以划分线程私有的缓冲区<code>（Thread Local Allocation Buffer, TLAB)</code>  </p><ul><li><p>-Xms10m：最小堆内存</p></li><li><p>-Xmx10m：最大堆内存</p><p>下图就是使用: Java VisualVM查看堆空间的内容，通过JDK bin提供的插件</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706200739392.png" alt="image-20200706200739392"></p><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><p>我要说的是: “几乎”所有的对象实例都在这里分配内存。</p><ul><li>因为还有一些对象是在栈上分配的。</li></ul><p>数组和对象可能永远不会在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会移除</p><ul><li><p>也就是触发了GC的时候，才会进行回收</p></li><li><p>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word堆，是<code>GC（Garbage Collection，垃圾收集器）</code>执行垃圾回收的重点区域</p></li></ul><p>  <img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706201904057.png" alt="image-20200706201904057"></p><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p><strong>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+<code>永久区</code></strong></p><ul><li>Young Generation Space 新生区  Young/New  <ul><li> 又被划分为Eden区和Survivor区</li></ul></li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space 永久区   Perm</li></ul><p><strong>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+<code>元空间</code></strong></p><ul><li>Young Generation Space 新生区  Young/New <ul><li> 又被划分为Eden区和Survivor区</li></ul></li><li>Tenure generation space 养老区  Old/Tenure</li><li>Meta Space  元空间   Meta</li></ul><p>约定：新生区 -&gt; 新生代 -&gt; 年轻代   、  养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706203419496.png" alt="image-20200706203419496"></p><p>堆空间内部结构，JDK1.8之前从永久代  替换成 元空间</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706203835403.png" alt="image-20200706203835403"></p><h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项<code>&quot;-Xmx&quot; 和&quot;-Xms&quot;</code>进行设置</p><ul><li>“-Xmx”用于表示堆区的起始内存，等价于-xx:InitialHeaoSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul><p>一旦堆区中的内存大小超过”-xmx”所指定的最大内存时，将会抛出<code>outofMemoryError</code>异常。</p><p>通常会将-Xmx 和-Xms两个参数配置相同的值，其目的是为能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能</p><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小/64</li><li>最大内存大小：物理电脑内存大小/4</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* -Xms 用来设置堆空间(年轻代 + 老年代) 的初始内存大小</span></span><br><span class="line"><span class="comment">* -X 是jvm运行参数</span></span><br><span class="line"><span class="comment">* ms memory start</span></span><br><span class="line"><span class="comment">* -Xmx 用来设置堆空间(年轻代 + 老年代)的最大内存大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSpaceInitial</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="keyword">long</span> initialMemory = Runtime.getRuntime().totalMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机视图使用最大的堆内存</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() /<span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms:245M</span><br><span class="line">-Xmx:3614M</span><br></pre></td></tr></table></figure><p>如何查看堆内存的内存分配情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps  -&gt;  jstat -gc 进程id</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706205756045.png" alt="image-20200706205756045"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706205821919.png" alt="image-20200706205821919"></p><h3 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">           list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706210000461.png" alt="image-20200706210000461"></p><p>我们简单的写一个OOM例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OOM测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-06-21:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210513104641303.png" alt="image-20210513104641303"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="number">999999999</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx:10m</span><br></pre></td></tr></table></figure><p>运行后，就出现OOM了，那么我们可以通过 VisualVM这个工具查看具体是什么参数造成的OOM</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706211652779.png" alt="image-20200706211652779"></p><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以划分为两类：</p><ul><li><p>一类是声明周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</p><ul><li>生命周期短的，及时回收即可</li></ul></li><li><p>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</p><p>Java堆区进一步细分的，可以划分为<code>年轻代（YoungGen）和 老年代（oldGen）</code></p><p>其中年轻代又可以划分为<code>Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区，to区）</code></p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707075847954.png" alt="image-20200707075847954"></p><p>下面这参数开发中一般不会调：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707080154039.png" alt="image-20200707080154039"></p><ul><li>Eden：From：to -&gt;  8:1:1</li><li>新生代：老年代  - &gt;  1 : 2</li></ul><p>配置新生代与老年代在堆结构的占比。</p><ul><li><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p></li><li><p>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</p></li></ul><blockquote><p>当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优</p></blockquote><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p><p>几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p><blockquote><p>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p><p>可以使用选项”-Xmn”设置新生代最大内存大小</p><p>这个参数一般使用默认值就可以了。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707084208115.png" alt="image-20200707084208115"></p><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><ul><li>new的对象先放<code>Eden</code>。此区有大小限制</li><li>当<code>Eden</code>的空间填满时，程序有需要创建对象，JVM的垃圾回收器将对Eden进行垃圾回收<code>（MinorGC)</code>，将Eden中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到Eden中。</li><li>然后将<code>Eden</code>中的剩余对象移动到<code>Survivor0</code>中</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到<code>Survivor0</code>的，如果没有回收，就会放到<code>Survivor1</code>中</li><li>如果再次经历垃圾回收，此时会重新放回<code>Survivor0</code>区，如果没有回收，就会放到<code>Survivor1</code>区</li><li>什么时候能去<code>Old Gen</code>，可以设置次数，默认为15次</li><li>在<code>Old Gen</code>，相对悠闲。当<code>Old Gen</code>内存不足时，再次触发<code>GC：Major GC</code>，进行<code>Old Gen</code>的内存清理</li><li>若<code>Old Gen</code>执行了<code>Major GC</code>之后，发现依然无法进行对象的保存，就会产生<code>OOM</code>异常。</li></ul><h3 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h3><p>我们创建的对象，一般都是存放在<code>Eden</code>区的，当我们Eden区满了后，就会触发GC操作，一般被称为YGC/ Minor GC操作。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707084714886.png" alt="image-20200707084714886"></p><p>当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在<code>S0(Survivor From)</code>区。同时我们给每个对象设置了一个<code>年龄计数器</code>，一次回收后就是1。</p><p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707085232646.png" alt="image-20200707085232646"></p><p>我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的<code>年龄达到15</code>的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象  晋升到 <code>老年代</code>中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707085737207.png" alt="image-20200707085737207"></p><h3 id="思考：幸存区区满了后？"><a href="#思考：幸存区区满了后？" class="headerlink" title="思考：幸存区区满了后？"></a>思考：幸存区区满了后？</h3><p>特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作</p><p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代</p><blockquote><p>举例：以当兵为例，正常人的晋升可能是 ：  新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长</p><p>但是也有可能有些人因为做了非常大的贡献，直接从  新兵 -&gt; 排长</p></blockquote><h3 id="对象分配的特殊情况"><a href="#对象分配的特殊情况" class="headerlink" title="对象分配的特殊情况"></a>对象分配的特殊情况</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707091058346.png" alt="image-20200707091058346"></p><h3 id="代码演示对象分配过程"><a href="#代码演示对象分配过程" class="headerlink" title="代码演示对象分配过程"></a>代码演示对象分配过程</h3><p>不断创建大对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapInstanceTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">200</span>)];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HeapInstanceTest());</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置JVM参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms600m -Xmx600m</span><br></pre></td></tr></table></figure><p>然后cmd输入下面命令，打开VisualVM图形化界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvisualvm</span><br></pre></td></tr></table></figure><p>然后通过执行上面代码，通过VisualGC进行动态化查看</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.gif" alt="垃圾回收"></p><p>最终，在老年代和新生代都满了，就出现OOM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:13)</span><br><span class="line">at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17)</span><br></pre></td></tr></table></figure><h3 id="常用的调优工具"><a href="#常用的调优工具" class="headerlink" title="常用的调优工具"></a>常用的调优工具</h3><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控  推荐~）</li><li>Jprofiler（推荐~）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to</li><li>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集</li><li>新生代采用复制算法的目的：是为了减少内碎片</li></ul><h2 id="Minor-GC、MajorGC、Full-GC"><a href="#Minor-GC、MajorGC、Full-GC" class="headerlink" title="Minor GC、MajorGC、Full GC"></a>Minor GC、MajorGC、Full GC</h2><ul><li>Minor GC: 新生代的GC</li><li>Major GC: 老年代的GC</li><li>Full GC: 整堆收集，收集整个Java堆和方法区的垃圾收集</li></ul><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题</p><p>而 Major GC 和 Full GC出现<code>STW（Stop The World（停顿类型STW））</code>的时间，是Minor GC的10倍以上</p><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两种大类型：一种是部分收集（Partial GC）， 一种是整堆收集（Full GC）</p><p><strong>部分收集：</strong>不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集</li><li>老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul><p><strong>整堆收集（FullGC）</strong>：收集整个java堆和方法区的垃圾收集。</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。）</p><p>因为Java对象大多都具备 <strong>朝生夕灭</strong> 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p><blockquote><p>STW：stop the word</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707095606813.png" alt="image-20200707095606813"></p><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p><p>出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC</li></ul><p>Major GC的速度一般会比MinorGc慢1e倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了</p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>触发Full GC执行的情况有如下五种：</p><ul><li>调用System.gc（）时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</p><h3 id="GC-举例"><a href="#GC-举例" class="headerlink" title="GC 举例"></a>GC 举例</h3><p>我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String a = <span class="string">&quot;mogu blog&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置JVM启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>打印出的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2038K-&gt;500K(2560K)] 2038K-&gt;797K(9728K), 0.3532002 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.36 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2108K-&gt;480K(2560K)] 2405K-&gt;1565K(9728K), 0.0014069 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2288K-&gt;0K(2560K)] [ParOldGen: 6845K-&gt;5281K(7168K)] 9133K-&gt;5281K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058675 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5281K-&gt;5281K(9728K), 0.0002857 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5281K-&gt;5263K(7168K)] 5281K-&gt;5263K(9728K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0058564 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 60K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0f138,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 5263K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 73% used [0x00000000ff600000,0x00000000ffb23cf0,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3514K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 388K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line">  Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOfRange(Arrays.java:3664)</span><br><span class="line">at java.lang.String.&lt;init&gt;(String.java:207)</span><br><span class="line">at java.lang.StringBuilder.toString(StringBuilder.java:407)</span><br><span class="line">at com.atguigu.java.chapter08.GCTest.main(GCTest.java:20)</span><br></pre></td></tr></table></figure><p>触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常</p><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了么？经研究，不同对象的生命周期不同，70%-99%的对象是临时对象。</p><blockquote><p>新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。<br>老年代：存放新生代中经历多次GC仍然存活的对象。</p></blockquote><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707101511025.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707101543871.png" alt="image-20200707101543871"></p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（<strong>默认为15岁，其实每个JVM、每个GC都有所不同</strong>）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阈值，可以通过选项<code>-xx：MaxTenuringThreshold</code>来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li><p>优先分配到Eden</p><ul><li>开发中比较长的字符串或者数组，会直接存到老年代，但是因为新创建的对象都是朝生夕死，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比Minor GC要更少，因此可能回收起来就会比较慢。</li></ul></li><li><p>对象直接分配到老年代</p><ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li><p>长期存活的对象分配到老年代</p></li><li><p>动态对象年龄判断</p><ul><li>如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于改年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</li></ul><p>空间分配担保：-xx:HandlePromotionFailure</p></li><li><p>经过 Minor GC后，所有对象都存活，因为Survivor比较小，所以就需要将Survivor 无法容纳的对象，存放到老年代中</p></li></ul><h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="问题：堆空间都是共享的么？"><a href="#问题：堆空间都是共享的么？" class="headerlink" title="问题：堆空间都是共享的么？"></a>问题：堆空间都是共享的么？</h3><p>不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占</p><h3 id="为什么有TLAB？"><a href="#为什么有TLAB？" class="headerlink" title="为什么有TLAB？"></a>为什么有TLAB？</h3><p><code>TLAB：Thread Local Allocation Buffer</code>，也就是为每个线程单独分配了一个缓冲区</p><p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</p><p>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</p><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p><h3 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h3><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。</p><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707103547712.png" alt="image-20200707103547712"></p><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。</p><p>在程序中，开发人员可以通过选项<code>“-Xx:UseTLAB”</code>设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项<code>“-Xx:TLABWasteTargetPercent”</code>设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</p><h3 id="TLAB分配过程"><a href="#TLAB分配过程" class="headerlink" title="TLAB分配过程"></a>TLAB分配过程</h3><p>对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707104253530.png" alt="image-20200707104253530"></p><h2 id="小结：堆空间的参数设置"><a href="#小结：堆空间的参数设置" class="headerlink" title="小结：堆空间的参数设置"></a>小结：堆空间的参数设置</h2><ul><li><p>-XX：+PrintFlagsInitial：查看所有的参数的默认初始值</p></li><li><p>-XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p></li><li><p>-Xms：初始堆空间内存（默认为物理内存的1/64）</p></li><li><p>-Xmx：最大堆空间内存（默认为物理内存的1/4）</p></li><li><p>-Xmn：设置新生代的大小。（初始值及最大值）</p></li><li><p>-XX:NewRatio：配置新生代与老年代在堆结构的占比</p></li><li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p></li><li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</p></li><li><p>-XX：+PrintGCDetails：输出详细的GC处理日志</p><ul><li>打印gc简要信息：①-Xx：+PrintGC  ② - verbose:gc</li></ul></li><li><p>-XX:HandlePromotionFalilure：是否设置空间分配担保</p></li></ul><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。<ul><li>如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</li><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则改为进行一次FullGC。</li><li>如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。</li></ul></li></ul><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。</p><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p><p>随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，<strong>那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><h4 id="逃逸分析举例"><a href="#逃逸分析举例" class="headerlink" title="逃逸分析举例"></a>逃逸分析举例</h4><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的逃逸分析代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis():obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">// getInstance().XXX  发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-xx：+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-xx：+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的栈上分配的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>我们通过举例来说明 开启逃逸分析  和 未开启逃逸分析时候的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 未发生逃逸</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置JVM参数，表示未开启逃逸分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>运行结果，同时还触发了GC操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为：664 ms</span><br></pre></td></tr></table></figure><p>然后查看内存的情况，发现有大量的User存储在堆中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707203038615.png" alt="image-20200707203038615"></p><p>我们在开启逃逸分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为：5 ms</span><br></pre></td></tr></table></figure><p>在看内存情况，我们发现只有很少的User对象，说明User未发生逃逸，因为它存储在栈中，随着栈的销毁而消失</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707203441718.png" alt="image-20200707203441718"></p><h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) &#123;</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object hellis = <span class="keyword">new</span> Object();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将其转换成字节码</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200707205634266.png" alt="image-20200707205634266"></p><h3 id="分离对象和标量替换"><a href="#分离对象和标量替换" class="headerlink" title="分离对象和标量替换"></a>分离对象和标量替换</h3><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。<br>标量替换为栈上分配提供了很好的基础。</p><h3 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h3><p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></table></figure><p>这里设置参数如下：</p><ul><li>参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数-XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数-Xmx10m：指定了堆空间最大为10MB</li><li>参数-XX:+PrintGC：将打印Gc日志</li><li>参数一xx：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。<br>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。</p><p>当GC发生在老年代时则被称为Major Gc或者Full GC。一般的，Minor Gc的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h1&gt;&lt;h2 id=&quot;堆的核心概念&quot;&gt;&lt;a href=&quot;#堆的核心概念&quot; class=&quot;headerlink&quot; title=&quot;堆的核心概念&quot;&gt;&lt;/a&gt;堆的核心概</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>7.JVM —— 本地方法接口</title>
    <link href="https://leslieaibin.github.io/2021/05/13/Java/JVM/8.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <id>https://leslieaibin.github.io/2021/05/13/Java/JVM/8.%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-05-12T21:15:42.000Z</published>
    <updated>2021-05-14T06:56:19.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h2><p>简单的讲，一个<code>Native Methodt</code>是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法，该方法的实现由非Java语言实现，比如C。这个特征并非Java所持有，很多其他的编程语言，都有这一机制，比如C++中，你可以用extern “c “告知编译器去调用一个c的函数</p><p>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706164139252.png" alt="image-20200706164139252"></p><p>代码举例说明Native方法是如何编写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhaveNatives</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Native1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">Native2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="keyword">private</span> <span class="keyword">float</span> <span class="title">Native3</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">Natives</span><span class="params">(<span class="keyword">int</span>[] ary)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：标识符native可以与其它java标识连用，但是abstract除外</p><h2 id="为什么使用Naticve-Method"><a href="#为什么使用Naticve-Method" class="headerlink" title="为什么使用Naticve Method?"></a>为什么使用Naticve Method?</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="与Java环境的交互"><a href="#与Java环境的交互" class="headerlink" title="与Java环境的交互"></a>与Java环境的交互</h3><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地方法接口&quot;&gt;&lt;a href=&quot;#本地方法接口&quot; class=&quot;headerlink&quot; title=&quot;本地方法接口&quot;&gt;&lt;/a&gt;本地方法接口&lt;/h1&gt;&lt;h2 id=&quot;什么是本地方法&quot;&gt;&lt;a href=&quot;#什么是本地方法&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>7.JVM —— 虚拟机栈</title>
    <link href="https://leslieaibin.github.io/2021/05/12/Java/JVM/7.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>https://leslieaibin.github.io/2021/05/12/Java/JVM/7.%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2021-05-11T21:15:42.000Z</published>
    <updated>2021-05-12T08:15:34.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h2><p>由于跨平台的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计基于寄存器的。</p><p>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>有不少Java开发人员一提到Java内存结构，就会非常粗粒度的将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）为什么？</p><p>首先栈是运行时的单位，而堆是存储的单位</p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</li><li>堆解决的是数据存储的问题，即数据怎么放，放在那里。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705163928652.png" alt="image-20200705163928652"></p><h3 id="Java虚拟机栈是什么"><a href="#Java虚拟机栈是什么" class="headerlink" title="Java虚拟机栈是什么"></a>Java虚拟机栈是什么</h3><p><code>Java虚拟机栈（Java Virtual Machine Stack）</code>，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧（Stack Frame）</code>，对应着一次次的Java方法调用。</p><p><strong>线程私有</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705164722033.png" alt="image-20200705164722033"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>声明周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>主管Java程序的运行，它保存方法的局部变量，部分结果，并参与方法的调用和返回。</p><p>局部变量，它是相比于成员变量来说的（或属性）</p><p>基本数据类型变量 VS 引用类型变量（类、数组、接口）</p><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序技术器。JVM直接对Java栈操作只有两个：</p><ul><li>每个方法执行，伴随着进展（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705165025382.png" alt="image-20200705165025382"></p><h3 id="开发中遇到哪些异常？"><a href="#开发中遇到哪些异常？" class="headerlink" title="开发中遇到哪些异常？"></a>开发中遇到哪些异常？</h3><p>栈中可能出现的异常</p><p>Java虚拟机孤帆允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<code>StackoverflowError</code>异常</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者创建新的线程时没够足够的内存去创建对应的虚拟机栈，那Java虚拟机栈将会抛出<code>outofMemoryError</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StackErrorTest&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.prinyln(count++);</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当栈深度达到9703的时候，就出现栈内存空间不足</p><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1k</span><br></pre></td></tr></table></figure><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。</p><p>在这个县城上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以栈帧格式存在。在这个线程上正在执行的每个方法都有各自对应一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中国的各种数据信息。</p><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循<strong>“先进后出”/“后进先出”</strong>原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705203142545.png" alt="image-20200705203142545"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackFrameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method02();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = method03();;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的开始&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法3的结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>的开始</span><br><span class="line">方法<span class="number">2</span>的开始</span><br><span class="line">方法<span class="number">3</span>的开始</span><br><span class="line">方法<span class="number">3</span>的结束</span><br><span class="line">方法<span class="number">2</span>的结束</span><br><span class="line">方法<span class="number">1</span>的结束</span><br></pre></td></tr></table></figure><p>满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210512114320863.png" alt="image-20210512114320863"></p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</p><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（operand Stack） （或表达式栈）</li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705204836977.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有各自的栈，并且每个栈里面都有很多栈帧，栈帧的到小主要由局部变量表 和 操作数栈决定的</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705205443993.png" alt="image-20200705205443993"></p><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p><code>局部变量表：Local Variables</code>，被称之为局部变量数组或本地变量表</p><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p><p>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是Slot（变量槽）局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p><p>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（1ong和double）占用两个slot。</p><blockquote><p>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>   1ong和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问1ong或doub1e类型变量）</p><p>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的s1ot处，其余的参数按照参数表顺序继续排列。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705212454445.png" alt="image-20200705212454445"></p><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlotTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVarl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localVar2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时的b就会复用a的槽位；</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><p>变量的分类：</p><ul><li>按数据类型分：基本数据类型、引用数据类型</li><li>按类中声明的位置分：成员变量（类变量，实例变量）、局部变量<ul><li>类变量：linking的paper阶段，给类变量默认赋值，init阶段给类变量显示赋值即静态代码块</li><li>实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值</li><li>局部变量：在使用前必须进行显式赋值，不然编译不通过。</li></ul></li></ul><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>操作数栈：Operand Stack</code></p><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 <strong>操作数栈</strong>，也可以称之为 <strong>表达式栈</strong>（Expression Stack）</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706090618332.png" alt="image-20200706090618332"></p><p>代码举例</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706090833697.png" alt="image-20200706090833697"></p><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。.</p><blockquote><p>这个时候数组是有长度的，因为数组一旦创建，那么就是不可变的</p></blockquote><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。|</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><p>我们给定代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap 命令反编译class文件： javap -v 类名.class</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706092610730.png" alt="image-20200706092610730"></p><blockquote><p>byte、short、char、boolean 内部都是使用int型来进行保存的</p><p>从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和  8进行入栈操作</p><p>同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作</p></blockquote><p>执行流程如下所示：</p><p>首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093131621.png" alt="image-20200706093131621"></p><p>执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093251302.png" alt="image-20200706093251302"></p><blockquote><p>为什么局部变量表不是从0开始的呢？</p><p>其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了~</p></blockquote><p>然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093646406.png" alt="image-20200706093646406"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093751711.png" alt="image-20200706093751711"></p><p>然后从局部变量表中，依次将数据放在操作数栈中</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093859191.png" alt="image-20200706093859191"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706093921573.png" alt="image-20200706093921573"></p><p>然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706094046782.png" alt="image-20200706094046782"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706094109629.png" alt="image-20200706094109629"></p><p>最后PC寄存器的位置指向10，也就是return方法，则直接退出方法</p><p>i++和++i的区别</p><h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p><code>栈顶缓存技术：Top of Stack Cashing</code></p><p>栈顶缓存技术：Top Of Stack Cashing</p><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>动态链接：Dynamic Linking</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706100311886.png" alt="image-20200706100311886"></p><blockquote><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p></blockquote><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中该栈帧所属方法的引用包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。</p><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706101251847.png" alt="image-20200706101251847"></p><blockquote><p>为什么需要运行时常量池？</p><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></blockquote><h2 id="方法调用：解析与分配"><a href="#方法调用：解析与分配" class="headerlink" title="方法调用：解析与分配"></a>方法调用：解析与分配</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期克制，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>对应的方法的绑定机制为：<strong>早期绑定（Early Binding）和晚期绑定（Late Binding）</strong>。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><h3 id="早晚期绑定的发展历史"><a href="#早晚期绑定的发展历史" class="headerlink" title="早晚期绑定的发展历史"></a>早晚期绑定的发展历史</h3><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><blockquote><p>子类对象的多态的使用前提</p><ul><li>类的继承关系</li><li>方法的重写</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。</p><h3 id="invokednamic指令"><a href="#invokednamic指令" class="headerlink" title="invokednamic指令"></a>invokednamic指令</h3><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><h3 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h3><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p><blockquote><p>Java：String info = “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)</p><p>JS：var name = “shkstart”;    var name = 10;    （运行时才进行检查）</p></blockquote><h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><h4 id="Java-语言中方法重写的本质："><a href="#Java-语言中方法重写的本质：" class="headerlink" title="Java 语言中方法重写的本质："></a>Java 语言中方法重写的本质：</h4><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.1ang.I1legalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li></ul><h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表<br>（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706144954070.png" alt="image-20200706144954070"></p><p>如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。</p><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li><p>正常执行完成</p></li><li><p>出现未处理的异常，非正常退出</p></li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。</p><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200706154554604.png" alt="image-20200706154554604"></p><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题</span></span><br><span class="line"><span class="comment"> * 方法中定义局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 陌溪</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-07-06-16:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1的声明方式是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程内部创建的，属于局部变量</span></span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">method04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stringBuilder 是线程不安全的，操作的是共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">(StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时并发的执行，会出现线程不安全的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        method02(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StringBuilder是线程安全的，但是String也可能线程不安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</strong></p><p>运行时数据区，是否存在Error和GC？</p><table><thead><tr><th>运行时数据区</th><th>是否存在Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>否</td></tr><tr><td>虚拟机栈</td><td>是</td><td>否</td></tr><tr><td>本地方法栈</td><td>是</td><td>否</td></tr><tr><td>方法区</td><td>是（OOM）</td><td>是</td></tr><tr><td>堆</td><td>是</td><td>是</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚拟机栈&quot;&gt;&lt;a href=&quot;#虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈&quot;&gt;&lt;/a&gt;虚拟机栈&lt;/h1&gt;&lt;h2 id=&quot;虚拟机栈概述&quot;&gt;&lt;a href=&quot;#虚拟机栈概述&quot; class=&quot;headerlink&quot; title=&quot;虚拟机栈概</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>6.JVM —— 程序计数器</title>
    <link href="https://leslieaibin.github.io/2021/05/12/Java/JVM/6.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>https://leslieaibin.github.io/2021/05/12/Java/JVM/6.%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</id>
    <published>2021-05-11T16:15:42.000Z</published>
    <updated>2021-05-12T08:15:01.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JVM中的<code>程序计数器（Program Counter Register)</code>中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有吧数据装在寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC寄存器（或指令寄存器）会更加贴切（也称为程序钩子)，并且不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705155551919.png" alt="image-20200705155551919"></p><p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都会有自己的额程序计数器，是线程私有的，生命周期与线程的声明周期保持一致。</p><p>任何时间一个线程都是只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址：或者是执行native方法，则是未指定值（undefend）.</p><p>他是唯一一个在Java虚拟机规范中没有规定任何outMemoryError情况的区域。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705155728557.png" alt="image-20200705155728557"></p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegisterTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i  = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j  = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k  = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: bipush        10</span><br><span class="line">2: istore_1</span><br><span class="line">3: bipush        20</span><br><span class="line">5: istore_2</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_2</span><br><span class="line">8: iadd</span><br><span class="line">9: istore_3</span><br><span class="line">10: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><p>通过PC寄存器，我们就可以知道当前程序执行到哪一步了 </p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161007423.png" alt="image-20200705161007423"></p><h2 id="使用PC寄存器存储字节码指令地址有什么用呢？"><a href="#使用PC寄存器存储字节码指令地址有什么用呢？" class="headerlink" title="使用PC寄存器存储字节码指令地址有什么用呢？"></a>使用PC寄存器存储字节码指令地址有什么用呢？</h2><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161409533.png" alt="image-20200705161409533"></p><h2 id="PC寄存器为什么被设定为私有的？"><a href="#PC寄存器为什么被设定为私有的？" class="headerlink" title="PC寄存器为什么被设定为私有的？"></a>PC寄存器为什么被设定为私有的？</h2><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161812542.png" alt="image-20200705161812542"></p><h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705161849557.png" alt="image-20200705161849557"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>5.JVM —— 运行时数据区概述及线程</title>
    <link href="https://leslieaibin.github.io/2021/05/11/Java/JVM/5.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://leslieaibin.github.io/2021/05/11/Java/JVM/5.%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-10T16:15:42.000Z</published>
    <updated>2021-05-12T08:14:43.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，他是类加载完成后的阶段</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705111640511.png" alt="image-20200705111640511"></p><p>当我们通过前面的：类的<strong>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化</strong>  这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705111843003.png" alt="image-20200705111843003"></p><p>也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序实时运行，JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高校稳定运行。不同JVM对于内存的划分方式和管理机制存在着部分差异。</p><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁。</p><p>运行时数据区的完整图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705112416101.png" alt="image-20200705112416101"></p><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705112601211.png" alt="image-20200705112601211"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。<br>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run（）方法。</p><h3 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h3><p>如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main（String[]）的main线程以及所有这个main线程自己创建的线程。|<br>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运行时数据区概述及线程&quot;&gt;&lt;a href=&quot;#运行时数据区概述及线程&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区概述及线程&quot;&gt;&lt;/a&gt;运行时数据区概述及线程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>4.JVM —— 类加载子系统</title>
    <link href="https://leslieaibin.github.io/2021/05/10/Java/JVM/4.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://leslieaibin.github.io/2021/05/10/Java/JVM/4.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-05-09T16:15:42.000Z</published>
    <updated>2021-05-10T11:11:02.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705080719531.png" alt="image-20200705080719531"></p><p>完整图如下</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705080911284.png" alt="image-20200705080911284"></p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="类加载器子系统作用"><a href="#类加载器子系统作用" class="headerlink" title="类加载器子系统作用"></a>类加载器子系统作用</h2><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p><p>ClassLoader只负责class文件的加载，至于他是否可以运行，则有Execution Engine决定。</p><p>加载的信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705081813409.png" alt="image-20200705081813409"></p><ul><li><p>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</p></li><li><p>class file加载到JVM中，被称为DNA元数据模板，放在方法区。</p></li><li><p>在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705081913538.png" alt="image-20200705081913538"></p></li></ul><h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>例如下面的一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLoder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经被加载了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载的过程：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705082255746.png" alt="image-20200705082255746"></p><p>完整的流程图如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705082601441.png" alt="image-20200705082601441"></p><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p>通过一个类的全限定名获取定义此类的二进制字节流</p><p>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</p><p>在内存生成一个代表这个类的java.lang.Class对象，作为方法区这个类的歌中数据访问入口</p><h3 id="加载class文件的方式"><a href="#加载class文件的方式" class="headerlink" title="加载class文件的方式"></a>加载class文件的方式</h3><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705084038680.png" alt="image-20200705084038680"></p><p>如果出现不合法的字节码文件，那么将会验证不通过</p><p>同时我们可以通过安装IDEA的插件，来查看我们的Class文件</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705090237078.png" alt="image-20200705090237078"></p><p>安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210506191727686.png" alt="image-20210506191727686"></p><h3 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h3><p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// 准备阶段为0，在下个阶段，也就是初始化的时候才是1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的变量a在<strong>准备阶段</strong>会赋初始值，但不是1，而是0。</p><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><h3 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h3><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>初始化阶段就是执行类构造器法<clinit>()的过程</p><p>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p><ul><li>也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li></ul><p>构造器方法中指令按语句在源文件中出现的顺序执行。</p><p><clinit>（）不同于类的构造器。（关联：构造器是虚拟机视角下的<init>（））若该类具有父类，JVM会保证子类的<clinit>（）执行前，父类的<clinit>（）已经执行完毕。</p><ul><li>任何一个类在声明后，都有生成一个构造器，默认是空参构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(number);  <span class="comment">//报错，非法的前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassInitTest.num); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(ClassInitTest.number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于涉及到父类时候的变量赋值过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Son.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们输出结果为2，也就是说首先加载ClinitTest1的时候，会先找到main方法，然后执行Son的初始化，但是Son继承了Father的初始化，同时将A赋值为2。我们通过反编译得到Father的加载过程，首先我们看到原来的值被赋值成1，然后又被赋值成2，最后返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class="line">iconst_2</span><br><span class="line">putstatic #2 &lt;com/atguigu/java/chapter02/ClinitTest1$Father.A&gt;</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>虚拟机必须保证一个类<clinit>()方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t1开始&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> DeadThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 线程t2开始&quot;</span>);</span><br><span class="line">                <span class="keyword">new</span> DeadThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadThread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 代码，输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1 线程t1开始</span><br><span class="line">t1 初始化当前类</span><br><span class="line">t2 线程t2开始</span><br></pre></td></tr></table></figure><p>从上面可以看出初始化后，只能够执行一次初始化，这也就是同步加锁的过程</p><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p>JVM支持两种类型的类加载器。分别为引导类加载器（BootStrap ClassLoader) 和自定义类加载器（User-Defined ClassLoader)。</p><p>从概念上讲，自定义类加载器一般指的是程序中有开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型怎么划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705094149223.png" alt="image-20200705094149223"></p><p>这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统的类加载器</span></span><br><span class="line">        ClassLoader sysremClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;系统的类加载器：&quot;</span> + sysremClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取器上层的： 扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = sysremClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器&quot;</span> + extClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 视图获取 根加载器</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;根加载器：&quot;</span>  + bootstrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自定义加载器</span></span><br><span class="line">        ClassLoader classLoader = ClassLoader.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;自定义加载器&quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取String类型的加载器</span></span><br><span class="line">        ClassLoader classLoader1 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;String类型的加载器&quot;</span> + classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果，从结果可以看出根记载器无法直接通过代码获取，同时目前永辉diamante所使用的加载器系统类的加载器。同时我们通过获取String类型的加载器，发现是null,那么说明String类型是通过根记载器进行加载的，也就是说Java的核心类库都是使用跟家在其进行加载的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">系统的类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">扩展类加载器sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">根加载器：null</span><br><span class="line">自定义加载器null</span><br><span class="line">String类型的加载器null</span><br></pre></td></tr></table></figure><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader)"></a><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader)</strong></h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h3><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><h3 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h3><ul><li>javI语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader#getSystemclassLoader（）方法可以获取到该类加载器</li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。<br>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ul><li>开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写1oadClass（）方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖1oadclass（）方法，而是建议把自定义的类加载逻辑写在findclass（）方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705103516138.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705103636003.png" alt="image-20200705103636003"></p><p>获取<code>ClassLoader</code>的途径</p><ul><li>获取当前<code>ClassLoader：clazz.getClassLoader()</code></li><li>获取当前线程上下文的<code>ClassLoader：Thread.currentThread().getContextClassLoader()</code></li><li>获取系统的<code>ClassLoader：ClassLoader.getSystemClassLoader()</code></li><li>获取调用者的<code>ClassLoader：DriverManager.getCallerClassLoader()</code></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是 <strong>双薪委派模式</strong>，即把请求交到由父类处理，它是一种任务委派模式。</p><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ul><li>如果一个类加载器收到了类加载请求，他不会自己先去加载，而是把这个请求委派给父类的加载器去执行</li><li>如果父类加载器还存在父类加载器，则进一步向上委托，一次递归，请求最终将叨叨顶层的启动类加载器</li><li>如果父类加载器可以完成类加载器任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这既是双亲委派任务模式。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705105151258.png" alt="image-20200705105151258"></p><h3 id="双亲委派机制举例"><a href="#双亲委派机制举例" class="headerlink" title="双亲委派机制举例"></a>双亲委派机制举例</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20200705105810107.png" alt="image-20200705105810107"></p><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h3 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a>双亲委派机制的优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如何判断俩个class对象是否相同</p><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。</li></ul><p>换句话说，在JVM中，即使这两个类对象来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是有用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一步保存在<strong>方法区</strong>中，当解析一个类型到另一个类型的引用的时候JVM需要保证这两个类型的类加载器是相同的。</p><h3 id="类的制动使用和被动使用"><a href="#类的制动使用和被动使用" class="headerlink" title="类的制动使用和被动使用"></a>类的制动使用和被动使用</h3><p>Java程序对类的使用方式分为：<strong>主动使用和被动使用</strong></p><p>主动使用又分为七种情况：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被表明为启动类的类</li><li>JDK7开始提供的动态语言支持</li><li>java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类加载子系统&quot;&gt;&lt;a href=&quot;#类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;类加载子系统&quot;&gt;&lt;/a&gt;类加载子系统&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://leslieaibin.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>8.CAS &amp; ABA &amp; AQS</title>
    <link href="https://leslieaibin.github.io/2021/05/04/Java/Thread/8.CAS%20&amp;%20ABA%20&amp;%20AQS/"/>
    <id>https://leslieaibin.github.io/2021/05/04/Java/Thread/8.CAS%20&amp;%20ABA%20&amp;%20AQS/</id>
    <published>2021-05-04T02:15:42.000Z</published>
    <updated>2021-05-04T08:13:32.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p><code>CAS（Compare And Swap）</code>指比较并交换。CAS算法CAS(V,E, N)包含3个参数，V表示要更新的变量，E表示预期的值，N表示新值。在且仅在V值等于 E值时，才会将V值设为 N，如果 V值和 E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。最后，CAS返回当前V的真实值。</p><h2 id="CAS的特性：乐观锁"><a href="#CAS的特性：乐观锁" class="headerlink" title="CAS的特性：乐观锁"></a>CAS的特性：乐观锁</h2><p>CAS操作采用了乐观锁的思想，总是认为自己可以成功完成操作。在有多个线程同时使用CAS操作一个变量时，只有一个会胜出并成功更新，其余均会失败。失败的线程不会被挂起，仅被告知失败，并且允许再次尝试，当然，也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><h2 id="CAS自旋等待"><a href="#CAS自旋等待" class="headerlink" title="CAS自旋等待"></a>CAS自旋等待</h2><p>在JDK的原子包<code>java.util.concurrent.atomic</code>里面提供了一组原子类，这些原子类的基本特性就是在多线程环境下，在有多个线程同时执行这些类的实例包含的方法时，会有排他性。其内部便是基于CAS算法实现的，即在某个线程进入方法中执行其中的指令时，不会被其他线程打断；而别的线程就像自旋锁一样，一直等到该方法执行完成才由JVM从等待的队列中选择另一个线程进入。</p><p>相对于synchronized阻塞算法，CAS是非阻塞算法的一种常见实现。由于CPU的切换比CPU指令集的操作更加耗时，所以CAS的自旋操作在性能上有了很大的提升。</p><h1 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h1><p>对CAS算法的实现有一个重要的前提：需要取出内存中某时刻的数据，然后在下一时刻进行比较、替换，在这个时间差内可能数据已经发生了变化，导致产生ABA问题。</p><p>ABA问题指第1个线程从内存的V位置取出A，这时第2个线程也从内存中取出A，并将V位置的数据首先修改为B，接着又将V位置的数据修改为A，这时第1个线程在进行CAS操作时会发现在内存中仍然是A，然后第1个线程操作成功。尽管从第1个线程的角度来说，CAS操作是成功的，但在该过程中其实V位置的数据发生了变化，只是第1个线程没有感知到罢了，这在某些应用场景下可能出现过程数据不一致的问题。</p><p>部分乐观锁是通过<code>版本号（version）</code>来解决ABA问题的，具体的操作是乐观锁每次在执行数据的修改操作时都会带上一个版本号，在预期的版本号和数据的版本号一致时就可以执行修改操作，并对版本号执行加1操作，否则执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为<strong>版本号只会增加，不会减少</strong>。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p><code>AQS(Abstract Aueued Synchronizer)</code>是一个抽象的队列同步器，通过维护一个共享资源状态（Volatile Int State) 和一个先进先出（FIFO）的线程等待队列来实现一个多线程访问共享资源的同步框架。</p><h2 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h2><p>AQS为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度。许多同步类的实现都依赖于AQS，例如常用的ReentrantLock、Semaphore和CountDownLatch。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210504160648860.png" alt="image-20210504160648860"></p><h2 id="state：状态"><a href="#state：状态" class="headerlink" title="state：状态"></a>state：状态</h2><p>Abstract Queued Synchronizer维护了一个volatile int类型的变量，用于表示当前的同步状态。Volatile虽然不能保证操作的原子性，但是能保证当前变量state的可见性。state的访问方式有三种：<code>getState()、setState()和compareAndSetState()</code>，均是原子操作，其中，compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()。</p><h2 id="AQS共享资源的方式：独占式和共享式"><a href="#AQS共享资源的方式：独占式和共享式" class="headerlink" title="AQS共享资源的方式：独占式和共享式"></a>AQS共享资源的方式：独占式和共享式</h2><p>AQS定义了两种资源共享方式：<code>独占式（Exclusive）和共享式（Share）</code>。</p><ul><li>独占式：只有一个线程能执行，具体的Java实现有ReentrantLock。</li><li>共享式：多个线程可同时执行，具体的Java实现有Semaphore和CountDownLatch。</li></ul><p>AQS只是一个框架，只定义了一个接口，具体资源的获取、释放都交由自定义同步器去实现。不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，如获取资源失败入队、唤醒出队等，AQS已经在顶层实现好，不需要具体的同步器再做处理。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210504161124244.png" alt="image-20210504161124244"></p><p>同步器的实现是AQS的核心内存。ReentrantLock对AQS的独占方式实现为：ReentrantLock中的state初始值为0时表示无锁状态。在线程执行tryAcquire()获取该锁后ReentrantLock中的state+1，这时该线程独占ReentrantLock锁，其他线程在通过tryAcquire()获取锁时均会失败，直到该线程释放锁后state再次为0，其他线程才有机会获取该锁。该线程在释放锁之前可以重复获取此锁，每获取一次便会执行一次state+1，因此ReentrantLock也属于可重入锁。但获取多少次锁就要释放多少次锁，这样才能保证state最终为0。如果获取锁的次数多于释放锁的次数，则会出现该线程一直持有该锁的情况；如果获取锁的次数少于释放锁的次数，则运行中的程序会报锁异常。</p><p>CountDownLatch对AQS的共享方式实现为：CountDownLatch将任务分为N个子线程去执行，将state也初始化为N, N与线程的个数一致，N个子线程是并行执行的，每个子线程都在执行完成后countDown()一次，state会执行CAS操作并减1。在所有子线程都执行完成（state=0）时会unpark()主线程，然后主线程会从await()返回，继续执行后续的动作。</p><p>一般来说，自定义同步器要么采用独占方式，要么采用共享方式，实现类只需实现tryAcquire、tryRelease或tryAcquireShared、tryReleaseShared中的一组即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，例如ReentrantReadWriteLock在读取时采用了共享方式，在写入时采用了独占方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS&quot;&gt;&lt;a href=&quot;#CAS&quot; class=&quot;headerlink&quot; title=&quot;CAS&quot;&gt;&lt;/a&gt;CAS&lt;/h1&gt;&lt;h2 id=&quot;什么是CAS&quot;&gt;&lt;a href=&quot;#什么是CAS&quot; class=&quot;headerlink&quot; title=&quot;什么是CAS&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>7.线程上下文切换与阻塞队列</title>
    <link href="https://leslieaibin.github.io/2021/05/04/Java/Thread/7.%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://leslieaibin.github.io/2021/05/04/Java/Thread/7.%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2021-05-03T16:15:42.000Z</published>
    <updated>2021-05-04T08:15:01.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h1><p>CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。任务的状态保存及再加载交做线程的上下文切换。</p><ul><li><strong>进程：</strong>指一个运行中的程序的示例。在一个进程内部可以有多个线程在同时运行，并与创建它的进程共享同一个地址空间（一段内存区域）和其他资源。</li><li><strong>上下文：</strong>指线程切换时CPU寄存器和程序计数器所保存的当前线程信息。</li><li><strong>寄存器：</strong>指CPU内部容量较小但速度很快的内存区域（与之对应的是CPU外部相对较慢的RAM主内存）。寄存器通过对常用值（同创是运算的中间值）快速访问来加快计算机程序运行的速度。</li><li><strong>程序计数器：</strong> 是一个专用的寄存器，用于表明指令序列中CPU正在执行的位置，存储的值为正在执行的指令的位置或者下一个将被执行的指令的位置，这依赖于特定的系统。</li></ul><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换。上下文切换过程中的信息被保存在进程控制块<code>（PCB-Process Control Block）</code>中。PCB又被称作切换桢<code>（SwitchFrame）</code>。上下文切换的信息会一直被保存在CPU的内存中，直到被再次使用。上下文的切换流程如下。</p><ul><li>挂起一个进程，将这个进程在CPU中的状态（上下文信息）存储于内存的PCB中。</li><li>在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复。</li><li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程。时间片轮转方式使多个任务在同一CPU上的执行有了可能。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210503143118716.png" alt="image-20210503143118716"></p><h2 id="上下文切换的原因"><a href="#上下文切换的原因" class="headerlink" title="上下文切换的原因"></a>上下文切换的原因</h2><p>上下文切换的原因如下：</p><ul><li>当前正在执行的任务完成，系统的CPU正常调度下一个任务。</li><li>当前正在执行的任务遇到I/O等阻塞操作，调度器挂起此任务，继续调度下一个任务。</li><li>多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。</li><li>用户的代码挂起当前任务，比如线程执行sleep方法，让出CPU。</li><li>硬件中断</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上下文切换就是一个工作的线程被另外一个线程暂停，另外一个线程占用了处理器开始执行任务的过程。系统和 Java 程序自发性以及非自发性的调用操作，就会导致上下文切换，从而带来系统开销。</p><p>线程越多，系统的运行速度不一定越快。那么我们平时在并发量比较大的情况下，什么时候用单线程，什么时候用多线程呢？</p><p>一般在单个逻辑比较简单，而且速度相对来非常快的情况下，我们可以使用单线程。例如，我们前面讲到的 Redis，从内存中快速读取值，不用考虑 I/O 瓶颈带来的阻塞问题。而在逻辑相对来说很复杂的场景，等待时间相对较长又或者是需要大量计算的场景，我建议使用多线程来提高系统的整体性能。例如，NIO 时期的文件读写操作、图像处理以及大数据分析等。</p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>队列是一种只允许在表的前端进行删除操作，而在表的后端进行插入操作的线性表。阻塞队列和一般队列的不同之处在于阻塞队列是”阻塞”的，这里的阻塞指的是操作队列的线程的一种状态。在阻塞队列中，线程阻塞有两种情况：</p><ul><li><strong>消费者阻塞：</strong>在队列为空时，消费者端的线程都会被自动阻塞（挂起），直到有数据放入队列，消费者线程会被自动唤醒并消费数据，如图</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210503153612863.png" alt="image-20210503153612863"></p><ul><li><p><strong>生产者阻塞：</strong> 在队列已满且没有可用空间时，生产者端的线程都会被自动阻塞（挂起），直到队列中有空的位置腾出来，线程会被自动唤醒并生产数据。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210503153741909.png" alt="image-20210503153741909"></p></li></ul><h2 id="阻塞队列的主要操作"><a href="#阻塞队列的主要操作" class="headerlink" title="阻塞队列的主要操作"></a>阻塞队列的主要操作</h2><p>阻塞队列的主要操作有插入操作和移除操作。插入操作有add(e)、offer(e)、put(e)、offer(e，time，unit)，移除操作有remove()，poll()，take()，poll(time，unit)。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>1、<code>public abstract boolean add(E paramE):</code>将指定的元素插入队列中，在成功时返回true，如果当前没有可用的空间，则抛出IllegalStateException。如果该元素是null，则抛出NullPointerException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个数据，如果添加成功，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果添加失败，则返回异常</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 、<code>public abstract boolean offer(E paramE)：</code>将指定的元素插入队列中，在成功时返回true，如果当前没有可用的空间，则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 如果队列满了， 则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="comment">// 如果队列有空间，则将元素加入队列中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>offer(E o, long timeout, TimeUnit unit)：</code>将指定的元素插入队列中，可以设定等待的时间，如果在设定的等待时间内仍不能向队列中加入元素，则返回false。</p><p>4、<code>public abstract void put(E paramE) throwsInterruptedException：</code>将指定的元素插入队列中，如果队列已经满了，则阻塞、等待可用的队列空间的释放，直到有可用的队列空间释放且插入成功为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrabtLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) <span class="comment">//阻塞等待可用空间的释放</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e); <span class="comment">// 将元素加入队列中</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取数据操作"><a href="#获取数据操作" class="headerlink" title="获取数据操作"></a>获取数据操作</h3><p>1、<code>poll()：</code>取走队列队首的对象，如果取不到数据，则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock =  <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁操作</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//如果获取不到 （count == 0） 则返回null</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; fianlly &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<code>poll(long timeout，TimeUnit unit)</code> 取出队列队首的对象，如果在指定的时间内队列有数据可取，则返回队列中的数据，否则等待一定时间，在等待超时并且没有数据可取时，返回null。</p><p>3、<code>take()：</code>取走队列队首的对象，如果队列为空，则进入阻塞状态等待，直到队列有新的数据被加入，再及时取出新加入的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取独占锁</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//如果队列为空，则进入阻塞状态，知道取到数据为止</span></span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">// 取出元素</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<code>drainTo(Collection collection)：</code>一次性从队列中批量获取所有可用的数据对象，同时可以指定获取数据的个数，通过该方法可以提升获取数据的效率，避免多次频繁操作引起的队列锁定。</p><h2 id="JDK7-提供了-7-个阻塞队列"><a href="#JDK7-提供了-7-个阻塞队列" class="headerlink" title="JDK7 提供了 7 个阻塞队列"></a>JDK7 提供了 7 个阻塞队列</h2><ul><li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue: 一个链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue: 一个支持优先级排序的无界阻塞队列</li><li>DelayQueue: 一个使用优先级队列实现的无届阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><strong>ArrayBlockingQueue</strong> 是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>访问者的公平性是使用可重入锁实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器 comparator 来指定元素的排序规则。元素按照升序排列。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：</p><ul><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度。使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。</li></ul><p>队列中的 Delayed 必须实现 compareTo 来指定元素的顺序。比如让延时时间最长的放在队列的末尾。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero ONLY if same object</span></span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">               ScheduledFutureTask x = (ScheduledFutureTask)other;</span><br><span class="line">               <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">               <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) -</span><br><span class="line">                     other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">           <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>如何实现 Delayed 接口</strong></p><p>我们可以参考 ScheduledThreadPoolExecutor 里 ScheduledFutureTask 类。这个类实现了 Delayed 接口。首先：在对象创建的时候，使用 time 记录前对象什么时候可以使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">           <span class="keyword">super</span>(r, result);</span><br><span class="line">           <span class="keyword">this</span>.time = ns;</span><br><span class="line">           <span class="keyword">this</span>.period = period;</span><br><span class="line">           <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用 getDelay 可以查询当前元素还需要延时多久，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>通过构造函数可以看出延迟时间参数 ns 的单位是纳秒，自己设计的时候最好使用纳秒，因为 getDelay 时可以指定任意单位，一旦以纳秒作为单位，而延时的时间又精确不到纳秒就麻烦了。使用时请注意当 time 小于当前时间时，getDelay 会返回负数。</p><p><strong>如何实现延时队列</strong></p><p>延时队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">long</span> delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                   <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">return</span> q.poll();</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                       available.await();</span><br></pre></td></tr></table></figure><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景, 比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</p><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。</p><p>transfer 方法。如果当前有消费者正在等待接收元素（消费者使用 take() 方法或带时间限制的 poll() 方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。transfer 方法的关键代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">Node pred &#x3D; tryAppend(s, haveData);</span><br><span class="line">return awaitMatch(s, pred, e, (how &#x3D;&#x3D; TIMED), nanos);</span><br></pre></td></tr></table></figure><p>第一行代码是试图把存放当前元素的 s 节点作为 tail 节点。第二行代码是让 CPU 自旋等待消费者消费元素。因为自旋会消耗 CPU，所以自旋一定的次数后使用 Thread.yield() 方法来暂停当前正在执行的线程，并执行其他线程。</p><p>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</p><p>对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit) 方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。</p><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。</p><p>在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程上下文切换&quot;&gt;&lt;a href=&quot;#线程上下文切换&quot; class=&quot;headerlink&quot; title=&quot;线程上下文切换&quot;&gt;&lt;/a&gt;线程上下文切换&lt;/h1&gt;&lt;p&gt;CPU利用时间片轮询来为每个任务都服务一定的时间，然后把当前任务的状态保存下来，继续服务下一个任务。</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>6.java中的锁</title>
    <link href="https://leslieaibin.github.io/2021/05/03/Java/Thread/6.java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://leslieaibin.github.io/2021/05/03/Java/Thread/6.java%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2021-05-03T02:15:42.000Z</published>
    <updated>2021-05-04T08:14:54.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><p>java中的锁主要用于保障多并发线程情况下数据的一致性，在多线程编程中为了保障数据的一致性，我们通常需要在使用对象或者方法之前加锁，这是如果有其他线程也需要使用该对象或者该方法，则首先要获得锁，如果某个线程发现锁正在被其他线程使用就会进入阻塞队列，等待锁的释放，知道其他线程执行完成并释放锁，该线程才有机会再次获取锁进行操作。这样就保障了在同一时刻只有一个线程持有该对象的锁并修改对象，从而保障数据的安全。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/7f749fc8.png" alt="img"></p><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别热不会修改该数据，所以不会上锁，但更新时会判断此期间别人有没有更新该数据，通常在写时先对出当前版本号然后加锁的方法。具体过程为：比较当前版本号与上一次的版本号，如果版本号一致，则更新，如果版本号不一致，则重复进行读、比较、写操作。</p><p>java中的乐观锁大部分是通过<code>CAS（Compar And Swap, 比较和交换）</code>操作实现的，CAS是一种原子更新操作，在对数据操作之前首先会比较当前值传入的值是否一样，如果一样则更新，否则不执行更新操作，直接返回失败状态。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁采用悲观思想处理数据，在每次读取数据时都认为别人会修改数据，所以每次在读写数据时都会上锁，这样别人想读写这个数据时就会阻塞，等待直拿到锁。</p><p>Java中的悲观锁大部分基于<code>AQS（Abstract Queued Synchronized, 抽象的队列同步器）</code>架构实现。AQS定义了一套多线程访问共享资源的同步框架，许多同步类的实现都依赖于它，例如常用的<code>Synchronized、ReentrantLock、Semaphore、CountDownLatch</code>等。该框架下的锁会现场时CAS乐观锁去获取锁，如果获取不到，则会转为悲观锁（如ReentrantLock）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/c8703cd9.png" alt="img"></p><p>根据从上面的概念描述可以发现：</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅度提升</li></ul><p>调用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------------------- 乐观锁的调用方式 -------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 需要保证多个线程使用的是同一个AtomicIntger</span></span><br><span class="line">atomicInteger.incrementAndGet;   <span class="comment">// 执行自增1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 --------------------</span></span><br><span class="line"><span class="comment">// synochronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> Reentrantlock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// 操作同步资源</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 <strong>Compare And Swap</strong>（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/feda866e.png" alt="img"></p><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码我们可以看出，<code>getAndAddInt()</code>循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在<code>compareAndSwapInt()</code>中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><ul><li><p>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作。</strong>对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ul><h2 id="自旋锁与适应性自旋锁"><a href="#自旋锁与适应性自旋锁" class="headerlink" title="自旋锁与适应性自旋锁"></a>自旋锁与适应性自旋锁</h2><h3 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h3><p>如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞，挂起状态，只需等一等（也叫作自旋），在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核状态上导致的锁时间消耗。</p><p>线程在自旋时会占用CPU，在线程长时间自旋获取不到锁时，将会产生CPU的浪费，甚至有时线程永远无法获取锁而导致CPU资源被永久占用，五哦一需要设定一个自旋等待的最大时间。在线程执行的时间超过自旋等待的最大时间后，线程会退出自旋模式并释放其持有的锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/452a3363.png" alt="img"></p><p><strong>自旋锁的优缺点</strong></p><ul><li><strong>优点：</strong>自旋锁可以减少CPU上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说性能大幅度提升，因为自旋的CPU耗时明显少于线程阻塞、挂起、再唤醒时两次CPU上下文切换所用的时间。◎</li><li><strong>缺点：</strong>在持有锁的线程占用锁时间过长或锁的竞争过于激烈时，线程在自旋过程中会长时间获取不到锁资源，将引起CPU的浪费。所以在系统中有复杂锁依赖的情况下不适合采用自旋锁。</li></ul><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/83b3f85e.png" alt="img"></p><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h2 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p><strong>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</strong></p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><table><thead><tr><th align="left">锁状态</th><th align="left">存储内容</th><th align="left">存储内容</th></tr></thead><tbody><tr><td align="left">无锁</td><td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td align="left">01</td></tr><tr><td align="left">偏向锁</td><td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td align="left">01</td></tr><tr><td align="left">轻量级锁</td><td align="left">指向栈中锁记录的指针</td><td align="left">00</td></tr><tr><td align="left">重量级锁</td><td align="left">指向互斥量（重量级锁）的指针</td><td align="left">10</td></tr></tbody></table><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a><strong>无锁</strong></h3><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h3><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8afdf6f2.png" alt="img"></p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/a23d746a.png" alt="img"></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4499559e.png" alt="img"></p><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/6edea205.png" alt="img"></p><p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/bc6fe583.png" alt="img"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/bd0036bb.png" alt="img"></p><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h2 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/58fc5bc9.png" alt="img"></p><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/ea597a0c.png" alt="img"></p><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/32536e7a.png" alt="img"></p><h2 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h2><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/762a042b.png" alt="img"></p><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8793e00a.png" alt="img"></p><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8b7878ec.png" alt="img"></p><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java”锁”事</a></p><p><a href="https://weread.qq.com/web/reader/d0c3212071a74c21d0c04fd">Java中的锁</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中的锁&quot;&gt;&lt;a href=&quot;#Java中的锁&quot; class=&quot;headerlink&quot; title=&quot;Java中的锁&quot;&gt;&lt;/a&gt;Java中的锁&lt;/h1&gt;&lt;p&gt;java中的锁主要用于保障多并发线程情况下数据的一致性，在多线程编程中为了保障数据的一致性，我们通常</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>5.线程的生命周期和常用方法</title>
    <link href="https://leslieaibin.github.io/2021/04/29/Java/Thread/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://leslieaibin.github.io/2021/04/29/Java/Thread/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-29T02:15:42.000Z</published>
    <updated>2021-04-29T08:18:46.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 <strong>新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态</strong>。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是 <strong>线程状态也会多次在运行、阻塞之间切换</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,                <span class="comment">// 新创建的线程，未调用 start() 方法</span></span><br><span class="line">    RUNNABLE,           <span class="comment">// 线程正在运行中：可能是在 JVM 中运行，也可能在等待 CPU 时间片</span></span><br><span class="line">    BLOCKED,            <span class="comment">// 阻塞状态： 正等待锁的释放以进入同步区</span></span><br><span class="line">    WAITING,            <span class="comment">// 等待状态： 需要被其他线程唤醒才能重新进入 RUNNABLE 状态</span></span><br><span class="line">    TIMED_WAITING,      <span class="comment">// 超时等待状态： 等待一个具体的时间段，到期会被自动唤醒</span></span><br><span class="line">    TERMINATED;         <span class="comment">// 线程执行结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/bVbClUm" alt="线程状态转换图"></p><p>其流程：</p><ul><li>调用<code>new</code>方法新建一个线程，这时线程处于<code>新建状态</code></li><li>调用<code>start</code> 方法启动一个线程， 这时线程处于<code>就绪状态</code></li><li>处于就绪状态的线程等待线程获取CPU资源，在等待其获取CPU资源后线程会执行<code>run</code>方法进入<code>运行状态</code></li><li>正在运行的线程在调用了<code>yield</code>方法或失去处理器资源时，会再次进入<code>就绪状态</code></li><li>正在执行的线程在执行了<code>sleep</code>方法、I/O阻塞、等待同步锁、等待通知、调用suspend方法等操作后，会挂起并进入<code>阻塞状态</code>，进入<code>Blocked池</code>。</li><li><code>阻塞状态</code>的线程由于出现<code>sleep时间已到</code>、I/O方法返回、获得同步锁、收到通知、调用resume方法等情况，会再次进入<code>就绪状态</code>，等待CPU时间片的轮询。该线程在获取CPU资源后，会再次进入<code>运行状态</code>。</li><li>处于<code>运行状态</code>的线程，在调用<code>run方法或call方法</code>正常执行完成、调用stop方法停止线程或者程序执行错误导致异常退出时，会进入<code>死亡状态</code>。</li></ul><h2 id="新建状态：New"><a href="#新建状态：New" class="headerlink" title="新建状态：New"></a>新建状态：New</h2><p>在Java中使用new关键字创建一个线程，新创建的线程将处于新建状态。在创建线程时主要是为线程分配内存并初始化其成员变量的值。</p><ul><li><p><strong>此时JVM为其分配内存，并初始化其成员变量的值</strong>；</p></li><li><p><strong>此时线程对象没有表现出任何线程的动态特征</strong>，程序也不会执行线程的线程执行体；</p></li></ul><h2 id="就绪（Runnable）状态"><a href="#就绪（Runnable）状态" class="headerlink" title="就绪（Runnable）状态"></a>就绪（Runnable）状态</h2><p>当线程对象调用了start()方法之后，该线程处于 <strong>就绪状态</strong>。此时的线程情况如下：</p><ul><li><p>此时JVM会为其 <strong>创建方法调用栈和程序计数器</strong>；</p></li><li><p>该状态的线程一直处于 <strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，<strong>把它称为可运行池而不是可运行队列</strong>。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；</p></li><li><p>此时线程 <strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</p></li></ul><p><strong>调用start()方法与run()方法，对比如下：</strong></p><ul><li><p><strong>调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理</strong>。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，<strong>系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体</strong>；</p></li><li><p>需要指出的是，调用了线程的run()方法之后，<strong>该线程已经不再处于新建状态</strong>，不要再次调用线程对象的start()方法。<strong>只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常</strong>；</p></li></ul><h2 id="运行（Running）状态"><a href="#运行（Running）状态" class="headerlink" title="运行（Running）状态"></a>运行（Running）状态</h2><p>当CPU开始调度处于 <strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 <strong>运行状态</strong>。</p><ul><li>如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；</li><li>如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；</li><li>当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</li></ul><p>处于运行状态的线程最为复杂，它 <strong>不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）</strong>，线程在运行过程中需要被中断，<strong>目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略</strong>。线程状态可能会变为 <strong>阻塞状态、就绪状态和死亡状态</strong>。比如：</p><ul><li><p>对于采用 <strong>抢占式策略</strong> 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 <strong>从运行状态变为就绪状态</strong>，重新等待系统分配资源；</p></li><li><p>对于采用 <strong>协作式策略</strong>的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—<strong>也就是必须由该线程主动放弃所占用的资源</strong>，线程就会又 <strong>从运行状态变为就绪状态</strong>。</p></li></ul><h2 id="阻塞（Blocked）状态"><a href="#阻塞（Blocked）状态" class="headerlink" title="阻塞（Blocked）状态"></a>阻塞（Blocked）状态</h2><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 <strong>阻塞状态</strong>。</p><p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p><ul><li><strong>线程调用sleep()方法</strong>，主动放弃所占用的处理器资源，暂时进入中断状态（<strong>不会释放持有的对象锁</strong>），时间到后等待系统分配CPU继续执行；</li><li><strong>线程调用一个阻塞式IO方法</strong>，在该方法返回之前，该线程被阻塞；</li><li><strong>线程试图获得一个同步监视器</strong>，但该同步监视器正被其他线程所持有;</li><li><strong>程序调用了线程的suspend方法将线程挂起</strong>；</li><li><strong>线程调用wait</strong>，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</li></ul><p><strong>阻塞状态分类：</strong></p><ul><li><strong>等待阻塞</strong>：运行状态中的 <strong>线程执行wait()方法</strong>，使本线程进入到等待阻塞状态；</li><li><strong>同步阻塞</strong>：线程在 <strong>获取synchronized同步锁失败</strong>（因为锁被其它线程占用），它会进入到同步阻塞状态；</li><li><strong>其他阻塞</strong>：通过调用线程的 <strong>sleep()或join()或发出I/O请求</strong> 时，线程会进入到阻塞状态。当 <strong>sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕</strong> 时，线程重新转入就绪状态；</li></ul><p><strong>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态</strong>。而就绪和运行状态之间的转换通常不受程序控制，<strong>而是由系统线程调度所决定</strong>。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；<strong>当处于运行状态的线程失去处理器资源时，该线程进入就绪状态</strong>。</p><p>但有一个方法例外，<strong>调用yield()方法可以让运行状态的线程转入就绪状态</strong>。</p><h3 id="等待（WAITING）状态"><a href="#等待（WAITING）状态" class="headerlink" title="等待（WAITING）状态"></a>等待（WAITING）状态</h3><p>线程处于 <strong>无限制等待状态</strong>，等待一个特殊的事件来重新唤醒，如：</p><ul><li>通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；</li><li>通过join()方法进行等待的线程等待目标线程运行结束而唤醒；</li></ul><p>以上两种一旦通过相关事件唤醒线程，线程就进入了 <strong>就绪（RUNNABLE）状态</strong> 继续运行。</p><h3 id="时限等待（TIMED-WAITING）状态"><a href="#时限等待（TIMED-WAITING）状态" class="headerlink" title="时限等待（TIMED_WAITING）状态"></a>时限等待（TIMED_WAITING）状态</h3><p>线程进入了一个 <strong>时限等待状态</strong>，如：</p><ul><li><strong>sleep(3000)**，等待3秒后线程重新进行 **就绪（RUNNABLE）状态</strong> 继续运行。</li></ul><h2 id="死亡（Dead）状态"><a href="#死亡（Dead）状态" class="headerlink" title="死亡（Dead）状态"></a>死亡（Dead）状态</h2><p>线程会以如下3种方式结束，结束后就处于 <strong>死亡状态</strong>：</p><ul><li><p><strong>run()或call()方法执行完成</strong>，线程正常结束；</p></li><li><p><strong>线程抛出一个未捕获的Exception或Error</strong>；</p></li><li><p><strong>直接调用该线程stop()方法来结束该线程</strong>—该方法容易导致死锁，通常不推荐使用；</p></li></ul><p><strong>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程</strong>。线程一旦死亡，就不能复生。 <strong>如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常</strong>。</p><p><strong>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态</strong>。</p><h3 id="终止（TERMINATED）状态"><a href="#终止（TERMINATED）状态" class="headerlink" title="终止（TERMINATED）状态"></a>终止（TERMINATED）状态</h3><p>线程执行完毕后，进入终止（TERMINATED）状态。</p><h1 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程的启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 线程体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 已废弃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 已废弃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 已废弃</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 在指定的毫秒数内让当前正在执行的线程休眠</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span></span>; </span><br><span class="line">    <span class="comment">// 同上，增加了纳秒参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span>; </span><br><span class="line">    <span class="comment">// 测试线程是否处于活动状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 中断线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 测试线程是否已经中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 测试当前线程是否已经中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 等待该线程终止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">    <span class="comment">// 等待该线程终止的时间最长为 millis 毫秒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">    <span class="comment">// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16417a1fd6acc8f4" alt="线程方法状态转换"></p><h2 id="线程就绪、运行和死亡状态转换"><a href="#线程就绪、运行和死亡状态转换" class="headerlink" title="线程就绪、运行和死亡状态转换"></a>线程就绪、运行和死亡状态转换</h2><ol><li><strong>就绪状态转换为运行状态</strong>：此线程得到CPU资源；</li><li><strong>运行状态转换为就绪状态</strong>：此线程主动调用yield()方法或在运行过程中失去CPU资源。</li><li><strong>运行状态转换为死亡状态</strong>：此线程执行执行完毕或者发生了异常；</li></ol><h2 id="sleep-amp-yield"><a href="#sleep-amp-yield" class="headerlink" title="sleep &amp; yield"></a>sleep &amp; yield</h2><p><strong>sleep()**：通过sleep(millis)使线程进入休眠一段时间，</strong>该方法在指定的时间内无法被唤醒，同时也不会释放对象锁**；</p><p><strong>注意如下几点问题：</strong></p><ul><li><p><strong>sleep是静态方法，最好不要用Thread的实例对象调用它</strong>，<strong>因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象</strong>，<strong>它只对正在运行状态的线程对象有效</strong>。看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread&#x3D;new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        &#x2F;&#x2F; 这里sleep的就是main线程，而非myThread线程 </span><br><span class="line">        myThread.sleep(1000); </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><ul><li>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。<strong>因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它</strong>，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</li></ul><p><strong>yield()**：与sleep类似，</strong>也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程<strong>。但是和sleep()方法不同的是，</strong>它不会进入到阻塞状态，而是进入到就绪状态<strong>。yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：</strong>当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行**。</p><ul><li>实际上，<strong>当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会</strong>，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。</li></ul><p><strong>关于sleep()方法和yield()方法的区别如下</strong>：</p><ul><li><p>sleep方法暂停当前线程后，<strong>会进入阻塞状态</strong>，只有当睡眠时间到了，<strong>才会转入就绪状态</strong>。而yield方法调用后 ，<strong>是直接进入就绪状态</strong>，所以有可能刚进入就绪状态，又被调度到运行状态；</p></li><li><p><strong>sleep方法声明抛出了InterruptedException</strong>，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。<strong>而yield方法则没有声明抛出任务异常</strong>；</p></li><li><p>sleep方法比yield方法有更好的可移植性，<strong>通常不要依靠yield方法来控制并发线程的执行</strong>；</p></li></ul><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>线程的合并的含义就是 <strong>将几个并行线程的线程合并为一个单线程执行</strong>，应用场景是 <strong>当一个线程必须等待另一个线程执行完毕才能执行时</strong>，Thread类提供了join方法来完成这个功能，<strong>注意，它不是静态方法</strong>。</p><p><strong>join有3个重载的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">   <span class="comment">// 当前线程等该加入该线程后面，等待该线程终止。    </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>    </span></span><br><span class="line"><span class="function">   <span class="comment">// 当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span>    </span></span><br><span class="line"><span class="function">   <span class="comment">// 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状</span></span></span><br></pre></td></tr></table></figure><h2 id="suspend-amp-resume-已过时"><a href="#suspend-amp-resume-已过时" class="headerlink" title="suspend &amp; resume (已过时)"></a>suspend &amp; resume (已过时)</h2><p>suspend-<strong>线程进入阻塞状态，但不会释放锁</strong>。此方法已不推荐使用，<strong>因为同步时不会释放锁，会造成死锁的问题</strong>。</p><p>resume-<strong>使线程重新进入可执行状态</strong>。</p><p>为什么 Thread.suspend 和 Thread.resume 被废弃了？</p><p>Thread.suspend 天生容易引起死锁。<strong>如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了</strong>。这种死锁一般自身表现为“冻结（ frozen ）”进程。</p><h2 id="stop（已过时）"><a href="#stop（已过时）" class="headerlink" title="stop（已过时）"></a>stop（已过时）</h2><p><strong>不推荐使用，且以后可能去除，因为它不安全</strong>。为什么 Thread.stop 被废弃了？</p><p>因为其天生是不安全的。<strong>停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）</strong>。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。<strong>这种对象被称为受损的 （damaged）</strong>。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。</p><p><strong>不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程</strong>。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。</p><h2 id="wait-amp-notify-notifyAll"><a href="#wait-amp-notify-notifyAll" class="headerlink" title="wait &amp; notify/notifyAll"></a>wait &amp; notify/notifyAll</h2><p>wait &amp; notify/notifyAll这三个都是Object类的方法。使用 wait ，notify 和 notifyAll <strong>前提是先获得调用对象的锁</strong>。</p><p>调用 wait 方法后，释放持有的对象锁，<strong>线程状态有 Running 变为 Waiting</strong>，并将当前线程放置到对象的 <strong>等待队列</strong>；</p><p>调用notify 或者 notifyAll 方法后，<strong>等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回</strong>；</p><p>notify 方法：<strong>将等待队列的一个等待线程从等待队列种移到同步队列中</strong> ，而 notifyAll 方法：<strong>将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked</strong>。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每个线程执行时都有一个优先级的属性，<strong>优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会</strong>。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，<strong>优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行</strong>。</p><p><strong>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级</strong>；</p><p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   =<span class="number">10</span></span><br><span class="line">MIN_PRIORITY   =<span class="number">1</span></span><br><span class="line">NORM_PRIORITY   =<span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程与普通线程写法上基本没啥区别，**调用线程对象的方法setDaemon(true)**，则可以将其设置为守护线程。</p><p>守护线程使用的情况较少，但并非无用，举例来说，<strong>JVM的垃圾回收、内存管理等线程都是守护线程</strong>。还有就是在做数据库应用时候，使用的数据库连接池，<strong>连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等</strong>。</p><h2 id="如何结束一个线程"><a href="#如何结束一个线程" class="headerlink" title="如何结束一个线程"></a>如何结束一个线程</h2><p><strong>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit</strong> 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。</p><ul><li><p>正常执行完run方法，然后结束掉；</p></li><li><p>控制循环条件和判断条件的标识符来结束掉线程；</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://weread.qq.com/web/reader/d0c3212071a74c21d0c04fdk4e73277021a4e732ced3b55">线程生命周期</a></p><p><a href="https://juejin.cn/post/6844903558433734669#heading-8">啃碎并发（二）：Java线程的生命周期</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程的生命周期&quot;&gt;&lt;a href=&quot;#线程的生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程的生命周期&quot;&gt;&lt;/a&gt;线程的生命周期&lt;/h1&gt;&lt;p&gt;当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>4.常用的线程池</title>
    <link href="https://leslieaibin.github.io/2021/04/29/Java/Thread/4.%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://leslieaibin.github.io/2021/04/29/Java/Thread/4.%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-04-28T22:15:42.000Z</published>
    <updated>2021-04-29T06:49:32.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的线程池"><a href="#常用的线程池" class="headerlink" title="常用的线程池"></a>常用的线程池</h1><p>Java定义了Executor接口并在该接口中定义了<code>execute()</code>用于执行一个线程任务，然后通过<code>ExecutorService</code>实现<code>Executor</code>接口并指向具体线程操作。<code>ExecutorService</code>接口有多个实现类可用于创建不同的线程池。</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>newWorkStealingPool</code></td><td>可缓存的线程池</td></tr><tr><td><code>newFixedThreadPool</code></td><td>固定大小的线程池</td></tr><tr><td><code>newScheduledThreadPool</code></td><td>可做任务调度的线程池</td></tr><tr><td><code>newSingleThreadExecutor</code></td><td>单个线程的线程池</td></tr><tr><td><code>newWorkStealingPool</code></td><td>足够大小的线程池，JDK1.8新增</td></tr></tbody></table><h2 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newWorkStealingPool用于创建一个缓存线程池。之所以叫缓存线程池，是因为它创建新线程时如果有可重用的线程，则重用他们，否则重新创建一个新的线程并将其添加到线程池中。对于执行时间很短的任务而言<code>newWorkStealingPool</code>线程池能很大程度的重用线程进而提高系统性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Exectuors.newCachedThreadPool();</span><br></pre></td></tr></table></figure><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newFixedThreadPool用于创建一个固定线程数量的线程池，并将线程资源存放在队列中循环使用。在newFixedThreadPool线程池中，若处于活动状态的线程数量大于等于核心线程池的数量，则新提交的任务将在阻塞队列中排队，直到有可用的线程资源，具体的创建方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool  = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool创建了一个可定时调度的线程池，可设置在给定的延迟时间后执行或者定期执行某个线程任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建一个延迟3秒的执行线程</span></span><br><span class="line">scheduledExecutorService.schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delay 3 seconds execu.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 创建一个延迟1秒执行且每3秒执行一次的线程</span></span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delay 1 seconds, repeat execute every 3 seconds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newSingleThreadExecutor线程池会保证永远有且只有一个可用的线程，在该线程停止或发生异常时，newSingleThreadExecutor线程池会启动一个新的线程来代替该线程继续执行任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThread = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><h2 id="newWorkStealingPool-1"><a href="#newWorkStealingPool-1" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newWorkStealingPool创建持有足够线程的线程池来达到快速运算的目的，在内部通过使用多个队列来减少各个线程调度产生的竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService workStealing = Executors.newWorkStealingPool();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用的线程池&quot;&gt;&lt;a href=&quot;#常用的线程池&quot; class=&quot;headerlink&quot; title=&quot;常用的线程池&quot;&gt;&lt;/a&gt;常用的线程池&lt;/h1&gt;&lt;p&gt;Java定义了Executor接口并在该接口中定义了&lt;code&gt;execute()&lt;/code&gt;用于执行一个</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>3.线程池的工作原理</title>
    <link href="https://leslieaibin.github.io/2021/04/28/Java/Thread/3.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2021/04/28/Java/Thread/3.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2021-04-27T16:15:42.000Z</published>
    <updated>2021-04-29T02:51:26.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p>Java线程池主要用于主要用于管理线程组及其运行状态，以便java虚拟机更好地利用CPU资源。Java线程池的工作原理为：JVM先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建这些任务，如果正在运行的线程数量，超过了最大线程数量（用户设置的线程池大小），则超出数量的线程派对等候，在任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。</p><h2 id="线程池相关概念"><a href="#线程池相关概念" class="headerlink" title="线程池相关概念"></a>线程池相关概念</h2><ul><li><strong>核心线程CorePool：</strong>当有新任务提交时，如果核心线程都在工作，并且数量已经达到最大核心线程数，则不会新建核心线程，而是把任务放入等待队列。</li><li><strong>阻塞队列 workQueue:</strong> 等待队列是一个线程安全的阻塞队列。当线程都在忙时，阻塞队列用于存放新增的任务。核心线程完成当前任务回去等待队列中拉取新出的任务。</li><li><strong>非核心线程:</strong> 当等待队列满时，若当前总线程线程数没有查过最大线程数，则会创建新的非核心线程。<ul><li>核心线程与非核心线程没有区别，只会在比较线程池中线程数目时，区分核心线程与非核心线程。</li></ul></li><li><strong>线程活动保持时间keepAliveTime:</strong>  当一个线程空闲下来之后，其保持继续存活的时间。超过该时间则线程销毁。默认情况下，核心线程数量会一直保持，即使他空闲下来了；当设置<code>threadPoolExecutor.allowCoreThreadTimeOut(true)</code> 时，则对核心线程也执行销毁。</li><li><strong>饱和策略 rejectedExecutionHandler</strong> ： 当等待队列满，且总线程数达到最大线程数时，会执行饱和策略。默认饱和策略是抛弃新的任务请求。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20180423235340436" alt="img"></p><p>其中，<code>ThreadPoolExecutor</code> 是构建线程的核心方法，该方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize, <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize, <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="keyword">long</span> keepAliveTime, <span class="comment">// 空闲线程的存活时间</span></span><br><span class="line">    TimeUnit unit, <span class="comment">// keepAliveTime的时间单位</span></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 阻塞队列</span></span><br><span class="line">    ThreadFactory threadFactory, <span class="comment">// 线程工厂，用于创建线程</span></span><br><span class="line">    RejectedExecutionHandler handler); <span class="comment">// 饱和策略</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210428163209103.png" alt="image-20210428163209103"></p><p>这个花瓶由 瓶口 、 瓶颈 、 瓶身 三个部分组成。</p><p>这三个部分分别对应着线程池的三个参数：maximumPoolSize, workQueue,corePoolSize。</p><h3 id="Executor框架实例"><a href="#Executor框架实例" class="headerlink" title="Executor框架实例"></a>Executor框架实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            executorService.submit(() -&gt; System.out.println(<span class="string">&quot;i:&quot;</span> + index +</span><br><span class="line">                    <span class="string">&quot; executorService&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submit(Runnable task)方法提交一个线程。</p><p>但是使用最新的“阿里巴巴编码规范插件”检测一下会发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，</span><br><span class="line">这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </span><br><span class="line">说明：Executors各个方法的弊端：</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span>）newFixedThreadPool和newSingleThreadExecutor:</span><br><span class="line">  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</span><br><span class="line"><span class="number">2</span>）newCachedThreadPool和newScheduledThreadPool:</span><br><span class="line">  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        executorService.submit(() -&gt; System.out.println(<span class="string">&quot;i:&quot;</span> + index +</span><br><span class="line">                <span class="string">&quot; executorService&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a>线程复用</h2><p>线程复用的核心是，我们知道，<code>Thread.start()</code>只能调用一次，一旦这个调用结束，则该线程就到了stop状态，不能再次调用start。则要达到复用的目的，则必须从<code>Runnable</code>接口的<code>run()</code>方法上入手，可以这样设计这个Runnable.run()方法（就叫外面的run()方法）：<br>        它本质上是个无限循环，跑的过程中不断检查我们是否有新加入的子Runnable对象（就叫内部的runnable:run()吧，它就是用来实现我们自己的任务），有就调一下我们的run()，其实就一个大run()把其它小run()#1,run()#2,…给串联起来了，基本原理就这么简单。不停地处理我们提交的Runnable任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tasks available) &#123;</span><br><span class="line">           Runnable task = taskqueue.dequeue();</span><br><span class="line">           task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// wait or whatever</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h2><ul><li><p><strong>降低资源消耗</strong>：通过池化技术复用已创建的线程，降低线程创建和销毁造成的损耗。</p></li><li><p><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</p></li><li><p><strong>提高线程的可管理性</strong>：使用线程池可以进行统一的分配、调优和监控，避免线程被无限制地创建。</p></li><li><p><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池 <code>ScheduledThreadPoolExecutor</code>，就允许任务延期执行或定期执行。</p></li></ul><h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程"></p><h2 id="Java-线程池-ThreadPoolExecutor"><a href="#Java-线程池-ThreadPoolExecutor" class="headerlink" title="Java 线程池 ThreadPoolExecutor"></a>Java 线程池 ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>线程池在内部实际上构建了一个<strong>生产者-消费者</strong>模型，利用阻塞队列，将线程和任务解耦，并不直接关联，从而良好的缓冲任务，复用线程。</p><p>线程池的运行主要分成两部分：<strong>任务管理、线程管理</strong></p><ul><li>任务管理部分充当生产者，当任务提交后，线程池会判断该任务后续的流转：<ul><li>直接申请线程执行该任务</li><li>缓冲到队列中等待线程执行</li><li>拒绝该任务</li></ul></li><li>线程管理部分是消费者，线程被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会获取新的任务去执行，最终当线程获取不到任务的时候，线程会被回收。</li></ul><h3 id="线程池运行状态-runState"><a href="#线程池运行状态-runState" class="headerlink" title="线程池运行状态-runState"></a>线程池运行状态-runState</h3><table><thead><tr><th align="center">运行状态</th><th align="center">状态描述</th></tr></thead><tbody><tr><td align="center"><strong>RUNNING 运行状态</strong></td><td align="center">接收新任务，并且也能处理阻塞队列中的任务。</td></tr><tr><td align="center"><strong>SHUTDOWN 停工状态</strong></td><td align="center">不接收新任务，但是却可以继续处理阻塞队列中的任务。</td></tr><tr><td align="center"><strong>STOP停止状态</strong></td><td align="center">不接收新任务，同时也不处理队列任务，并且中断正在进行的任务。</td></tr><tr><td align="center"><strong>TIDYING清空状态</strong></td><td align="center">所有任务都已终止，workercount(有效线程数)为0，线程转向 TIDYING 状态将会运行 terminated() 钩子方法。</td></tr><tr><td align="center"><strong>TERMINATED终止状态</strong></td><td align="center">terminated() 方法调用完成后变成此状态。</td></tr></tbody></table><p>线程池生命周期状态转化：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/13888" alt="img"></p><h3 id="线程池任务执行机制"><a href="#线程池任务执行机制" class="headerlink" title="线程池任务执行机制"></a>线程池任务执行机制</h3><p><strong>线程池的任务调度 execute()</strong></p><p>当用户提交了一个任务，所有任务的调度都是由 <code>execute()</code> 方法完成的。包括：检查现在线程池的运行状态、运行线程数、运行策略，并决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。具体的<strong>执行过程</strong>如下：</p><ul><li><p>首先检测线程池运行状态 <code>runState</code>，如果不是 <code>RUNNING</code>，则直接拒绝，线程池要保证在 <code>RUNNING</code> 的状态下执行任务。</p></li><li><p>如果 <code>workerCount &lt; corePoolSize</code>，即核心线程还没创建满，则创建并启动一个核心线程来执行新提交的任务。</p></li><li><p>如果 <code>workerCount &gt;= corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</p></li><li><p>如果 <code>workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个非核心线程来执行新提交的任务。</p></li><li><p>如果 <code>workerCount &gt;= maximumPoolSize</code>，并且线程池内的阻塞队列已满, 则根据<strong>拒绝策略</strong>来处理该任务, 默认的处理方式是直接抛异常。</p></li></ul><h3 id="任务缓冲与阻塞队列-BlockingQueue"><a href="#任务缓冲与阻塞队列-BlockingQueue" class="headerlink" title="任务缓冲与阻塞队列 BlockingQueue"></a>任务缓冲与阻塞队列 BlockingQueue</h3><p>线程池维护了一个 <code>BlockingQueue&lt;Runnable&gt;</code> <strong>阻塞队列</strong>，用于存放等待执行的线程，队列中的所有线程都处于 <code>Runnable</code> 状态。队列的维护相当于一个 producer-consumer 模型，producer 把线程放入阻塞队列，consumer 从阻塞队列中拿出线程来执行。</p><ul><li><p>当阻塞队列满时，生产者线程会等待队列可用；</p></li><li><p>当阻塞队列空时，消费者线程会等待队列变成非空。</p></li></ul><h3 id="为什么用阻塞队列不用普通队列？"><a href="#为什么用阻塞队列不用普通队列？" class="headerlink" title="为什么用阻塞队列不用普通队列？"></a>为什么用阻塞队列不用普通队列？</h3><p>阻塞队列是为了实现生产者-消费者模型。当消费者从空的队列中取元素时，线程会被阻塞直到队列非空，然后消费者会被自动唤醒。</p><p>如果使用普通队列的话，需要我们自己去实现这样的同步和互斥机制，以及一些线程阻塞与唤醒的策略。</p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>若线程池中的核心线程数被用完且阻塞队列已拍满，则此时线程数的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。</p><ul><li><p><strong>AbortPolicy</strong>         </p><ul><li>当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbortPolicy 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 结果说明：</span></span><br><span class="line"><span class="comment"> * 将&quot;线程池的拒绝策略&quot;由DiscardPolicy修改为AbortPolicy之后，当有任务添加到线程池被拒绝时，会抛出RejectedExecutionException。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbortPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210429104351291.png" alt="image-20210429104351291"></p><p>只有0，1两个任务运行OK，其它的8个任务，在往线程池丢的时候，被线程池拒绝了，而且还抛了异常，被catch住了，catch了8次。</p></li></ul><ul><li><p><strong>CallerRunsPolicy</strong>  </p><ul><li>当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CallerRunsPolicy 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务</span></span><br><span class="line"><span class="comment"> * 翻译一下：就是不进入线程池执行，在这种方式（CallerRunsPolicy）中，任务将有调用者线程去执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallerRunsPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory);</span><br><span class="line">        <span class="comment">// 设置线程池的拒绝策略为&quot;CallerRunsPolicy&quot;</span></span><br><span class="line">        pool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210429104711573.png" alt="image-20210429104711573"></p><p>在任务往线程池丢的时候，发现线程池已经装不下了，那么这个时候，就让往线程池丢任务丢这个线程来执行这个任务，在此例子就是main线程了，从结果图可见线程池里面的一个线程和main一起干活，把10个任务给搞完了。</p></li></ul><ul><li><p><strong>DiscardOldestPolicy</strong></p><ul><li>当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</span></span><br><span class="line"><span class="comment"> * 结果说明：线程池pool的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，这意味着&quot;线程池能同时运行的任务数量最大只能是1&quot;。</span></span><br><span class="line"><span class="comment"> * 线程池pool的阻塞队列是ArrayBlockingQueue，ArrayBlockingQueue是一个有界的阻塞队列，ArrayBlockingQueue的容量为1。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。</span></span><br><span class="line"><span class="comment"> * 根据&quot;&quot;中分析的execute()代码可知：线程池中共运行了2个任务。第1个任务直接放到Worker中，通过线程去执行；第2个任务放到阻塞队列中等待。其他的任务都被丢弃了！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDiscardOldestPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory);</span><br><span class="line">        <span class="comment">// 设置线程池的拒绝策略为&quot;DiscardOldestPolicy&quot;</span></span><br><span class="line">        pool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210429104901856.png" alt="image-20210429104901856"></p><p>可见0任务到池子之后，运行，剩下1-9在来池子的时候，没位置了，都的排队，但位置就1个，那每次新来的都会不客气但把旧时代的给挤掉。也就是这个策略的名字的由来。</p></li><li><p><strong>DiscardPolicy</strong>    </p><ul><li>当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</span></span><br><span class="line"><span class="comment"> * 结果说明：线程池pool的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，这意味着&quot;线程池能同时运行的任务数量最大只能是1&quot;。</span></span><br><span class="line"><span class="comment"> * 线程池pool的阻塞队列是ArrayBlockingQueue，ArrayBlockingQueue是一个有界的阻塞队列，ArrayBlockingQueue的容量为1。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。</span></span><br><span class="line"><span class="comment"> * 根据&quot;&quot;中分析的execute()代码可知：线程池中共运行了2个任务。第1个任务直接放到Worker中，通过线程去执行；第2个任务放到阻塞队列中等待。其他的任务都被丢弃了！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDiscardPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_SIZE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;Test-Rejected-Policy-Pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池。线程池的&quot;最大池大小&quot;和&quot;核心池大小&quot;都为1(THREADS_SIZE)，&quot;线程池&quot;的阻塞队列容量为1(CAPACITY)。</span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY), namedThreadFactory);</span><br><span class="line">        <span class="comment">// 设置线程池的拒绝策略为&quot;丢弃&quot;</span></span><br><span class="line">        pool.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建10个任务，并将它们添加到线程池中。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_MAX; i++) &#123;</span><br><span class="line">            Runnable myRunnable = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;task [ &quot;</span> + i + <span class="string">&quot; ]&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pool.execute(myRunnable);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210428212820271.png" alt="image-20210428212820271"></p></li></ul><p>任务0来了池子，先抢占了线程，可以执行，之后来的都的在队列里排队，但队列就一个位置，先来的占着位置，后面的来只能看着，被无情的抛弃，所以，输出结果就0，1两个任务执行，其它的都消失了。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团技术团队-Java线程池</a></p><p><a href="http://concurrent.redspider.group/article/03/12.html">redspider-线程池部分</a></p><p><a href="https://zgxh.github.io/2020/11/06/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/12.%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/#toc-heading-15">线程池工作原理</a></p><h2 id="线程池源码分析："><a href="#线程池源码分析：" class="headerlink" title="线程池源码分析："></a>线程池源码分析：</h2><p><a href="https://juejin.im/post/6844903795768459271">掘金-线程池源码分析</a></p><p><a href="https://juejin.im/post/6844903889678893063">掘金-Java 线程池</a></p><p><a href="https://segmentfault.com/a/1190000016326062">segmentfault-线程池源码分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池的工作原理&quot;&gt;&lt;a href=&quot;#线程池的工作原理&quot; class=&quot;headerlink&quot; title=&quot;线程池的工作原理&quot;&gt;&lt;/a&gt;线程池的工作原理&lt;/h1&gt;&lt;p&gt;Java线程池主要用于主要用于管理线程组及其运行状态，以便java虚拟机更好地利用CPU资源</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2.java中多线程的实现</title>
    <link href="https://leslieaibin.github.io/2021/04/24/Java/Thread/2.java%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://leslieaibin.github.io/2021/04/24/Java/Thread/2.java%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-04-23T16:15:42.000Z</published>
    <updated>2021-04-28T13:35:37.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java多线程编程"><a href="#Java多线程编程" class="headerlink" title="Java多线程编程"></a>Java多线程编程</h2><p>java给多线程编程提供了内置的支持。一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程 ，每条线程并行执行不同的任务。</p><p>一个进程包括由操作系统分配的内存空间，包括一个或多个线程。一个线程不能独立的存在，他必须是进程的一部分。一个进程一直运行，直到所有的非收回线程都结束运行后才能结束。</p><h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210427163338918.png" alt="image-20210427163338918"></p><ul><li><p>新建状态</p><p>使用new关键字和Thread类或器子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序<code>start()</code>线程。</p></li><li><p>就绪状态</p><p>当线程对象调用了<code>start()</code>方法之后，该线程就进入了就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里<strong>线程调度器</strong>的调度。</p></li><li><p>运行状态</p><p>如果就绪状态的线程以获取CPU资源，就可以执行<code>run()</code>，此时线程便处于运行状态。处于运行状态的线程最为复杂，他可以变为<strong>阻塞状态</strong>，<strong>就绪状态</strong>和<strong>死亡状态</strong>。</p></li><li><p>阻塞状态</p><p>如果一个线程执行了<code>sleep（睡眠）</code>、<code>suspend（挂起）</code>等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态</p><p>一个运行状态的线程完成任务或者其他终止条发生时，该线程就切换到终止状态</p></li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>java线程的优先级是一个整数，其取值范围 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="Java-中多线程的实现"><a href="#Java-中多线程的实现" class="headerlink" title="Java 中多线程的实现"></a>Java 中多线程的实现</h2><p>主要有三种方案：</p><ul><li><p>Thread class       继承Thread类</p></li><li><p>Runnable接口    实现Runnable接口</p></li><li><p>Callable接口       实现Callable接口</p></li></ul><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><ul><li>继承<code>Thread</code>类， 并重写<strong>run()</strong> 方法</li><li>Thread类底层也是实现Runnable接口，并重写了<code>run()</code>方法</li><li>调用<code>start()</code>方法后，JVM为创建一个新的线程，并将该线程设置为可<strong>运行态Runnable</strong>,但并没有直接运行</li><li>当线程第一次得到时间片时，<code>run()</code> 方法得以运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ThreadDemo T1 = <span class="keyword">new</span> ThreadDemo(<span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        T1.start();</span><br><span class="line"></span><br><span class="line">        ThreadDemo T2 = <span class="keyword">new</span> ThreadDemo(<span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line">        T2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">200000</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Main: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    ThreadDemo(String name) &#123;</span><br><span class="line">        threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating&quot;</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span> + threadName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">                <span class="comment">// 让线程睡眠一会</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting &quot;</span> + threadName);</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, threadName);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>start() 方法不可被多次调用，否则会抛出异常。</strong></p><h3 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>public void start()</strong></td><td>开始线程，将新线程设置为就绪态; Java虚拟机调用该线程的run()方法</td></tr><tr><td><strong>public void run()</strong></td><td>线程获得时间片时，自动被异步调用，真正开始执行该线程; 该线程实现自<code>Runnable</code>接口</td></tr><tr><td><strong>public final void setName(String name)</strong></td><td>改变线程名称，使之与参数name相同</td></tr><tr><td><strong>public final void setPriority(int priority)</strong></td><td>更改线程的优先级</td></tr><tr><td><strong>public final void setDaemon(boolean on)</strong></td><td>将该线程标记为收回线程或用户线程</td></tr><tr><td><strong>public final void join(long millisec)</strong></td><td>让当前线程等待另一个线程执行完毕后再继续执行； 底层是使用的<code>Object</code>类的<code>wait()</code>方法</td></tr><tr><td><strong>public void interrupt()</strong></td><td>中断线程</td></tr><tr><td><strong>public final boolean isAlive()</strong></td><td>判断线程是否处于活动状态</td></tr></tbody></table><p>上述方法是被Thread对象调用的，线面的方法是Thread类的静态方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>public static void yield()</strong></td><td>让出当前的CPU时间片，并重现变成就绪状态，重新竞争CPU。让出后，可能当前CPU使用权还会被该线程获取到。</td></tr><tr><td><strong>public static void sleep(long millisec)</strong></td><td>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td></tr><tr><td><strong>public static Thread currentThread()</strong></td><td>返回对当前正在执行的线程对象的引用。</td></tr><tr><td><strong>public static boolean holdsLock(Object x)</strong></td><td>当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td></tr><tr><td><strong>public static void dumpStack()</strong></td><td>将当前线程的堆栈跟踪打印至标准错误流。</td></tr></tbody></table><h3 id="线程sleep和yield的区别"><a href="#线程sleep和yield的区别" class="headerlink" title="线程sleep和yield的区别"></a>线程sleep和yield的区别</h3><ul><li><code>sleep()</code>方法暂停当前线程后，会给其他线程执行机会，线程优先级对此没有影响。<code>yield()</code>方法会给优先级相同或更高的线程更高的执行机会</li><li><code>sleep()</code>方法会将线程转入阻塞状态，知道阻塞时间结束，才会转入就绪状态。<code>yield()</code>方法会将当前线程直接转入就绪状态。</li><li><code>sleep()</code>方法生命抛出InterruptedException异常，所以调用sleep()方法时要么捕捉该异常，要么显示声明抛出该异常。<code>yield()</code>方法则没有声明抛出任何异常。</li><li><code>sleep()</code>方法比yield()方法有更好的移植性，通常不建议使用yield()方法来控制并发线程的执行。</li></ul><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>如果一个子类已经继承了一个类，就无法在继承Thread类，此时可以通过Runnable接口创建线程。</p><ul><li><p>通过实现Runnable接口创建RunnableDemo线程，对其进行实例化</p></li><li><p>创建Thread类的实例并传入RunnableDemo线程的实例</p></li><li><p>调用线程的start方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        RunnableDemo R1 = <span class="keyword">new</span> RunnableDemo( <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        R1.start();</span><br><span class="line"></span><br><span class="line">        RunnableDemo R2 = <span class="keyword">new</span> RunnableDemo( <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line">        R2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line"></span><br><span class="line">    RunnableDemo( String name) &#123;</span><br><span class="line">        threadName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> +  threadName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running &quot;</span> +  threadName );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + threadName + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">                <span class="comment">// 让线程睡眠一会</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> +  threadName + <span class="string">&quot; exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting &quot;</span> +  threadName );</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread (<span class="keyword">this</span>, threadName);</span><br><span class="line">            t.start ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Runnable</code> 接口来创建并启动线程，有两种方式：</p><ol><li>通过 <strong>普通类</strong> 的方式或 <strong>函数式编程匿名类</strong> 的方式来创建 <code>Runnable</code> 接口的实现类，并实现 <code>run()</code> 方法。</li><li>传入 <code>Runnable</code> 的实现类，实例化 <code>Thread</code> 类对象。</li><li>调用 <code>start()</code> 方法来启动该线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 Thread 类来创建新线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread()).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 8 函数式编程，创建匿名类</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-Callable-和-ExecutorService创建线程"><a href="#通过-Callable-和-ExecutorService创建线程" class="headerlink" title="通过 Callable 和 ExecutorService创建线程"></a>通过 Callable 和 ExecutorService创建线程</h2><p>有时，我们需要在主线程中开启多个子线程并发执行一个任务，然后收集各个线程执行返回的结果并将最终结果汇总起来，这时就要用到Callable接口。</p><ul><li><p>创建callable接口的实现类，并实现call方法，该call()方法将作为线程执行体，并且有返回值。</p></li><li><p>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该Future List对象封装了该Callable对象的call()方法的返回值</p></li><li><p>使用Future List 对象作为Thread对象的target创建并启动新线程</p></li><li><p>调用Future List对象的get()方法来获得子线程执行结束后的返回值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// step 2: 创建一个固定大小为5的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// step 3: 创建有多个有返回值的任务列表</span></span><br><span class="line">        List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">// step 4: 创建一个有返回值的线程实例</span></span><br><span class="line">            Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// step 5： 提交线程，获取Future对象并将其保存到Future List中</span></span><br><span class="line">            Future future = pool.submit(c);</span><br><span class="line">            System.out.println(<span class="string">&quot;submit a callable thread: &quot;</span> + i);</span><br><span class="line">            list.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step 6: 关闭线程池，等待线程执行结束</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">        <span class="comment">// step 7: 遍历所有线程的运行结果，</span></span><br><span class="line">        <span class="keyword">for</span> (Future future : list)&#123;</span><br><span class="line">            <span class="comment">// 从Future 对象上获取任务的返回值 并将结果输出到控制台</span></span><br><span class="line">            System.out.println(<span class="string">&quot;get  the result from callable thread: &quot;</span> + future.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 ：通过实现Callable接口创建MyCallable线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 通过构造函数为线程传递函数，以定义线程的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span> <span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul><li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li> 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li></ul><h2 id="面试：-线程无线次创建的时候会拖垮CPU么"><a href="#面试：-线程无线次创建的时候会拖垮CPU么" class="headerlink" title="面试： 线程无线次创建的时候会拖垮CPU么  ?"></a>面试： 线程无线次创建的时候会拖垮CPU么  ?</h2><p>不会拓宽CPU， 只会占满内存，造成out of memery</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java多线程编程&quot;&gt;&lt;a href=&quot;#Java多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程编程&quot;&gt;&lt;/a&gt;Java多线程编程&lt;/h2&gt;&lt;p&gt;java给多线程编程提供了内置的支持。一个线程指的是进程中一个单一顺序的控制流，一个</summary>
      
    
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与并发" scheme="https://leslieaibin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>1.Java集合-框架</title>
    <link href="https://leslieaibin.github.io/2021/03/26/Java/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/"/>
    <id>https://leslieaibin.github.io/2021/03/26/Java/Collection/1.Java%E9%9B%86%E5%90%88-%E6%A1%86%E6%9E%B6/</id>
    <published>2021-03-25T16:15:42.000Z</published>
    <updated>2021-04-30T13:04:07.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合-1-–java集合分类"><a href="#Java集合-1-–java集合分类" class="headerlink" title="Java集合[1]–java集合分类"></a>Java集合[1]–java集合分类</h1><p>之前大概分为三种，<code>Set</code>，<code>List</code>，<code>Map</code>三种，JDK5之后，增加<code>Queue</code>.主要由<code>Collection</code>和<code>Map</code>两个接口衍生出来,同时<code>Collection</code>接口继承<code>Iterable</code>接口，所以我们也可以说java里面的集合类主要是由<code>Iterable</code>和<code>Map</code>两个接口以及他们的子接口或者其实现类组成。我们可以认为<code>Collection</code>接口定义了单列集合的规范，每次只能存储一个元素，而<code>Map</code>接口定义了双列集合的规范，每次能存储一对元素。</p><p>Iterable接口:主要是实现遍历功能</p><ul><li>Collection接口: 允许重复<ul><li>Set接口：无序，元素不可重复,访问元素只能通过元素本身来访问。</li><li>List接口：有序且可重复，可以根据元素的索引来访问集合中的元素。</li><li>Queue接口：队列集合</li></ul></li></ul><p>Map接口：映射关系，简单理解为键值对&lt;Key，Value&gt;，Key不可重复，与<code>Collection</code>接口关系不大，只是个别函数使用到。</p><p>整个接口框架关系</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20190414213527553.jpg" alt="20190414213527553"></p><h2 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个内部元素为T类型的迭代器（JDK1.5只有这个接口）</span></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历内部元素，action意思为动作，指可以对每个元素进行操作（JDK1.8添加）</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个可分割迭代器（JDK1.8添加），分割的迭代器主要是提供可以并行遍历元素的迭代器，可以适应现在cpu多核的能力，加快速度。</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java集合最源头的接口，实现这个接口的作用主要是集合对象可以通过迭代器去遍历每一个元素。</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>default void</code></td><td><code>forEachRemaining(Consumer&lt;? super E&gt; action)</code>  执行给定的每个剩余元素的动作，直到所有的元素都被处理或操作抛出异常。</td></tr><tr><td><code>boolean</code></td><td><code>hasNext()</code>  返回 <code>true</code>如果迭代具有更多的元素。</td></tr><tr><td><code>E</code></td><td><code>next()</code>  返回迭代中的下一个元素。</td></tr><tr><td><code>default void</code></td><td><code>remove()</code>  从基础集合中移除这个迭代器返回的最后一个元素（可选操作）。</td></tr></tbody></table><p> <strong>iterator方法</strong></p><p>遍历Collection的两种方式：</p><p>​        ① 使用迭代器Iterator  ② foreach循环（或增强for循环）</p><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</p><p> GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;asdfg&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;zxcvb&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">false</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="comment">// hasNext():判断是否还下一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">// next():①指针下移  ②将下移以后集合位置上的元素返回</span></span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;zxcvb&quot;</span>.equals(obj))&#123;</span><br><span class="line">            <span class="comment">// 内部定义了remove(),可以在遍历的时候，删除集合中的元素。</span></span><br><span class="line">            iterator.remove(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator iterator1 = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator1.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*****************************************&quot;</span>);</span><br><span class="line">    <span class="comment">// for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//        // 错误方式一： 一次iterator.next()进行一次指针移动</span></span><br><span class="line">    <span class="comment">//        while(iterator.next() != null)&#123;</span></span><br><span class="line">    <span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        // 错误方式二： 一次coll.iterator()返回一个迭代器对象</span></span><br><span class="line">    <span class="comment">//        while(coll.iterator().hasNext())&#123;</span></span><br><span class="line">    <span class="comment">//            System.out.println(coll.iterator().next());</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。 这是由于<a href="https://zhuanlan.zhihu.com/p/37476508">Fail-fast</a>。</p><h3 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h3><p>其实就是把对每一个元素的操作当成了一个对象传递进来，对每一个元素进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list.forEach(x -&gt; System.out.print(x));</span><br></pre></td></tr></table></figure><p>当然像ArrayList自然也是有自己的实现的，那我们就可以使用这样的写法,简洁优雅。forEach方法在java8中参数是<code>java.util.function.Consumer</code>,可以称为<strong>消费行为</strong>或者说<strong>动作</strong>类型。</p><h3 id="spliterator方法"><a href="#spliterator方法" class="headerlink" title="spliterator方法"></a>spliterator方法</h3><p>这是一个为了并行遍历数据元素而设计的迭代方法，返回的是<code>Spliterator</code>，是专门并行遍历的迭代器。以发挥多核时代的处理器性能，java默认在集合框架中提供了一个默认的<code>Spliterator</code>实现，底层也就是Stream.isParallel()实现的，我们可以看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream使用的就是spliterator</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20210326162900813.png" alt="image-20210326162900813"></p><p>Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  确保此集合包含指定的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code>  将指定集合中的所有元素添加到这个集合（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>clear()</code>  从这个集合中移除所有的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>  返回 <code>true</code>如果集合包含指定元素。</td></tr><tr><td><code>boolean</code></td><td><code>containsAll(Collection&lt;?&gt; c)</code>  返回 <code>true</code>如果这个集合包含指定集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此集合进行比较，以进行相等性。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此集合的哈希代码值。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果集合不包含任何元素。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>  返回此集合中的元素的迭代器。</td></tr><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>parallelStream()</code>  返回一个可能并行 <code>Stream</code>与集合的来源。</td></tr><tr><td><code>boolean</code></td><td><code>remove(Object o)</code>  从这个集合中移除指定元素的一个实例，如果它是存在的（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>removeAll(Collection&lt;?&gt; c)</code>  删除此集合中包含的所有元素（可选操作）的所有元素（可选操作）。</td></tr><tr><td><code>default boolean</code></td><td><code>removeIf(Predicate&lt;? super E&gt; filter)</code>  删除满足给定谓词的这个集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的这个集合中的元素（可选操作）。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回此集合中的元素的数目。</td></tr><tr><td><code>default Spliterator&lt;E&gt;</code></td><td><code>spliterator()</code>  创建此集合中的元素的 <a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>。</td></tr><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>stream()</code>  返回一个序列 <code>Stream</code>与集合的来源。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>  返回包含此集合中所有元素的数组。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>  返回包含此集合中所有元素的数组；返回数组的运行时类型是指定的数组的运行时类型。</td></tr></tbody></table><p>可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。<br>其中重点介绍iterator()方法，该方法的返回值是Iterator<E>。</p><h3 id="List-extends-Collection"><a href="#List-extends-Collection" class="headerlink" title="List extends Collection"></a>List extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继承于<code>Collection</code>接口，有顺序，取出的顺序与存入的顺序一致，有索引，可以根据索引获取数据，允许存储重复的元素，可以放入为null的元素。<br> 最常见的三个实现类就是<code>ArrayList</code>，<code>Vector</code>,<code>LinkedList</code>，<code>ArrayList</code>和<code>Vector</code>都是内部封装了对数组的操作，唯一不同的是，<code>Vector</code>是线程安全的，而<code>ArrayList</code>不是，理论上<code>ArrayList</code>操作的效率会比<code>Vector</code>好一些。</p><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  将指定的元素到这个列表的末尾（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>add(int index, E element)</code>  在列表中指定的位置上插入指定的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code>  追加指定集合的所有元素到这个列表的末尾，按他们的指定集合的迭代器返回（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(int index,  Collection&lt;? extends E&gt; c)</code>  将指定的集合中的所有元素插入到指定位置的列表中（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>clear()</code>  从这个列表中移除所有的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>  返回 <code>true</code>如果这个列表包含指定元素。</td></tr><tr><td><code>boolean</code></td><td><code>containsAll(Collection&lt;?&gt; c)</code>  返回 <code>true</code>如果这个列表包含指定集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此列表进行比较，以进行相等性。</td></tr><tr><td><code>E</code></td><td><code>get(int index)</code>  返回此列表中指定位置的元素。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此列表的哈希代码值。</td></tr><tr><td><code>int</code></td><td><code>indexOf(Object o)</code>  返回此列表中指定元素的第一个出现的索引，或-如果此列表不包含元素，或- 1。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果此列表不包含元素。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>  在这个列表中的元素上返回一个正确的顺序。</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(Object o)</code>  返回此列表中指定元素的最后一个发生的索引，或-如果此列表不包含元素，或- 1。</td></tr><tr><td><code>ListIterator&lt;E&gt;</code></td><td><code>listIterator()</code>  返回列表元素的列表迭代器（在适当的顺序）。</td></tr><tr><td><code>ListIterator&lt;E&gt;</code></td><td><code>listIterator(int index)</code>  在列表中的元素上返回列表迭代器（在适当的顺序），从列表中的指定位置开始。</td></tr><tr><td><code>E</code></td><td><code>remove(int index)</code>  移除此列表中指定位置的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>remove(Object o)</code>  从该列表中移除指定元素的第一个发生，如果它是存在的（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>removeAll(Collection&lt;?&gt; c)</code>  从这个列表中移除包含在指定集合中的所有元素（可选操作）。</td></tr><tr><td><code>default void</code></td><td><code>replaceAll(UnaryOperator&lt;E&gt; operator)</code>  用将运算符应用到该元素的结果替换此列表中的每个元素。</td></tr><tr><td><code>boolean</code></td><td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的列表中的元素（可选操作）。</td></tr><tr><td><code>E</code></td><td><code>set(int index, E element)</code>  用指定元素替换此列表中指定位置的元素（可选操作）。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回此列表中元素的数目。</td></tr><tr><td><code>default void</code></td><td><code>sort(Comparator&lt;? super E&gt; c)</code>  分类列表使用提供的 <code>Comparator</code>比较元素。</td></tr><tr><td><code>default Spliterator&lt;E&gt;</code></td><td><code>spliterator()</code>  创建此列表中的元素的 <a href="../../java/util/Spliterator.html"><code>Spliterator</code></a>。</td></tr><tr><td><code>List&lt;E&gt;</code></td><td><code>subList(int fromIndex,  int toIndex)</code>  返回一个视图之间的指定 <code>fromIndex</code>，包容，和  <code>toIndex</code>这份名单的部分，独家。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>  返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>  返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一到最后一个元素）；返回数组的运行时类型是指定的数组的运行时类型。</td></tr></tbody></table><p>Collection接口：单列集合，用来存储一个一个的对象</p><p><strong>常用类</strong></p><ul><li>List接口：存储序的、可重复的数据。  –&gt;“动态”数组,替换原的数组<ul><li><strong>ArrayList</strong>：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</li><li><strong>LinkedList</strong>：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li><li><strong>Vector</strong>：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</li></ul></li></ul><h3 id="Set-extends-Collection"><a href="#Set-extends-Collection" class="headerlink" title="Set extends Collection"></a>Set extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  如果没有当前（可选操作），则将指定的元素添加到该集合中。</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code>  如果没有当前（可选操作），将指定集合中的所有元素添加到该集合中。</td></tr><tr><td><code>void</code></td><td><code>clear()</code>  从这个集合中移除所有的元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>  如果这套 <code>true</code>返回包含指定的元素。</td></tr><tr><td><code>boolean</code></td><td><code>containsAll(Collection&lt;?&gt; c)</code>  如果这套 <code>true</code>返回包含指定集合的所有元素。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此设置的相等性进行比较。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此组的哈希代码值。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果这个集合不包含元素。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>  返回此集合中元素的迭代器。</td></tr><tr><td><code>boolean</code></td><td><code>remove(Object o)</code>  如果当前（可选操作），则从该集合中移除指定的元素。</td></tr><tr><td><code>boolean</code></td><td><code>removeAll(Collection&lt;?&gt; c)</code>  从这个集合中移除包含在指定集合中的所有元素（可选操作）。</td></tr><tr><td><code>boolean</code></td><td><code>retainAll(Collection&lt;?&gt; c)</code>  仅保留包含在指定集合中的此集合中的元素（可选操作）。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回该集合中元素个数（其基数）。</td></tr><tr><td><code>default Spliterator&lt;E&gt;</code></td><td><code>spliterator()</code>  在这个集合中的元素创建一个 <code>Spliterator</code>。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>  返回一个包含此集合中所有元素的数组。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>  返回包含此集合中的所有元素的数组；返回的数组的运行时类型是指定的数组的运行时类型。</td></tr></tbody></table><p><strong>Set</strong>存储的数据特点：无序的、不可重复的元素</p><p><strong>常用类</strong></p><p> 以HashSet为例说明：</p><ul><li><p>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</p></li><li><p>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</p></li></ul><p>Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法。</p><p>Collection接口：单列集合，用来存储一个一个的对象</p><ul><li><p>Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”</p><ul><li><p>HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</p><ul><li><p>LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历。</p><p>在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p></li></ul></li><li><pre><code>         TreeSet：可以照添加对象的指定属性，进行排序。</code></pre></li></ul></li></ul><h3 id="Queue-extends-Collection"><a href="#Queue-extends-Collection" class="headerlink" title="Queue extends Collection"></a>Queue extends Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code>  插入指定元素为该队列是否有可能立即这样做不违反容量限制，还  <code>true</code>成功后抛出 <code>IllegalStateException</code>如果没有空间是可用的。</td></tr><tr><td><code>E</code></td><td><code>element()</code>  检索，但不删除此队列的头。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>  如果可能立即在不违反容量限制的情况下这样做的话，将指定的元素插入到队列中。</td></tr><tr><td><code>E</code></td><td><code>peek()</code>  检索，但不删除，这个队列头，或返回 <code>null</code>如果队列为空。</td></tr><tr><td><code>E</code></td><td><code>poll()</code>  检索并移除此队列的头，或返回 <code>null</code>如果队列为空。</td></tr><tr><td><code>E</code></td><td><code>remove()</code>  检索和删除此队列的头。</td></tr></tbody></table><p>队列接口，在Collection接口的接触上添加了增删改查接口定义，一般默认是先进先出，即FIFO，除了优先队列和栈，优先队列是自己定义了排序的优先顺序，队列中不允许放入null元素。</p><ul><li><p>Deque（接口）:Queue的子接口，双向队列，可以从两边存取</p><ul><li>ArrayDeque：Deque的实现类，底层用数组实现，数据存贮在数组中</li></ul></li><li><p>AbstractQueue：Queue的子接口，仅实现了add、remove和element三个方法</p><ul><li>PriorityQueue：按照默认或者自己定义的顺序来排序元素，底层使用堆（完全二叉树）实现，使用动态数组实现，</li></ul></li><li><p>BlockingQueue： 在java.util.concurrent包中，阻塞队列，满足当前无法处理的操作</p></li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interface Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><ul><li>定义双列集合的规范Map&lt;K，V&gt;，每次存储一对元素，即key和value。</li><li>key的类型可以和value的类型相同，也可以不同，任意的引用类型都可以。</li><li>key是不允许重复的，但是value是可以重复的，所谓重复是指计算的hash值系统。</li></ul><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>clear()</code>  从这个映射中移除所有的映射（可选操作）。</td></tr><tr><td><code>default V</code></td><td><code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  试图计算出指定键和当前的映射值的映射（或 <code>null</code>如果没有当前映射）。</td></tr><tr><td><code>default V</code></td><td><code>computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>  如果指定的键是不是已经与价值相关的（或映射到  <code>null</code>），尝试使用给定的映射功能，进入到这个Map除非 <code>null</code>计算其价值。</td></tr><tr><td><code>default V</code></td><td><code>computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>  如果指定键的值是存在和非空的，尝试计算一个新的映射，给出了键和它当前的映射值。</td></tr><tr><td><code>boolean</code></td><td><code>containsKey(Object key)</code>  返回 <code>true</code>如果这Map包含一个指定的键映射。</td></tr><tr><td><code>boolean</code></td><td><code>containsValue(Object value)</code>  返回 <code>true</code>如果映射到指定的值的一个或多个键。</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code></td><td><code>entrySet()</code>  返回一个 <a href="../../java/util/Set.html"><code>Set</code></a>视图的映射包含在这个Map。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object o)</code>  将指定的对象与此映射的相等性进行比较。</td></tr><tr><td><code>default void</code></td><td><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>  在该映射中的每个条目执行给定的操作，直到所有的条目被处理或操作抛出异常。</td></tr><tr><td><code>V</code></td><td><code>get(Object key)</code>  返回指定的键映射的值，或 <code>null</code>如果这个Map不包含的键映射。</td></tr><tr><td><code>default V</code></td><td><code>getOrDefault(Object key, V defaultValue)</code>  返回指定的键映射的值，或  <code>defaultValue</code>如果这个Map不包含的键映射。</td></tr><tr><td><code>int</code></td><td><code>hashCode()</code>  返回此映射的哈希代码值。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>  返回 <code>true</code>如果这个Map不包含键值的映射。</td></tr><tr><td><code>Set&lt;K&gt;</code></td><td><code>keySet()</code>  返回一个 <a href="../../java/util/Set.html"><code>Set</code></a>的关键视图包含在这个Map。</td></tr><tr><td><code>default V</code></td><td><code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>  如果指定的键已与值相关联的值或与空值相关联的，则将其与给定的非空值关联。</td></tr><tr><td><code>V</code></td><td><code>put(K key, V value)</code>  将指定的值与此映射中的指定键关联（可选操作）。</td></tr><tr><td><code>void</code></td><td><code>putAll(Map&lt;?  extends K,?  extends V&gt; m)</code>  从指定的映射到这个Map（可选操作）复制所有的映射。</td></tr><tr><td><code>default V</code></td><td><code>putIfAbsent(K key, V value)</code>  如果指定的键是不是已经与价值相关的（或映射到  <code>null</code>）将其与给定的值并返回 <code>null</code>，否则返回当前值。</td></tr><tr><td><code>V</code></td><td><code>remove(Object key)</code>  如果存在（可选操作），则从该Map中移除一个键的映射。</td></tr><tr><td><code>default boolean</code></td><td><code>remove(Object key, Object value)</code>  仅当它当前映射到指定的值时，为指定的键移除条目。</td></tr><tr><td><code>default V</code></td><td><code>replace(K key, V value)</code>  仅当它当前映射到某一值时，替换指定的键的条目。</td></tr><tr><td><code>default boolean</code></td><td><code>replace(K key, V oldValue, V newValue)</code>  仅当当前映射到指定的值时，替换指定的键的条目。</td></tr><tr><td><code>default void</code></td><td><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>  将每个条目的值替换为在该项上调用给定函数的结果，直到所有的条目都被处理或函数抛出异常。</td></tr><tr><td><code>int</code></td><td><code>size()</code>  返回这个映射中的键值映射的数目。</td></tr><tr><td><code>Collection&lt;V&gt;</code></td><td><code>values()</code>  返回一个 <a href="../../java/util/Collection.html"><code>Collection</code></a>视图的值包含在这个Map。</td></tr></tbody></table><p><strong>Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)</strong></p><ul><li><p>HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</p><ul><li><pre><code>         LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</code></pre></li><li><pre><code>               原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</code></pre></li><li><pre><code>               对于频繁的遍历操作，此类执行效率高于HashMap。</code></pre></li></ul></li><li><p>TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</p><p>底层使用红黑树</p></li><li><p>Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p><ul><li><pre><code>  Properties:常用来处理配置文件。key和value都是String类型</code></pre></li></ul></li><li><p>HashMap的底层：数组+链表  （jdk7及之前)</p></li></ul><p>  <strong>数组+链表+红黑树 （jdk 8)</strong></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么有数组了，还要提供集合？</p><p><strong>数组的优点：</strong></p><ul><li>数组的效率高于集合类</li><li>数组能存放基本数据类型和对象；集合中只能放对象</li></ul><p><strong>数组的缺点：</strong></p><ul><li>不是面向对象的，存在明显的缺陷</li><li>数组长度固定且无法动态改变；集合类容量动态改变</li><li>数组无法判断其中实际存了多少元素，只能通过length属性获取数组的申明的长度</li><li>数组存储的特点是顺序的连续内存；集合的数据结构更丰富</li></ul><p><strong>JDK 提供集合的意义：</strong></p><ul><li>集合以类的形式存在，符合面向对象，通过简单的方法和属性调用可实现各种复杂操作</li><li>集合有多种数据结构，不同类型的集合可适用于不同场合</li><li>弥补了数组的一些缺点，比数组更灵活、实用，可开发效率</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java集合-1-–java集合分类&quot;&gt;&lt;a href=&quot;#Java集合-1-–java集合分类&quot; class=&quot;headerlink&quot; title=&quot;Java集合[1]–java集合分类&quot;&gt;&lt;/a&gt;Java集合[1]–java集合分类&lt;/h1&gt;&lt;p&gt;之前大概分为</summary>
      
    
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/categories/Collection/"/>
    
    
    <category term="Collection" scheme="https://leslieaibin.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法（Java实现）</title>
    <link href="https://leslieaibin.github.io/2020/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89/</id>
    <published>2020-12-05T16:15:42.000Z</published>
    <updated>2021-04-30T13:04:25.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法概述"><a href="#排序算法概述" class="headerlink" title="排序算法概述"></a>排序算法概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>将杂乱无章的数据元素，通过一定的方法按关键字顺序排列的过程叫做排序。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>非线性时间比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li><li><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-df96f14c5802a123.png" alt="img"></p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-fe7ee389e47ba067.png" alt="img"></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><strong>稳定：</strong>如果a原本在b前面且a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定：</strong>如果a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度：</strong>对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li><li><strong>内部排序：</strong>所有排序操作都在内存中完成。本文主要介绍的是内部排序。</li><li><strong>外部排序：</strong>待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。</li></ul><h2 id="各算法原理及实现"><a href="#各算法原理及实现" class="headerlink" title="各算法原理及实现"></a>各算法原理及实现</h2><p>下面我们来逐一分析十大经典排序算法，主要围绕下列问题展开：<br> 1、算法的基本思想是什么？<br> 2、算法的代码实现？<br> 3、算法的时间复杂度是多少？（平均、最好、最坏）什么情况下最好？什么情况下最坏？<br> 4、算法的空间复杂度是多少？<br> 5、算法的稳定性如何？</p><h3 id="直接插入排序（Insertion-Sort）"><a href="#直接插入排序（Insertion-Sort）" class="headerlink" title="直接插入排序（Insertion Sort）"></a>直接插入排序（Insertion Sort）</h3><p><strong>基本思想</strong></p><p>直接插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法描述</strong></p><p>一般来说，直接插入排序都采用in-place（原地算法）在数组上实现。具体算法描述如下：</p><ul><li><p>从第一个元素开始，该元素可以认为已经被排序；</p></li><li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p></li><li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置；</p></li><li><p>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p></li><li><p>将新元素插入到该位置后；</p></li><li><p>重复步骤2~5。</p></li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-07e08e0588d54869.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertioSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">int</span> current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        current = nums[i];</span><br><span class="line">        <span class="keyword">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (current &gt;= <span class="number">0</span> &amp;&amp; current &lt; nums[preIndex])&#123;</span><br><span class="line">            nums[preIndex + <span class="number">1</span>] = nums[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>直接插入排序平均时间复杂度为O(n<sup>2</sup>)，最好时间复杂度为O(n)，最坏时间复杂度为O(n<sup>2</sup>)。</p><p><strong>最好情况：</strong></p><p>如果待排序元素本来是正序的，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。</p><p><strong>最坏情况：</strong>如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n * (n - 1) / 2和 n * (n - 1) / 2。因此最坏情况下的时间复杂度为O(n<sup>2</sup>)。</p><p><strong>空间复杂度</strong></p><p>直接插入排序使用了常数空间，空间复杂度为O（1）</p><p><strong>稳定性</strong></p><p>直接插入属于稳定的</p><p><strong>算法扩展</strong></p><p>在直接插入排序中，待插入的元素总是在有序区线性查找合适的插入位置，没有利用有序的优势，考虑使用二分查找搜索插入位置进行优化，即<strong>二分插入排序</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binaryInsertioSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = nums[i];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; right)&#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; --j)&#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p><strong>基本思想</strong></p><p> 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为每趟比较将当前数列未排序部分的最大的元素“沉”到数列末端，而小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><strong>算法描述</strong></p><ul><li>比较相邻的元素。如果前一个比后一个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。为了优化算法，可以设立一个布尔标识，每趟排序开始前设为false，如果该趟排序发生了交换就置为true，如果一趟排序结束标识仍为false表示该趟排序没有发生交换，即数组已经有序，可以提前结束排序。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-641d29be81792220.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="comment">// 设置标识，检测是否交换过，如果没有交换过则表示已经有序，无需排序</span></span><br><span class="line">    <span class="keyword">int</span> numPairs = nums.length;</span><br><span class="line">    <span class="keyword">boolean</span> = isSwap = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (isSwap)&#123;</span><br><span class="line">        isSwap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPairs - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i + <span class="number">1</span>];</span><br><span class="line">                nums[i + <span class="number">1</span>]  = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">                isSwap = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numPairs--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>冒泡排序平均时间复杂度为O(n<sup>2</sup>)，最好时间复杂度为O(n)，最坏时间复杂度为O(n<sup>2</sup>)。</p><p> <strong>最好情况：</strong></p><p>如果待排序元素本来是正序的，那么一趟冒泡排序就可以完成排序工作，比较和移动元素的次数分别是 (n - 1) 和 0，因此最好情况的时间复杂度为O(n)。</p><p> <strong>最坏情况：</strong>如果待排序元素本来是逆序的，需要进行 (n - 1) 趟排序，所需比较和移动次数分别为 n * (n - 1) / 2和 3 * n * (n-1) / 2。因此最坏情况下的时间复杂度为O(n<sup>2</sup>)。</p><p><strong>空间复杂度</strong></p><p>冒泡排序使用了常数空间，空间复杂度为O(1)</p><p><strong>稳定性</strong></p><p>当 array[j] == array[j+1] 的时候，我们不交换 array[i] 和 array[j]，所以冒泡排序是稳定的。</p><p><strong>算法扩展</strong></p><p><strong>鸡尾酒排序，又称定向冒泡排序、搅拌排序等，是对冒泡排序的改进。</strong>在把最大的数往后面冒泡的同时，把最小的数也往前面冒泡，同时收缩无序区的左右边界，有序区在序列左右逐渐累积。</p><p>动图如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-81626da2174262f3.gif" alt="img"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] cocktailSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i + <span class="number">1</span>];</span><br><span class="line">                nums[i + <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸡尾酒排序是稳定的。它的平均时间复杂度为O(n<sup>2</sup>)，最好情况是待排序列原先就是正序的，时间复杂度为O(n)，最坏情况是待排序列原先是逆序的，时间复杂度为O(n<sup>2</sup>。空间复杂度为O(1)。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p><strong>基本思想</strong></p><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p><strong>算法描述</strong></p><p> 快速排序使用分治法来把一个数列分为两个子数列。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。这称为分区（partition）操作；</li><li>递归地（recursive）对小于基准值元素的子数列和大于基准值元素的子数列进行快速排序。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-d1a29d77c2e60116.gif" alt="img"></p><p><strong>代码实现</strong></p><p><strong>快速排序最核心的步骤就是partition操作</strong>，即从待排序的数列中选出一个数作为基准，将所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），该基准就处于数列的中间位置。partition函数返回基准的位置，然后就可以对基准位置的左右子序列递归地进行同样的快排操作，从而使整个序列有序。</p><p>下面我们来介绍partition操作的两种实现方法：<strong>左右指针法</strong> 和 <strong>挖坑法</strong>。</p><p><strong>方法一：左右指针法</strong></p><p><strong>基本思路：</strong></p><ul><li>将数组的最后一个数 right 作为基准数 key。</li><li>分区过程：从数组的首元素 begin 开始向后找比 key 大的数（begin 找大）；end 开始向前找比 key 小的数（end 找小）；找到后交换两者（swap），直到 begin &gt;= end 终止遍历。最后将 begin（此时begin == end）和最后一个数交换（ 这个时候 end 不是最后一个位置），即 key 作为中间数（左区间都是比key小的数，右区间都是比key大的数）</li><li>再对左右区间重复第二步，直到各区间只有一个数。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-1aa5092187a082d0.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(nums, left, right);</span><br><span class="line">        Quicksort(nums, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(nums, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left;</span><br><span class="line">    <span class="keyword">int</span> end = right;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end)&#123;</span><br><span class="line">        <span class="comment">// begin找大</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; nums[begin] &lt;= nums[right]) begin++;</span><br><span class="line">        <span class="comment">// end找小</span></span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end &amp;&amp; nums[end] &gt;= nums[right]) end--;</span><br><span class="line">        swap(nums, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, begin, right);</span><br><span class="line">    <span class="keyword">return</span> begin;       <span class="comment">//返回基准</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组内两个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：挖坑法</strong></p><p><strong>基本思路：</strong></p><ul><li>定义两个指针 left 指向起始位置，right 指向最后一个元素的位置，然后指定一个基准 key（right），作为坑。</li><li>left 寻找比基准（key）大的数字，找到后将 left 的数据赋给 right，left 成为一个坑，然后 right 寻找比基数（key）小的数字，找到将 right 的数据赋给 left，right 成为一个新坑，循环这个过程，直到 begin 指针与 end指针相遇，然后将 key 填入那个坑（最终：key的左边都是比key小的数，key的右边都是比key大的数），然后进行递归操作。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-c3fad33b4cab91ba.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = nums[right]; <span class="comment">// 初始坑</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// left 找大</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= key) left++;</span><br><span class="line">        nums[right] = nums[left]; <span class="comment">// 赋值，然后left作为新坑</span></span><br><span class="line">        <span class="comment">// right找小</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= key) right--;</span><br><span class="line">        nums[left] = nums[right]; <span class="comment">// right作为新坑</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = key;</span><br><span class="line">    <span class="comment">// 将key赋值给left和right的相遇点</span></span><br><span class="line">    <span class="comment">// 保持key的左边都是比key小的数，key的右边都是比key大的数</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 数列左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 数列右边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(array, left, right);</span><br><span class="line">        Quicksort(array, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(array, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码优化</strong></p><p>我们之前选择基准的策略都是<strong>固定基准</strong>，即固定地选择序列的右边界值作为基准，但如果在待排序列几乎有序的情况下，选择的固定基准将是序列的最大（小）值，快排的性能不好（因为每趟排序后，左右两个子序列规模相差悬殊，大的那部分最后时间复杂度很可能会达到O(n<sup>2</sup>）</p><p>下面提供几种常用的快排优化：</p><p> <strong>优化一：随机基准</strong></p><p>每次随机选取基准值，而不是固定选取左或右边界值。将随机选取的基准值和右边界值进行交换，然后就回到了之前的解法。只需要在 partition 函数前增加如下操作即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> random = (<span class="keyword">int</span>) (left + Math.random() * (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="comment">//随机选择 left ~ right 之间的一个位置作为基准</span></span><br><span class="line">swap(array, random, right);</span><br><span class="line"><span class="comment">//把基准值交换到右边界</span></span><br></pre></td></tr></table></figure><p><strong>优化二：三数取中法</strong></p><p> <strong>基本思想：</strong></p><p>取第一个数，最后一个数，第（N/2）个数即中间数，三个数中数值中间的那个数作为基准值。</p><p>举个例子，对于int[] array = { 2，5，4，9，3，6，8，7，1，0}，2、3、0分别是第一个数，第（N/2）个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。 实现getMid函数即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三数取中，返回array[left]、array[mid]、array[right]三者的中间者下标作为基准</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMid</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> a = array[left];</span><br><span class="line">    <span class="keyword">int</span> b = array[mid];</span><br><span class="line">    <span class="keyword">int</span> c = array[right];</span><br><span class="line">    <span class="keyword">if</span> ((b &lt;= a &amp;&amp; a &lt;= c) || (c &lt;= a &amp;&amp; a &lt;= b)) &#123; <span class="comment">//a为中间值</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a &lt;= b &amp;&amp; b &lt;= c) || (c &lt;= b &amp;&amp; b &lt;= a)) &#123; <span class="comment">//b为中间值</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((a &lt;= c &amp;&amp; c &lt;= b) || (b &lt;= c &amp;&amp; c &lt;= a)) &#123; <span class="comment">//c为中间值</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化三：当待排序序列的长度分割到一定大小后，使用插入排序</strong></p><p>在子序列比较小的时候，直接插入排序性能较好，因为对于有序的序列，插排可以达到O(n)的复杂度，如果序列比较小，使用插排效率要比快排高。</p><p> 实现方式也很简单，快排是在子序列元素个数为 1 时才停止递归，我们可以设置一个阈值n，假设为5，则大于5个元素，子序列继续递归，否则选用插排。<br> 此时QuickSort()函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left &gt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = partition(array, left, right);</span><br><span class="line">        Quicksort(array, left, pos - <span class="number">1</span>);</span><br><span class="line">        Quicksort(array, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insertionSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化四：三路划分</strong></p><p>如果待排序列中重复元素过多，也会大大影响排序的性能，这是因为大量相同元素参与快排时，左右序列规模相差极大，快排将退化为冒泡排序，时间复杂度接近O(n2)。这时候，如果采用三路划分，则会很好的避免这个问题。</p><p> 三路划分的思想是利用 partition 函数将待排序列划分为三部分：<strong>第一部分小于基准v，第二部分等于基准v，第三部分大于基准v。</strong>这样在递归排序区间的时候，<strong>我们就不必再对第二部分元素均相等的区间进行快排了</strong>，这在待排序列存在大量相同元素的情况下能大大提高快排效率。</p><p>来看下面的三路划分示意图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-dab14d648daa9ef1.png" alt="img"></p><p><strong>说明：</strong>红色部分为小于基准v的序列，绿色部分为等于基准v的序列，白色部分由于还未被 cur 指针遍历到，属于大小未知的部分，蓝色部分为大于基准v的序列。<br> left 指针为整个待排区间的左边界，right 指针为整个待排区间的右边界。less 指针指向红色部分的最后一个数（即小于v的最右位置），more 指针指向蓝色部分的第一个数（即大于v的最左位置）。cur 指针指向白色部分（未知部分）的第一个数，即下一个要判断大小的位置。</p><p><strong>算法思路：</strong></p><ul><li>由于最初红色和蓝色区域没有元素，初始化 less = left - 1，more = right + 1，cur = left。整个区间为未知部分（白色）。</li><li>如果当前 array[cur] &lt; v，则 swap(array,++less,cur++)，即把红色区域向右扩大一格（less指针后移），把 array[cur] 交换到该位置，cur 指针前移判断下一个数。</li><li>如果当前 array[cur] = v，则不必交换，直接 cur++</li><li>如果当前 array[cur] &gt; v，则 swap(array,–more,cur)，即把蓝色区域向左扩大一格（more指针前移），把 array[cur] 交换到该位置。<strong>特别注意！此时cur指针不能前移，这是因为交换到cur位置的元素来自未知区域，还需要进一步判断array[cur]。</strong></li></ul><p><strong>利用三路划分，我们就可以递归地进行三路快排了！并且可以愉快地避开所有重复元素区间。</strong></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = array[right]; <span class="comment">//选择右边界为基准</span></span><br><span class="line">        <span class="keyword">int</span> less = left - <span class="number">1</span>; <span class="comment">// &lt; v 部分的最后一个数</span></span><br><span class="line">        <span class="keyword">int</span> more = right + <span class="number">1</span>; <span class="comment">// &gt; v 部分的第一个数</span></span><br><span class="line">        <span class="keyword">int</span> cur = left;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; <span class="number">7</span>more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[cur] &lt; v)&#123;</span><br><span class="line">                swap(array,++less,cur++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[cur] &gt; v)&#123;</span><br><span class="line">                swap(array,--more,cur);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>,more - <span class="number">1</span>&#125;;  <span class="comment">//返回的是 = v 区域的左右下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] p = partition(array,left,right);</span><br><span class="line">            Quicksort(array,left,p[<span class="number">0</span>] - <span class="number">1</span>); <span class="comment">//避开重复元素区间</span></span><br><span class="line">            Quicksort(array,p[<span class="number">1</span>] + <span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p><strong>基本思想</strong></p><p> 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将<strong>已有序</strong>的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p><strong>算法描述</strong></p><ul><li>把长度为 n 的输入序列分成两个长度为 n / 2 的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-0d061316be55799a.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(nums, mid, nums.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序--将两段有序数组结合成一个有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[]  right)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j  = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">            result[k++] = left[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[k++] = right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.length)&#123;</span><br><span class="line">        result[k++] = left[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; right.length)&#123;</span><br><span class="line">        result[k++] = right[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p> 归并排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。</p><p> 归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</p><p><strong>空间复杂度</strong></p><p>归并排序空间复杂度为O(n)</p><p><strong>稳定性</strong></p><p>归并排序是稳定的。</p><p><strong>算法应用</strong></p><p> 归并排序可以用于求解逆序对数量问题，具体见：<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剑指offer - 数组中的逆序对</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">        <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将两段有序数组结合成一个有序数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">             <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">             <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">while</span> (i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left[i] &lt;= right[j]) &#123;</span><br><span class="line">                    result[k++] = left[i++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result[k++] = right[j++];</span><br><span class="line">                     <span class="comment">/*归并同时统计逆序对数量，因为归并的两个子序列都已有序，故当left[i] &gt;  </span></span><br><span class="line"><span class="comment">                     right[j]，有left[i...left.length - 1]均大于right[j]*/</span></span><br><span class="line">                    <span class="keyword">this</span>.cnt = (<span class="keyword">this</span>.cnt % MOD + (left.length - i) % MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">while</span> (i &lt; left.length) &#123;</span><br><span class="line">                result[k++] = left[i++];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">while</span> (j &lt; right.length) &#123;</span><br><span class="line">                result[k++] = right[j++];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        MergeSort(array);</span><br><span class="line">        <span class="keyword">return</span> cnt % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p><strong>基本思想</strong></p><p>堆排序是一种树形选择排序方法，它利用了<strong>堆</strong>这种数据结构。在排序的过程中，将array[0，…，n-1]看成是一颗<strong>完全二叉树</strong>的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的关系，在当前无序区中选择关键字最大（最小）的元素。</p><p><strong>概念</strong></p><p> <strong>堆：</strong>堆是一种<strong>完全二叉树</strong>，且满足所有父节点的值均大于等于（或小于等于）其子节点的值。</p><p> <strong>大根堆（最大堆）：</strong>满足所有父节点的值均大于等于其子节点的值的堆称为大根堆，堆顶元素是堆中元素的最大值。</p><p> <strong>小根堆（最小堆）：</strong>满足所有父节点的值均小于等于其子节点的值的堆称为小根堆，堆顶元素是堆中元素的最小值。</p><p> <strong>堆的顺序存储结构：</strong>使用顺序数据结构（数组）存储堆，表示方法为：</p><ul><li>数组按层序遍历的顺序存放完全二叉树的结点，下标为 0 处为堆顶，下标为 len - 1 处为堆尾。</li><li>结点 i 如果存在左孩子（下标不超过 len - 1 就存在），左孩子的下标为（2 * i + 1）；如果存在右孩子，右孩子的下标为（2 * i + 2）。结点 i 的父结点下标为 (i - 1) / 2 (下标为 0 的结点除外，它没有父结点)。<strong>最后一个非叶子结点即为堆尾元素的父结点，下标为 (len - 1 - 1) / 2 = (len - 2) / 2。</strong></li></ul><p><strong>算法描述</strong></p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-671151d1fa2211f6.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量 用于记录nums的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">    len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    <span class="comment">// 1.构建大顶堆</span></span><br><span class="line">    buildMaxHeap(nums);</span><br><span class="line">    <span class="comment">// 2.循环将堆顶（最大值）与堆尾交换，删除堆尾元素，然后重现调整大顶堆</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        len--; <span class="comment">// 原先的堆尾进入有序区，删除堆尾元素</span></span><br><span class="line">        adjustHeap(nums, <span class="number">0</span>); <span class="comment">// 重新调整大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自顶向下调整以i为根的堆为大顶堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">    <span class="comment">// 如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; len &amp;&amp; nums[<span class="number">2</span> * i + <span class="number">1</span>] &gt; nums[maxIndex]) maxIndex = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果有右子树， 且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt; len &amp;&amp; nums[<span class="number">2</span> * i + <span class="number">2</span>] &gt; nums[maxIndex]) maxIndex = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">    <span class="keyword">if</span> (maxIndex != i)&#123;</span><br><span class="line">        swap(nums, maxIndex, i);</span><br><span class="line">        adjustHeap(nums, maxIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自底向上构建初始大根堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始自底向上构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (len - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        adjustHeap(nums, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组的两个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[len];</span><br><span class="line">    arr[len] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>扩展</strong></p><p><strong>插入元素：</strong>只需要把待插入的元素放置在堆尾，然后 len++ 把其纳入堆，然后调用 adjustHeap 函数重新调整堆即可。</p><p><strong>删除堆顶元素：</strong>只需要把堆顶元素交换到堆尾，然后 len– 把其移出堆，然后调用 adjustHeap 函数重新调整堆即可。</p><p><strong>时间复杂度</strong></p><p> 堆排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlogn)，最坏时间复杂度为O(nlogn)。</p><p> 堆排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它在任何情况下时间复杂度均是O(nlogn)。</p><p><strong>空间复杂度</strong></p><p> 堆排序使用了常数空间，空间复杂度为O(1)。</p><p><strong>稳定性</strong></p><p> 堆排序是不稳定的。</p><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p> <strong>基本思想</strong></p><p>1959年Shell发明，第一个突破O(n<sup>2</sup>)的排序算法，是直接插入排序的改进版。它与直接插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p><strong>算法描述</strong></p><p>先将整个待排元素序列分割成 gap 个增量为 gap 的子序列（每个子序列由位置相差为 gap 的元素组成，整个序列正好分割成 gap 个子序列，每个序列中有 n / gap 个元素）分别进行直接插入排序，然后缩减增量为之前的一半再进行排序，待 gap == 1时，希尔排序就变成了直接插入排序。因为此时序列已经基本有序，直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。<strong>gap初始值一般取 len / 2。</strong></p><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-89239b577fa8a299.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 希尔排序</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">     <span class="keyword">int</span> len = nums.length;</span><br><span class="line">     <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">     <span class="keyword">int</span> current, gap = len / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; ++i)&#123;</span><br><span class="line">             current = nums[i];</span><br><span class="line">             <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">             <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; nums[preIndex] &gt; current)&#123;</span><br><span class="line">                 nums[preIndex + gap] = nums[preIndex];</span><br><span class="line">                 preIndex -= gap;</span><br><span class="line">             &#125;</span><br><span class="line">             nums[preIndex + gap] = current;</span><br><span class="line">         &#125;</span><br><span class="line">         gap /= <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> nums;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p> 希尔排序平均时间复杂度为O(nlogn)，最好时间复杂度为O(nlog2n)，最坏时间复杂度为O(nlog2n)。希尔排序的时间复杂度与增量序列的选取有关。</p><p><strong>空间复杂度</strong></p><p>希尔排序使用了常数空间，空间复杂度为O(1)</p><p><strong>稳定性</strong></p><p> 由于相同的元素可能在各自的序列中插入排序，最后其稳定性就会被打乱，比如序列 2、4、1、2，所以希尔排序是不稳定的。</p><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p><strong>基本思想</strong></p><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p> <strong>算法描述</strong></p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-79b756f0ac7b932f.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计数排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">       <span class="keyword">int</span> bias, min = Integer.MIN_VALUE, max = Integer.MAX_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">           min = Math.min(min, nums[i]);</span><br><span class="line">           max = Math.max(max, nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 计算偏移量，将 min ~ max 映射到 bucket 数组的 0 ~ (max - min) 位置上</span></span><br><span class="line">       bias = -min;</span><br><span class="line">       <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">       Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">           bucket[bucket[i] + bias]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(index &lt; nums.length)&#123;</span><br><span class="line">           <span class="keyword">if</span> (bucket[i] != <span class="number">0</span>)&#123;</span><br><span class="line">               nums[index] = i - bias;</span><br><span class="line">               bucket[i]--;</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>计数排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n + k)。n 为遍历一趟数组计数过程的复杂度，k 为遍历一趟桶取出元素过程的复杂度。</p><p><strong>空间复杂度</strong></p><p> 计数排序空间复杂度为O(k)，k为桶数组的长度。</p><p><strong>稳定性</strong></p><p>计数排序是稳定的。</p><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p> <strong>基本思想</strong></p><p> 桶排序与计数排序很相似，不过现在的桶不单计数，是实实在在地放入元素。按照映射函数将数据分配到不同的桶里，每个桶内元素再分别排序（可能使用别的排序算法），最后拼接各个桶中排好序的数据。<strong>映射函数人为设计，但要保证桶 i 中的数均小于桶 j （i &lt; j）中的数，即必须桶间必须有序，桶内可以无序，可以考虑按照数的区间范围划分桶。下面代码的桶映射函数为：(i - min) / arr.length。</strong></p><p> <strong>算法描述</strong></p><ul><li><p>设置一个定量的数组当作空桶；</p></li><li><p>遍历输入数据，并且把数据一个一个放到对应的桶里去；</p></li><li><p>对每个不是空的桶的桶内元素进行排序（可以使用直接插入排序等）；</p></li><li><p>从不是空的桶里把排好序的数据拼接起来。</p></li></ul><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-580b859fbe994d10.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">        min = Math.min(min, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*桶映射函数：自己设计，要保证桶 i 的数均小于桶 j （i &lt; j）的数，</span></span><br><span class="line"><span class="comment">      即必须桶间必须有序，桶内可以无序。这里桶映射函数为：(i - min) / arr.length*/</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / array.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (array[i] - min) / (array.length);</span><br><span class="line">        bucketArr.get(num).add(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; bucketArr.get(i).size();j++) &#123;</span><br><span class="line">           array[k++] = bucketArr.get(i).get(j);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>桶排序平均时间复杂度为O(n + k)，最好时间复杂度为O(n + k)，最坏时间复杂度为O(n2)。</p><p><strong>空间复杂度</strong></p><p>桶排序空间复杂度为O(n + k)。</p><p><strong>稳定性</strong></p><p>桶排序是稳定的。</p><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p><strong>基本思想</strong></p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><strong>算法描述</strong></p><ul><li>取得数组中的最大数，并取得位数；</li><li>array 为原始数组，从最低位开始取每个位组成 radix 数组；</li></ul><p>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</p><p><strong>动图演示</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2510824-d4feaca47e97eaec.gif" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">     <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="comment">//2.进行maxDigit趟分配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++,div *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (array[j] / div) % <span class="number">10</span>;</span><br><span class="line">                bucketList.get(num).add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//3.收集</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                    array[index++] = bucketList.get(j).get(k);</span><br><span class="line">                bucketList.get(j).clear();</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>基数排序平均时间复杂度为O(n * k)，最好时间复杂度为O(n * k)，最坏时间复杂度为O(n * k)。</p><p><strong>空间复杂度</strong></p><p>基数排序空间复杂度为O(n + k)。</p><p><strong>稳定性</strong></p><p> 基数排序是稳定的。</p><h3 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h3><p><strong>基本思想</strong></p><p> 简单选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p><strong>算法描述</strong></p><p>n个记录的简单选择排序可经过(n-1)趟简单选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>(n-1)趟结束，数组有序化了。</li></ul><p><strong>动图演示</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2510824-b373a01a7e32ea97.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp" alt="img"></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>)</span><br><span class="line">             <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) <span class="comment">//找到最小的数</span></span><br><span class="line">                    minIndex = j; <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[minIndex]; <span class="comment">//将最小数和无序区的第一个数交换</span></span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>简单选择排序平均时间复杂度为O(n2)，最好时间复杂度为O(n2)，最坏时间复杂度为O(n2)。</p><p><strong>最好情况：</strong>如果待排序元素本来是正序的，则移动元素次数为 0，但需要进行 n * (n - 1) / 2 次比较。</p><p><strong>最坏情况：</strong>如果待排序元素中第一个元素最大，其余元素从小到大排列，则仍然需要进行 n * (n - 1) / 2 次比较，且每趟排序都需要移动 3 次元素，即移动元素的次数为3 * (n - 1)次。<strong>需要注意的是，简单选择排序过程中需要进行的比较次数与初始状态下待排序元素的排列情况无关。</strong></p><p><strong>空间复杂度</strong><br> 简单选择排序使用了常数空间，空间复杂度为O(1)</p><p><strong>稳定性</strong><br> 简单选择排序不稳定，比如序列 2、4、2、1，我们知道第一趟排序第 1 个元素 2 会和 1 交换，那么原序列中 2 个 2 的相对前后顺序就被破坏了，所以简单选择排序不是一个稳定的排序算法.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.jianshu.com/p/47170b1ced23">一文搞定十大经典排序算法（Java实现）</a></p><p><a href="https://www.cnblogs.com/mobin/p/5374217.html">堆排序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序算法概述&quot;&gt;&lt;a href=&quot;#排序算法概述&quot; class=&quot;headerlink&quot; title=&quot;排序算法概述&quot;&gt;&lt;/a&gt;排序算法概述&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="排序" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>2.操作系统-进程管理</title>
    <link href="https://leslieaibin.github.io/2020/11/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://leslieaibin.github.io/2020/11/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2020-11-29T16:15:42.000Z</published>
    <updated>2021-04-30T13:04:44.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h3><p>进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数据）的真正运行实例。</p><p>进程结构一般由3部分组成：<strong>代码段、数据段和堆栈段</strong>。代码段用于存放程序代码数据，数个进程可以共享同一个代码段。数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数的参数，它存放着函数的参数，函数内部定义的局部变量。堆栈段还包括了进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序及数据在处理机执行时所发生的活动</li><li>进程时系统进行资源分配和调度的独立单位。进程的独立运行由进程控制块PCB控制和管理。进程映像时静态的进程。程序段、相关数据、PCB三部分构成了进程映像。</li><li>进程具有动态性（创建、活动、暂停、和终止、具有生命周期），并发性（多个进程在<strong>一段时间</strong>内同时运行），独立性（进程是一个独立运行、获得资源和接受调度的基本单位）、异步性（进程按照独自不可预知的速度前进）、结构性（每个进程都有一个PCB描述）</li></ul><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129200001614.png" alt="image-20201129200001614"></p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p><strong>三种基本状态</strong></p><ul><li><strong>运行态</strong>  占有CPU，并在CPU上运行。单核处理机环境下，每一时刻最多只有一个进程处于运行态。双核环境下可以同时又两个进程处于运行态</li><li><strong>就绪态</strong>  已经具备 运行条件，但由于没有哦空闲CPU，而暂时不能运行。进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。</li><li>**阻塞态 ** 又称等待态，因等待某一时间而暂时不能运行。如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</li></ul><p><strong>另外两种状态</strong></p><ul><li><strong>创建态</strong>  进程正在被创建，操作系统为进程分配资源 初始化PCB</li><li>**终止态 **  进程正在从系统中撤销，操纵系统会回收进程拥有的资源，撤下PCB</li></ul><h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129202447277.png" alt="image-20201129202447277"></p><h3 id="原语实现对进程的控制"><a href="#原语实现对进程的控制" class="headerlink" title="原语实现对进程的控制"></a>原语实现对进程的控制</h3><p><strong>进程控制：</strong> 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简化理解：反正进程控制就是要实现进程状态转换</p><p>用原语实现进程控制。源于的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即云子操作。原语采用“关中断指令”和”开中断指令”实现</p><p>显然，关/开中断指令的权限非常大，必然只允许在核心态执行的特权指令</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129203151073.png" alt="image-20201129203151073"></p><h3 id="进程控制的五种原语"><a href="#进程控制的五种原语" class="headerlink" title="进程控制的五种原语"></a>进程控制的五种原语</h3><p>学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</p><ul><li><p>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）</p><ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复期运行环境</li></ul></li><li><p>将PCB插入合适的队列</p></li><li><p>分配/回收资源</p></li></ul><p><strong>进程的创建原语</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20200315163724449.png" alt="在这里插入图片描述"></p><p><strong>进程的终止原语</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129204154402.png" alt="image-20201129204154402"></p><p><strong>进程的阻塞和唤醒</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129204332368.png" alt="image-20201129204332368"></p><p><strong>进程切换原语</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129204418402.png" alt="image-20201129204418402"></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>顾名思义，进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法</p><p><strong>共享存储</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129205215962.png" alt="image-20201129205215962"></p><p><strong>管道通信</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129205333396.png" alt="image-20201129205333396"></p><p><strong>消息传递</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129205444441.png" alt="image-20201129205444441"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129210311586.png" alt="image-20201129210311586"></p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>可以把线程理解为“轻量级进程线程” 是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。线程则作为处理机的分配单元。</p><h3 id="线程带来的变化"><a href="#线程带来的变化" class="headerlink" title="线程带来的变化"></a>线程带来的变化</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129211655148.png" alt="image-20201129211655148"></p><h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（PCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><h4 id="用户级线程与多对一模型"><a href="#用户级线程与多对一模型" class="headerlink" title="用户级线程与多对一模型"></a>用户级线程与多对一模型</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129212738423.png" alt="image-20201129212738423"></p><p>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户线程对用户不透明，对操作系统透明）可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”</p><p><strong>多对一模型：</strong></p><p>多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><p><strong>优点：</strong>用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p><strong>缺点：</strong>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><h4 id="内核级线程与一对一模型"><a href="#内核级线程与一对一模型" class="headerlink" title="内核级线程与一对一模型"></a>内核级线程与一对一模型</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129213319676.png" alt="image-20201129213319676"></p><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”</p><p><strong>一对一模型：</strong></p><p>一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p><strong>优点：</strong>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p><strong>缺点：</strong>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><h4 id="特殊的组合方式与多对多模型"><a href="#特殊的组合方式与多对多模型" class="headerlink" title="特殊的组合方式与多对多模型"></a>特殊的组合方式与多对多模型</h4><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129213712898.png" alt="image-20201129213712898"></p><p>重点重点重点：</p><p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><p>例如：左边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</p><p><strong>多对多模型：</strong>n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><h1 id="处理机的调度"><a href="#处理机的调度" class="headerlink" title="处理机的调度"></a>处理机的调度</h1><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><h2 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h2><h3 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220048583.png" alt="image-20201129220048583"></p><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p><p><strong>高级调度（作业调度）</strong>。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</p><p>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p><h3 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220512620.png" alt="image-20201129220512620"></p><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p><p>这么做的目的是为了提高内存利用率和系统吞吐量。暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。<br>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p><h3 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220656794.png" alt="image-20201129220656794"></p><p>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><h3 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220739706.png" alt="image-20201129220739706"></p><h3 id="三层调度的联系与对比"><a href="#三层调度的联系与对比" class="headerlink" title="三层调度的联系与对比"></a>三层调度的联系与对比</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129220929694.png" alt="image-20201129220929694"></p><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129221959790.png" alt="image-20201129221959790"></p><h3 id="进程的切换和过程"><a href="#进程的切换和过程" class="headerlink" title="进程的切换和过程"></a>进程的切换和过程</h3><p><strong>“狭义的进程调度”与“进程切换”的区别：</strong></p><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p><p>进程切换的过程主要完成了：</p><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复<br>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ul><p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="先来先服务——FCFS"><a href="#先来先服务——FCFS" class="headerlink" title="先来先服务——FCFS"></a>先来先服务——FCFS</h3><ul><li>FCFS是一种最简单的调度算法，从后备作业队列中选择最先进入该队列作业调度</li><li>FCFS是不可剥夺算法，长作业会使后到的短作业长期等待</li><li>算法简单，效率低，对长作业有利，有利于CPU繁忙性工作</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129223227492.png" alt="image-20201129223227492"></p><h3 id="短作业优先——SJF"><a href="#短作业优先——SJF" class="headerlink" title="短作业优先——SJF"></a>短作业优先——SJF</h3><ul><li>从后备队列中选择一个或若干个估计运行时间最短的作业掉入内存运行</li><li>对长作业不利，如果短作业源源不断，会使得长作业一直处于饥饿状态</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129223802686.png" alt="image-20201129223802686"></p><h3 id="高响应比优先—HRRN"><a href="#高响应比优先—HRRN" class="headerlink" title="高响应比优先—HRRN"></a>高响应比优先—HRRN</h3><ul><li>该算法是对FCFS和SJF算法的一种平衡，计算每个作业的响应比</li><li>响应比的计算为（等待时间 + 要求服务时间）/要求服务时间</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201129223954712.png" alt="image-20201129223954712"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130195616108.png" alt="image-20201130195616108"></p><h3 id="时间片轮转调度算法（RR）"><a href="#时间片轮转调度算法（RR）" class="headerlink" title="时间片轮转调度算法（RR）"></a>时间片轮转调度算法（RR）</h3><ul><li><p>时间片轮转算法适用于分时系统，系统讲所有就绪的进程按照到达时间排成一个序列，进程调度总是选择就绪队列中的第一个进程执行。但是仅能运行一个，如100ms</p></li><li><p>受系统响应时间影响，队列进程数目，进程长短影响较大</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130195840641.png" alt="image-20201130195840641"></p><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><ul><li>优先级调度算法每次从后备队列中选取优先级最高的一个或几个作业</li><li>优先级调度可以剥夺时占有，也可以非剥夺式占有</li></ul><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><ul><li>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展</li></ul><ol><li>设置多个就绪队列，为各个队列赋予优先级，1，2，3等</li><li>赋予各个队列中时间片大小不同，优先级高时间片越小</li><li>一个进程进入内存后首先放入1级队列末尾，FCFS原则等待，如果其能够完成，则撤离系统，否则放入耳机队列的末尾，依次向下执行。</li><li>仅当1级队列为空时，调度程序调度2级队列中的进程，依次类推</li></ol><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130200117865.png" alt="image-20201130200117865"></p><h1 id="进程的同步与互斥"><a href="#进程的同步与互斥" class="headerlink" title="进程的同步与互斥"></a>进程的同步与互斥</h1><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ul><li><code>同步也称为直接制约关系。</code></li><li>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。</li><li>一个简单的例子来理解这个概念。</li><li>例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有<code>异步性</code>,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</li></ul><h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><ul><li><code>互斥，亦称间接制约关系</code>。<code>进程互斥</code>指当一个进程访问某临界资源时，另一个想要访问该<code>临界资源</code>的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li><li>在这里需复习一下<code>临界资源</code>的概念。</li><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。</li></ul><p><strong>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</strong></p><ul><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个整形变量，可以被定义为两个标准的原语wait(S),signal(S)即P，V操作</p><ul><li>P操作 如果信号量大于0， 执行-1操作，如果等于0，执行等待信号量大于0</li><li>V操作 对信号量完成加1操作，唤醒睡眠的进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore mutex &#x3D; 1 </span><br><span class="line">void P1()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">void P2()&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    &#x2F;&#x2F;临界区</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块</p><ul><li>使用信号量机制时，进程自备同步操作，P(S)和V(S)操作大量分散在各个进程中，不易管理，易发生死锁。</li><li>管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。一个时刻只能有一个进程使用。进程不能一直占用管程，不然其他程序都无法使用</li><li>引入管程的目的：1. 把分散在各进程中的临界区集中起来进行管理；2. 防止进程有意无意的违反同步操作;3. 便于高级语言程序书写和验证。</li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没满，生产者才可以放入物品；只有缓冲区不空，消费者可以拿走物品</p><p>由于缓冲区输入临界资源，需要一个互斥量mutex来完成缓冲区的互斥访问</p><p>为了同步生产者和消费者的行为，需要记录缓冲区物品数量，数量可以用信号量表示，empty记录空缓冲区，full记录满缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># define N 100</span><br><span class="line">typedef int semahpore</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line">semaphore empty &#x3D; N;</span><br><span class="line">semaphore full &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void producer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        int item &#x3D; produceItem();</span><br><span class="line">        P(&amp;empty);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        Item.push(item);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        V(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer()&#123;</span><br><span class="line">    while(True)&#123;</span><br><span class="line">        P(&amp;full);</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        int item &#x3D; Item.top();</span><br><span class="line">        Item.pop();</span><br><span class="line">        consume(item);</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(&amp;empty())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>问题描述： 控制多个进程对数据进行读、写操作，但是不允许读-写和写-写操作同时进行</p><p>用一个count表示读进程数量，分别用read_mutex 和write_mutex 作为读锁和写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore count &#x3D; 0;</span><br><span class="line">semaphore read_mutex &#x3D; 1;</span><br><span class="line">semaphore write_mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void read()&#123;</span><br><span class="line">    P(&amp;read_mutex);</span><br><span class="line">    count++;</span><br><span class="line">    if(count&#x3D;&#x3D;1) P(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">    read();</span><br><span class="line">    p(&amp;read_mutex);</span><br><span class="line">    count--;</span><br><span class="line">    if(count&#x3D;&#x3D;0) V(&amp;write_mutex);</span><br><span class="line">    V(&amp;read_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write()&#123;</span><br><span class="line">    P(&amp;write_mutex);</span><br><span class="line">    write();</span><br><span class="line">    V(&amp;write_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>问题描述：五个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种活动：吃饭与思考，吃饭时，他拿起左边及右边的筷子，并且一次只能拿一根</p><p>如果所有哲学家都拿左边的筷子，就会出现死锁，这样只需加一步，当哲学家拿起筷子时检查是否能同时拿起两根筷子，不然就等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef int semaphore</span><br><span class="line">semaphore chop[5] &#x3D; &#123;1,1,1,1,1&#125;;</span><br><span class="line">semaphore mutex &#x3D; 1;</span><br><span class="line"></span><br><span class="line">void process()&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        P(chop[i]);</span><br><span class="line">        P(chop[(i+1)%5]);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chop[i]);</span><br><span class="line">        V(chop[(i+1)%5]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是<strong>死锁</strong>，发生死锁后若无外力干涉，这些进程都将无法向前推进。</p><h2 id="死锁、饥饿、死循环区别"><a href="#死锁、饥饿、死循环区别" class="headerlink" title="死锁、饥饿、死循环区别"></a>死锁、饥饿、死循环区别</h2><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130202012613.png" alt="image-20201130202012613"></p><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li><strong>互斥条件：</strong>只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li><strong>不剥夺条件：</strong>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li><strong>请求和保持条件：</strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li><strong>循环等待条件：</strong>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><h2 id="什么时候发生死锁"><a href="#什么时候发生死锁" class="headerlink" title="什么时候发生死锁"></a>什么时候发生死锁</h2><ul><li><p>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</p></li><li><p>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁例如，并发执行的进程P1<br>P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程2又申请资源1两者会因为申请的资源被对方占有而阻塞，从而发生死锁</p></li><li><p>信号量的使用不当也会造成死锁如生产者消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p></li></ul><p>总之，对不可剥夺资源的不合理分配，可能导致死锁</p><h2 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h2><ul><li><p>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</p></li><li><p>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</p></li><li><p>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p></li></ul><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130203852543.png" alt="image-20201130203852543"></p><h4 id="不剥夺条件"><a href="#不剥夺条件" class="headerlink" title="不剥夺条件"></a>不剥夺条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130203808687.png" alt="image-20201130203808687"></p><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130211744625.png" alt="image-20201130211744625"></p><h4 id="破坏循环条件"><a href="#破坏循环条件" class="headerlink" title="破坏循环条件"></a>破坏循环条件</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130211807469.png" alt="image-20201130211807469"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>在并发程序中，避免了逻辑中出现复数个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。</p><p>下面我们通过“破坏”第四个死锁条件，来解决第一个小节中的死锁示例并证明我们的结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程a</span></span><br><span class="line">        Thread td1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程b</span></span><br><span class="line">        Thread td2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DeadLockDemo2.method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        td1.start();</span><br><span class="line">        td2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程a尝试获取integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程a获取到integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不再获取线程a需要的Integer.class锁。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (String.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程b尝试获取Integer.class&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (Integer.class) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程b获取到Integer.class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------</span><br><span class="line">线程a尝试获取integer.class</span><br><span class="line">线程a获取到integer.class</span><br><span class="line">线程b尝试获取Integer.class</span><br><span class="line">线程b获取到Integer.class</span><br></pre></td></tr></table></figure><p>在上面的例子中，由于已经不存在线程a持有线程b需要的锁，而线程b持有线程a需要的锁的逻辑了，所以Demo顺利执行完毕。</p><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130212101903.png" alt="image-20201130212101903"></p><h4 id="解除"><a href="#解除" class="headerlink" title="解除"></a>解除</h4><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201130212121587.png" alt="image-20201130212121587"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Video Analysis 相关领域</title>
    <link href="https://leslieaibin.github.io/2020/11/24/Video%20Analysis%20%E7%9B%B8%E5%85%B3%E9%A2%86%E5%9F%9F/CV%E4%BB%BB%E5%8A%A1/"/>
    <id>https://leslieaibin.github.io/2020/11/24/Video%20Analysis%20%E7%9B%B8%E5%85%B3%E9%A2%86%E5%9F%9F/CV%E4%BB%BB%E5%8A%A1/</id>
    <published>2020-11-23T16:15:42.000Z</published>
    <updated>2020-11-24T07:46:05.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Action-Recognition-行为识别"><a href="#Action-Recognition-行为识别" class="headerlink" title="Action Recognition(行为识别)"></a>Action Recognition(行为识别)</h1><p>也可以叫  <strong>Action Classification</strong> </p><h2 id="任务目的"><a href="#任务目的" class="headerlink" title="任务目的"></a>任务目的</h2><p>给一个视频片段进行分类，类别通常是各类人的动作</p><h2 id="任务特点"><a href="#任务特点" class="headerlink" title="任务特点"></a>任务特点</h2><p>简化了问题，一般使用的数据库都先将动作分割好了，一个视频片断中包含一段明确的动作，时间较短（几秒钟）且有唯一确定的label。所以也可以看作是输入为视频，输出为动作标签的多分类问题。此外，动作识别数据库中的动作一般都比较明确，周围的干扰也相对较少（不那么real-world）。有点像图像分析中的Image Classification任务。</p><h2 id="难点-关键点"><a href="#难点-关键点" class="headerlink" title="难点/关键点"></a>难点/关键点</h2><ul><li>强有力的特征：即如何在视频中提取出能更好的描述视频判断的特征。特征越强，模型的效果通常较好。</li><li>特征的编码（encode）/融合（fusion）：这一部分包括两个方面，第一个方面是非时序的，在使用多种特征的时候如何编码/融合这些特征以获得更好的效果；另外一个方面是时序上的，由于视频很重要的一个特性就是其时序信息，一些动作看单帧的图像是无法判断的，只能通过时序上的变化判断，所以需要将时序上的特征进行编码或者融合，获得对于视频整体的描述。</li><li>算法速度：虽然在发论文刷数据库的时候算法的速度并不是第一位的。但高效的算法更有可能应用到实际场景中去。</li></ul><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>行为识别的数据库比较多，这里主要介绍两个最常用的数据库，也是近年这个方向的论文必做的数据库。</p><ul><li>UCF101:来源为YouTube视频，共计101类动作，13320段视频。共有5个大类的动作：1)人-物交互；2)肢体运动；3)人-人交互；4)弹奏乐器；5)运动。数据库主页为：<a href="https://www.crcv.ucf.edu/data/UCF101.php">UCF101</a>。文章的题图为UCF各类视频的示意图。</li><li>HMDB51:来源为YouTube视频，共计51类动作，约7000段视频。数据库主页为：<a href="https://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/">HMDB51</a></li></ul><p>在Actioin Recognition中，实际上还有一类骨架数据库，比如MSR Action 3D，HDM05，SBU Kinect Interaction Dataset等。这些数据库已经提取了每帧视频中人的骨架信息，基于骨架信息判断运动类型。不做详细介绍</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><a href="https://github.com/jinwchoi/awesome-action-recognition">Action Recognition方法</a></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124105621642.png" alt="image-20201124105621642"></p><h1 id="Temporal-Action-Proposals（时间行动建议）"><a href="#Temporal-Action-Proposals（时间行动建议）" class="headerlink" title="Temporal Action Proposals（时间行动建议）"></a>Temporal Action Proposals（时间行动建议）</h1><h2 id="任务目的-1"><a href="#任务目的-1" class="headerlink" title="任务目的"></a>任务目的</h2><p>Temporal Action Proposal任务不需要对活动分类，只需要找出proposals,主要目的是将长视频根据语义分割成多个segment。所以判断找的temporal proposals全不全就可以测评方法好坏，常用average recall (AR) ，Average Recall vs. Average Number of Proposals per Video (AR-AN) 即曲线下的面积(ActivityNet Challenge 2017就用这个测评此项任务)。如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/uniform_random_proposal_performance.png" alt="img"></p><h2 id="任务特点-1"><a href="#任务特点-1" class="headerlink" title="任务特点"></a>任务特点</h2><p>为了适应视频数据集的特点，好的action proposal应该具有如下的特点：</p><ol><li>能够高效地表示一个视频间隔（temporal segment），计算开销小。</li><li>将可能具有action的视频间隔（temporal segment）找出来。</li><li>初步识别出视频间隔中的动作是否为我们感兴趣的动作类别之一。</li></ol><h2 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h2><p>目前使用比较广泛的数据集为ActivityNet-1.3（2016年发布）以及早些年的一个相对较小的数据集THUMOS14。</p><p>THUMOS14是一个包含action recognition和action localization任务的比赛，其中训练集是trimmed UCF101，所以训练集不能被用来训练action proposal网络。验证集集有1010个视频，测试集有1574个视频。但是验证集中只有200个视频有temporal label，测试集中只有212个。一般情况下，大家使用验证集来训练action proposal网络，然后在测试集上查看效果。</p><p>用于训练的验证集上每个类别平均有150个动作时序标注，每个动作平均的持续时间为4.04秒。一共有3007个动作时序标注，标注了的动作共持续12159.8秒。测试集上的每个类别平均有167.9个动作时序标注，每个动作平均的持续时间为4.47秒，标注了的动作共持续15040。3秒。验证集上不同类别的标注个数及平均动作持续时间如下图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-d323e3a24d32ee79dcb862f39740f1ea_720w.jpg" alt="img"></p><p>ActivityNet-1.3共有200个类别，训练集有10024个视频，验证集有4926个视频，测试集有5044个视频。官方提供的视频分辨率为320x240，除了视频之外还提供了按照5FPS 使用的代码，以及使用ResNet-152在抽好的帧上提取的feature。一般来说对于Action Proposal需要在提供的帧上进行实验，或者为了更好地利用标注也可以自己进行密集抽帧。</p><p>就标注来看，共有23065个动作时序标注，平均每个视频有1.15个时序标注。视频的平均时长为128秒，标注的平均时长为49.2秒。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-ab716c73c416fdfc9fe84ad3219bab28_720w.jpg" alt="img">时序动作标注长度分布图</p><p>就类别分布来看，平均每个类别有115个标注，平均每个类别的动作持续时间为51.3秒。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/v2-62bd5ac0bf060e9bed1fe6ef92cf4212_720w.jpg" alt="img">类别动作持续时间图</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201123211330471.png" alt="image-20201123211330471"></p><p><strong>ActivityNet 任务的提交格式</strong></p><h1 id="Temporal-Action-Localization-（时序动作定位）"><a href="#Temporal-Action-Localization-（时序动作定位）" class="headerlink" title="Temporal Action Localization （时序动作定位）"></a>Temporal Action Localization （时序动作定位）</h1><p>也可以叫 <strong>Temporal Action Detection （时序行为检测）</strong> </p><h2 id="任务目的-2"><a href="#任务目的-2" class="headerlink" title="任务目的"></a>任务目的</h2><p>给定一段未分割的长视频，算法需要检测视频中的行为片段（action instance），包括其<strong>开始时间、结束时间以及类别</strong>。一段视频中可能包含一个或多个行为片段。</p><p>(1) temporal action proposal generation: 即进行时序动作提名，产生候选的视频时序片段，即相当于Faster-RCNN中的RPN网络的作用；</p><p>(2) action classification: 即判断候选视频时序片段的动作类别。两个部分结合在一起，即实现了视频中的时序动作检测。目前视频分类算法的精度其实以及比较高了，然而时序检测的效果依旧比较低，主要的性能瓶颈在于时序提名环节。</p><h2 id="任务特点-2"><a href="#任务特点-2" class="headerlink" title="任务特点"></a>任务特点</h2><ul><li><p><strong>特点1</strong></p><p><strong>action recognition</strong>与<strong>temporal action detection</strong>之间的关系同 <strong>image classfication</strong>与 <strong>object detection</strong>之间的关系非常像。基于image classification问题，发展出了许多强大的网络模型（比如ResNet,VGGNet等），这些模型在object detection的方法中起到了很大的作用。同样，action recognition的相关模型（如2stream，C3D, iDT等)也被广泛的用在temporal action detection的方法中。</p></li><li><p><strong>特点2</strong></p><p>由于temporal action detection和object detection之间存在一定的相似性，所以很多temporal action detection方法都采用了与一些object detection方法相似的框架（最常见的就是参考R-CNN系列方法）。具体的会在后面的论文介绍中讲到。</p></li></ul><h2 id="难点-关键点-1"><a href="#难点-关键点-1" class="headerlink" title="难点/关键点"></a>难点/关键点</h2><ul><li><p><strong>难点1</strong></p><p>在目标检测中，物体目标的边界通常都是非常明确的，所以可以标注出较为明确的边界框。但时序行为的边界很多时候并不是很明确，什么时候一个行为算开始，什么时候行为算结束常常无法给出一个准确的边界（指精确的第几帧）。</p></li><li><p><strong>难点2</strong></p><p>只使用静态图像的信息，而不结合时序信息在行为识别中是可以的（虽然结合时序信息效果会更好）。但在时序行为检测中，是无法只使用静态图像信息的。必须结合时序的信息，比如使用RNN读入每帧图像上用CNN提取的特征，或是用时序卷积等。</p></li><li><p><strong>难点3</strong></p><p>时序行为片段的时间跨度变化可能非常大。比如在ActivityNet中，最短的行为片段大概1s左右，最长的行为片段则超过了200s。巨大的时长跨度，也使得检测时序动作非常难。</p></li></ul><p><strong>任务关键点</strong></p><p>我认为设计一个好的时序行为检测方法的关键主要在于以下两点：</p><ul><li><p>高质量的时序片段（<strong>Proposals</strong>）：很多方法都是使用<strong>Proposal + classification</strong>的框架。对于这类方法，重要的是较高的proposal质量（即在保证平均召回率的情况下，尽可能减少proposal的数量）。此外，对于所有方法，获取准确的时序行为边界都是非常重要的。</p></li><li><p>准确的分类（<strong>Classification</strong>）：即能准确的得到时序行为片段的类别信息。这里通常都会使用行为识别中的一些方法与模型。</p></li></ul><h2 id="数据集-2"><a href="#数据集-2" class="headerlink" title="数据集"></a>数据集</h2><p>时序行为检测的数据库也有很多，下面主要介绍几个常用的主流数据库：</p><ul><li><strong>THUMOS 2014</strong>：该数据集即为THUMOS Challenge 2014，地址为<a href="http://crcv.ucf.edu/THUMOS14/">THUMOS 2014</a>。该数据集包括行为识别和时序行为检测两个任务。它的训练集为UCF101数据集，包括101类动作，共计13320段分割好的视频片段。THUMOS2014的验证集和测试集则分别包括1010和1574个未分割过的视频。在时序行为检测任务中，只有20类动作的未分割视频是有时序行为片段标注的，包括200个验证集视频（包含3007个行为片段）和213个测试集视频（包含3358个行为片段）。这些经过标注的未分割视频可以被用于训练和测试时序行为检测模型。实际上之后还有THUMOS Challenge 2015,包括更多的动作类别和视频数，但由于上面可以比较的方法不是很多，所以目前看到的文章基本上还是在THUMOS14上进行实验。</li><li><strong>MEXaction2</strong>：MEXaction2数据集中包含两类动作：骑马和斗牛。该数据集由三个部分组成：YouTube视频，UCF101中的骑马视频以及INA视频，数据集地址为<a href="http://mexculture.cnam.fr/xwiki/bin/view/Datasets/Mex+action+dataset">MEXaction2</a> 。其中YouTube视频片段和UCF101中的骑马视频是分割好的短视频片段，被用于训练集。而INA视频为多段长的未分割的视频，时长共计77小时，且被分为训练，验证和测试集三部分。训练集中共有1336个行为片段，验证集中有310个行为片段，测试集中有329个行为片断。且MEXaction2数据集的特点是其中的未分割视频长度都非常长，被标注的行为片段仅占视频总长的很低比例</li><li><strong>ActivityNet</strong>: 目前最大的数据库，同样包含分类和检测两个任务。数据集地址为<a href="http://activity-net.org/">Activity Net</a> ，这个数据集仅提供视频的youtube链接，而不能直接下载视频，所以还需要用python中的youtube下载工具来自动下载。该数据集包含200个动作类别，20000（训练+验证+测试集）左右的视频，视频时长共计约700小时。由于这个数据集实在太大了，我的实验条件下很难完成对其的实验，所以我之前主要还是在THUMOS14和MEXaction2上进行实验。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201123203536610.png" alt="image-20201123203536610"></p><p><strong>ActivityNet 任务的提交格式</strong></p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124110351933.png" alt="image-20201124110351933"></p><h1 id="Temporal-Action-Parsing-TAP-时态动作解析"><a href="#Temporal-Action-Parsing-TAP-时态动作解析" class="headerlink" title="Temporal Action Parsing (TAP) (时态动作解析)"></a>Temporal Action Parsing (TAP) (时态动作解析)</h1><p>相关论文《Intra- and Inter-Action Understanding via Temporal Action Parsing》</p><h2 id="相关数据集Datasets"><a href="#相关数据集Datasets" class="headerlink" title="相关数据集Datasets"></a>相关数据集Datasets</h2><ol><li>only class labels：<ul><li>KTH, Weizmann, UCFSports, Olympic</li><li>UCF101, HMDB51, Sports1M, Kinetics</li></ul></li><li>boundaries of actions in untrimmed video:<ul><li>THUMOS’15, ActivityNet, Charades, HACS, AVA</li></ul></li><li>finegrained annotations for action instances(author’s): 动作实例的细粒度注释<ul><li>Salads, Breakfast, <strong>MPIICooking, JIGSAWS</strong></li></ul></li></ol><p>为2020年CVPR 商汤等新提出的任务，在一段动作视频中，定义一连串子动作（sub-action），动作解析即定位这些子动作的开始帧。该任务可更好的进行动作间和动作内部的视频理解。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul><li>对动作实例的内部结构的详细了解，特别是在时间维度上（TAP/TAS）<ul><li>TAP仅提供了子动作之间的边界，而这些边界的监督作用却明显较弱</li><li>TAS的目标是在一组预定义的子动作中标记动作实例的每一个框架，这些子动作可以在一个监督下完成</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201123213225627.png" alt="image-20201123213225627"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124102457517.png" alt="image-20201124102457517"></p><p>特点：  每个未剪辑的视频类别是一样的，子动作的边界给出，但是没有给出子动作的类比</p><h2 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124104217442.png" alt="image-20201124104217442"></p><p>动作边界检测。我们借助于序列模型，特别是时间卷积网络(TCN)，来估计动作状态变化的出现。给定一个T帧片段，在顶部构建一个两层时间卷积网络来密集预测每个帧的标量。接下来，带注释的时间边界及其k个相邻帧被标记为1，其余的被设置为0。由于正样本(即子动作变化点)和负样本之间的不平衡，使用加权二进制交叉熵损失来优化网络。在推断期间，一旦输出超过某个阈值θc，例如0.5，就检测到子动作。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124104510876.png" alt="image-20201124104510876">\</p><p>弱监督时间动作分割。时间动作分割旨在用一组预定义的子动作来标记动作实例的每个帧。在弱监督设置中，仅提供按发生顺序排列的子动作列表，而没有精确的时间位置。我们通过迭代软边界分配(ISBA)  [6]和连接主义时间建模(CTM) [18]选择了两个有代表性的方法。对于ISBA，我们通过提取帧级特征{ fi } N i =  1并将它们预分组为K个簇来生成伪标签。对CTM来说，最初的训练目标是最大化预定义目标标记的对数似然性。在我们的例子中，损失被改变为所有可能标签的对数似然的和，因为所有k个有区别的随机抽样子动作可能是一个可能的解决方案。在推断过程中，我们使用简单的最佳路径解码，即在每个时间戳连接最活跃的输出。</p><h2 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201124103739413.png" alt="image-20201124103739413"></p><p>输出的是每个子动作的开始帧  用于评测的是召回率，精确率，f1分数</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/26603387">Video Analysis</a></p><p><a href="https://zhuanlan.zhihu.com/p/32265681">视频分析入门之 Action Proposal</a></p><p><a href="https://zhuanlan.zhihu.com/p/80333569">Action Proposal &amp; Boundary系列</a></p><p><a href="https://pianshen.com/article/36421969810/">TAPOS论文分享</a></p><p><a href="https://zhuanlan.zhihu.com/p/75444151">边界匹配网络详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/39327364">用于时序动作提名生成的边界敏感网络</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Action-Recognition-行为识别&quot;&gt;&lt;a href=&quot;#Action-Recognition-行为识别&quot; class=&quot;headerlink&quot; title=&quot;Action Recognition(行为识别)&quot;&gt;&lt;/a&gt;Action Recogniti</summary>
      
    
    
    
    <category term="Video Analysis" scheme="https://leslieaibin.github.io/categories/Video-Analysis/"/>
    
    
    <category term="Video Analysis" scheme="https://leslieaibin.github.io/tags/Video-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>1.操作系统-操作系统概述</title>
    <link href="https://leslieaibin.github.io/2020/11/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://leslieaibin.github.io/2020/11/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-11-21T16:15:42.000Z</published>
    <updated>2021-04-30T13:04:41.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统举例"><a href="#操作系统举例" class="headerlink" title="操作系统举例"></a>操作系统举例</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2020022012313767.png" alt="在这里插入图片描述"></p><h2 id="操作系统的层次结构"><a href="#操作系统的层次结构" class="headerlink" title="操作系统的层次结构"></a>操作系统的层次结构</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121211023859.png" alt="image-20201121211023859"></p><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><ul><li>是系统最基本最核心的软件，属于系统软件</li><li>控制和管理整个计算机的硬件和软件资源</li><li>合理的组织、调度计算机的工作与资源分配</li><li>为用户和其他软件提供方便的接口和环境</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121212138580.png" alt="image-20201121212138580"></p><h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121212425015.png" alt="image-20201121212425015"></p><h3 id="计算机系统资源的管理者"><a href="#计算机系统资源的管理者" class="headerlink" title="计算机系统资源的管理者"></a>计算机系统资源的管理者</h3><ul><li><p>处理机管理（进程管理）</p></li><li><p>存储器管理（内存）</p></li><li><p>文件管理（文件系统）</p></li><li><p>设备管理（I/O）</p></li></ul><h4 id="处理机管理-进程管理"><a href="#处理机管理-进程管理" class="headerlink" title="处理机管理(进程管理)"></a>处理机管理(进程管理)</h4><p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归纳为进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁通信、处理机调度等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121214558742.png" alt="image-20201121214558742"></p><h4 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h4><p>为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存的<strong>分配与回收、地址映射、内存保护与共享和内存扩充</strong>等功能。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121230607457.png" alt="image-20201121230607457"></p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>计算机中所有的信息都是以文件的形式存在的，操作票系统中负责文件管理的部分称为文件系统，文件管理包括<strong>文件存储空间的管理、目录管理及文件读写管理和保护</strong>等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121230956206.png" alt="image-20201121230956206"></p><h4 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h4><p>设备管理的主要任务是完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓<strong>存管理、设备分配、设备处理和虚拟设备</strong>等功能。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121231235672.png" alt="image-20201121231235672"></p><p><strong>以上4种管理功能都由“工人”负责，“雇主”无序关注。</strong></p><h3 id="用户与计算机硬件系统之间的接口"><a href="#用户与计算机硬件系统之间的接口" class="headerlink" title="用户与计算机硬件系统之间的接口"></a>用户与计算机硬件系统之间的接口</h3><ul><li><p>为了让用户方便、快捷、可靠的操作计算机硬件并执行自己的程序，操作系统提供了用户接口</p></li><li><p>操作系统提供的接口分为两类：<code>命令接口和程序接口</code></p><ul><li><strong>命令接口</strong>：用户可以<strong>直接</strong>使用的，利用这些操作命令来组织和控制作业的执行</li><li><strong>程序接口</strong>：用户通过程序<strong>间接</strong>使用的，编程人员可以使用它们来请求操作系统服务</li></ul></li></ul><h4 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h4><p>用户利用这些命令来组织和控制作业的运行</p><ul><li><p>联机命令接口： 又称交互式命令接口，适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121232243498.png" alt="image-20201121232243498"></p></li><li><p>脱机命令接口： 又称批处理命令接口，使用于批处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令。在操作系统运行这些命令时用户不可干预。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121232546065.png" alt="image-20201121232546065"></p></li></ul><h4 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h4><p>由一组系统调用（也称广义指令）组成，用户通过在程序中使用这些系统调用请求操作系统为其提供服务，只能通过用户程序间接调用，如使用各种外部设备、申请分配和回收内存及其他各种要求</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121233121560.png" alt="image-20201121233121560"></p><h3 id="作为扩充机器（虚拟机）"><a href="#作为扩充机器（虚拟机）" class="headerlink" title="作为扩充机器（虚拟机）"></a>作为扩充机器（虚拟机）</h3><p>没有任何软件支持的计算机称为<strong>裸机</strong>，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器：因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p><h1 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h1><p>操作系统是一种系统软件，但与其它系统软件和应用软件有很大的不同，它有自己的特殊性，及基本特征。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201121234036988.png" alt="image-20201121234036988"></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>并发</strong>：两个或多个时间在同一时间间隔内发生，这些时间在宏观上是同时发生的，在微观上是交替发生的，操作系统的并发性指系统中同时存在着多个运行的程序。</p><p><strong>并行</strong>：两个或多个时间在同一时刻发生</p><ul><li>一个单核(CPU)同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</li><li>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的</li><li>在如今的计算机中，一般都是多核cpu的，即在同一<strong>时刻</strong>可以并行执行多个程序，比如我的计算机是8核的，我的计算机可以在同一时刻并行执行8个程序，但是事实上我们计算机执行的程序并不止8个，因此并发技术是必须存在的，并发性必不可少。</li></ul><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>资源共享即共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用，共享分为两类：<strong>互斥共享和同时共享</strong></p><h3 id="互斥共享"><a href="#互斥共享" class="headerlink" title="互斥共享"></a>互斥共享</h3><ul><li>计算机中的某个资源在一段时间内只能允许<code>一个进程</code>访问，别的进程没有使用权</li><li>临界资源(独占资源)：在一段时间内只允许一个进程访问的资源，计算机中大多数物理设备及某些软件中的栈、变量和表格都属于临界资源，它们被要求互斥共享</li><li>举个例子：比如QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li></ul><h3 id="同时共享"><a href="#同时共享" class="headerlink" title="同时共享"></a>同时共享</h3><ul><li>计算机中的某个资源在在一段时间内可以<code>同时</code>允许<code>多个</code>进程访问</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，<strong>分时共享</strong></li><li>这里的<code>同时</code>指在宏观上是同时的，在微观上是交替进行访问的，只是cpu处理速度很快，我们感觉不到，在宏观上感觉是在同时进行</li><li>举个例子：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行访问磁盘的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li><strong>注意</strong>：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul><h3 id="并发性和共享性互为存在条件"><a href="#并发性和共享性互为存在条件" class="headerlink" title="并发性和共享性互为存在条件"></a>并发性和共享性互为存在条件</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122000214611.png" alt="image-20201122000214611"></p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。 物理实体（前者） 是实际存在的， 而逻辑上<br>对应物（后者） 是用户感受到的。  </p><p>多道程序设计：是指在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。</p><ul><li>虚拟是把一个物理上的实体变为若干逻辑上的对应物。</li><li>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</li><li>虚拟技术：用于实现虚拟的技术</li><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的</li><li>操作系统的虚拟技术科归纳为：<ul><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟存储器</li></ul></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122000457368.png" alt="image-20201122000457368"></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步是指， 在多道程序环境下， 允许多个程序并发执行， 但由于资源有限， 进程的执行不是一贯到底的，<br>而是走走停停， 以不可预知的速度向前推进， 这就是进程的异步性。  </p><ul><li>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</li></ul><p>如果失去了并发性， 即系统只能串行地运行各个程序， 那么每个程序的执行会一贯到底。 只有系统拥有并发性， 才有可能导致异步性。  </p><h1 id="操作系统分类和发展"><a href="#操作系统分类和发展" class="headerlink" title="操作系统分类和发展"></a>操作系统分类和发展</h1><h2 id="操作系统的分类及其特征优劣"><a href="#操作系统的分类及其特征优劣" class="headerlink" title="操作系统的分类及其特征优劣"></a>操作系统的分类及其特征优劣</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/20200222160313682.png" alt="在这里插入图片描述"></p><h2 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122003006007.png" alt="image-20201122003006007"></p><h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><h2 id="两种命令"><a href="#两种命令" class="headerlink" title="两种命令"></a>两种命令</h2><ul><li><p>特权指令</p><p>不允许用户直接使用的命令，比如：I/O令、置中断指令、存取用于内存保护的寄存器、送程序状态字到程序状态寄存器，内存清零等的指令</p></li><li><p>非特权指令</p><p>加减乘除等普通运算指令</p></li></ul><h2 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h2><ul><li><p>核心态(管态)</p><p>特权指令和非特权指令都可执行</p></li><li><p>用户态(目态)</p><p>只能执行非特权指令</p></li></ul><h2 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h2><ul><li><p>内核程序（管理程序）</p><p>操作系统内核程序是系统管理，特权指令和非特权指令都可执行，运行在核心态</p></li><li><p>用户持续（应用程序）</p><p>为了保证系统能够安全运行，用户只能执行非特权指令，运行在用户态</p></li></ul><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122172717616.png" alt="image-20201122172717616"></p><p>内核是计算机配置在底层的软件，是操作系统最基本最核心的部分；实现操作系统内核功能的程序是内核程序</p><ul><li><strong>时钟管理</strong><ul><li>计时  操作系统需要通过时钟管理，向用户提供标准的系统时间</li><li>切换进程 在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度</li></ul></li><li><strong>中断机制</strong><ul><li>初衷是提高多道程序运行环境中CPU的利用率，主要针对外部设备</li><li>后来逐步得到发展形成了多种类型，成为操作系统各项操作的基础</li></ul></li><li><strong>原语</strong><ul><li>处于操作系统的最低层，是最接近硬件的部分。</li><li>这些程序的运行具有原子性，其操作只能一气呵成（主要从系统安全性和便于管理考虑）</li><li>这些程序的运行时间都较短，而且调用频繁。</li></ul></li><li><strong>资源管理</strong><ul><li>进程管理  进程状态管理、进程调度和分派、创建与撤销进程控制块</li><li>存储器管理 存储器的空间分配和回收、内存信息保护程序、代码对换程序等</li><li>设备管理 缓冲区管理、设备分配和回收等</li></ul></li></ul><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="中断技术的诞生"><a href="#中断技术的诞生" class="headerlink" title="中断技术的诞生"></a>中断技术的诞生</h2><p>为了实现多道程序并发执行的一种技术为了提高资源利用率</p><h2 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h2><p>发生中断，就意味着需要操作系统介入开展管理工作，cpu会立即进入核心态作用：</p><p>“中断”是CPU从用户进入核心态的<strong>唯一途径</strong></p><h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>陷入（有意而为之的异常，如系统调用）、故障（由错误条件引起的，可能被故障处理程序修复，如缺页）、终止（不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除以0），<strong>信号来源CPU内部，与当前执行的指令有关</strong></p><ul><li><p>资源中断</p><ul><li>指令中断：系统调用时使用的访管指令（又叫陷入指令，trap指令）</li></ul></li><li><p>强迫中断</p><ul><li>硬件故障： 缺页</li><li>软件中断： 整数除以0</li></ul></li></ul><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p><strong>信号来源于CPU外部，与当前执行的指令无关</strong></p><ul><li>外设要求    如：/操作完成发出的中断信号</li><li>人为干预    如：用户强行终止一个进程</li></ul><h2 id="中断（外中断）处理过程"><a href="#中断（外中断）处理过程" class="headerlink" title="中断（外中断）处理过程"></a>中断（外中断）处理过程</h2><ul><li><p>关中断    CPU响应中所后，应该拒绝响应更高级的中源的中断请求件完成</p></li><li><p>保存断点    完成为了之后能重新恢复执行这个程序，需要将原来的程序的断点（即程序计数器PC）保存起来</p></li><li><p>中断服务程序寻址    取出中断服务程序的入口地址送到程序计数器PC</p></li><li><p>保存现场和屏蔽字    中断程序完成进入程序中所服务程序后，首先要保护现场，现场信息一般是指程序状态字寄存器PSWR和某些通用寄存器的内容</p></li><li><p>开中断 允许更高级中断请求得到响应，想象一下多道程序设计的并发执行，CPU交替执行内存里面的各个程序</p></li><li><p>执行中断 服务程序这是中断请求的目的，完成某些中断后的操作</p></li><li><p>关中断    保证在恢复现场和屏蔽字时不被中断，完成中断后的操作之后，需要恢复现场，不希望被打扰</p></li><li><p>恢复现场和屏蔽字    将现场和屏蔽字恢复到原来的状态</p></li><li><p>开中断    中断返回中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序</p></li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122172302086.png" alt="image-20201122172302086"></p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是操作系统提供给应用程序的接口</p><p>作用：应用程序可以通过系统调用（程序接口）请求获得操作系统的服务</p><p>系统调用会使处理器从用户态切换到核心态</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>设备管理     完成设备的请求、释放启动等功能</li><li>文件管理    完成文件的读，写、创删除等功能</li><li>进程控制    完成进程的创建、撒销、阻塞、唤醒等功能</li><li>进程通信    完成进程之间的消息传递、信号传递等功能</li><li>内存管理    完成内存的分配、回收、获取作业占用内存区大小及始址等功能</li></ul><h2 id="系统调用和库函数区别"><a href="#系统调用和库函数区别" class="headerlink" title="系统调用和库函数区别"></a>系统调用和库函数区别</h2><p>系统用时操作系统向上提供的接口</p><p>有的库函数是对系统调用的进一步封装</p><p>当今编写的应用程序大多是通过高级语言提供的库数接的进行系统调用</p><h2 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a>系统调用背后的过程</h2><ul><li>用户程序执行陷入指令（又称访问指令/Trap指令），请求操作系统服务</li><li>操作系统内核程序对系统调用进行相应处理</li><li>处理完成后，操作系统内核程序将CPU使用权还给用户</li></ul><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><ul><li><p>大内核</p><p>操作系统的主要功能模块都作为一个紧密联系的整体运行在和心态，为应用提供高性能的系统服务。但随着体系结构和应用需求的发展，需要操作系统提供的服务越来越多，接口越来越复杂，设计规模急剧增长。</p><p>优点： 高性能</p><p>缺点： 内核代码庞大、结构混乱、难以维护</p></li><li><p>微内核</p><ul><li><p>将内核中最基本的功能保留在内核，将不需要在核心态执行的功能移到用户态执行，降低内核的设计复杂性。</p></li><li><p>被移出的代码根据分层的原则被划分为若干服务程序，执行相互独立，交互借助于微内核进行通信。</p></li><li><p>微内核结构有效的分离了内核与服务、服务与服务，使得接口更加清晰，维护代价大大降低，各部分可以独立的优化和演进，从而保证操作系统的可靠性。</p></li><li><p>客户服务器模式：将进行划分为两类，服务器用来提供服务，客户端使用这些服务。</p></li></ul><p>优点： 内核功能少、结构清晰、方便维护</p><p>缺点：需要频繁在用户态和核心态之间切换，性能低</p></li></ul><p><strong>内核态→用户态</strong>：执行一条特权指令一一修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</p><p><strong>用户态→内核态</strong>：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201122162253358.png" alt="image-20201122162253358"></p><h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><h2 id="CPU-（Central-Processing-Unit）"><a href="#CPU-（Central-Processing-Unit）" class="headerlink" title="CPU （Central Processing Unit）"></a>CPU （Central Processing Unit）</h2><ul><li>CPU从系统的RAM中提取指令，然后解码该指令的实际内容，然后由CPU的相关部分执行该指令（提取、解码和执行）</li><li>CPU从功能上看主要由两部分构成<ol><li>控制单元： 从内存中提取指令并解码执行</li><li>算数逻辑单元（ALU）： 处理算数和逻辑运算</li></ol></li><li>内部结构：<ol><li>寄存器：中央处理器内的组成部分。用来暂存指令、数据和地址。可以将其看作是内存的一中，根据种类的不同，一个CPU内部会有20-100个寄存器。</li><li>控制器：负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机</li><li>运算器： 负责运算从内存中读入寄存器的数据</li><li>时钟：负责发出CPU开始计时的时钟信号</li></ol></li></ul><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>累加寄存器</td><td>存储运行的数据和运算后的数据</td></tr><tr><td>标志寄存器</td><td>用于反应处理器的状态和运算结果的某些特征以及控制指令的执行</td></tr><tr><td>程序计数器</td><td>程序计数器是用于存放下一条指令所在单元的地址的地方</td></tr><tr><td>基址寄存器</td><td>存储数据内存的起始位置</td></tr><tr><td>变址寄存器</td><td>存储基址寄存器的相对地址</td></tr><tr><td>通用寄存器</td><td>存储任意数据</td></tr><tr><td>指令寄存器</td><td>储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td></tr><tr><td>栈寄存器</td><td>存储栈区域的起始位置</td></tr></tbody></table><ul><li>CPU指令执行过程<ol><li>取指令</li><li>指令译码</li><li>执行指令</li><li>访问取数</li><li>结果写回</li></ol></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的。</li><li>又称为主存，作用是存放CPU中的运算数据，以及与硬盘等外部存储设备交换的数据</li><li>只要计算机在运行中，CPU就会把需要运算的数据调到主存中进行运算，当运算完成后CPU再将结构传送回来</li><li>内存的内部是有各种IC（Integrated Circuit，集成电路）电路组成的，它的种类很庞大，但是主要分为三种存储器：<ol><li>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</li><li>只读存储器（ROM）：ROM一般只能用于数据的读取，不能写入数据，但是当机器停电时，数据不会丢失</li><li>高速缓存（Cache）：分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache），它位于内存和CPU之间，是一个读写速度比内存更快的存储器。当CPU向内存写入数据时，这些数据会被写入高速缓存中，需要读取数据时，会直接从高速缓存中读取。如果需要的数据在Cache中没有，会再去读取内存中的数据</li></ol></li></ul><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><ul><li>磁盘中存储的程序必须加载到内存中才能运行，在磁盘中保存的程序是无法直接运行的。这是因为负责解析和运行程序内容的CPU是需要通过程序计数器来指定内存地址从而读出程序指令的。</li><li>磁盘缓存和虚拟内存</li></ul><h2 id="BIOS和引导"><a href="#BIOS和引导" class="headerlink" title="BIOS和引导"></a>BIOS和引导</h2><p>程序的运行环境，存在着名为BIOS（Basic Input/Output System）的系统。BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘和显卡等基本控制外，还有引导程序的功能，引导程序是存储在启动驱动器启示区域的小程序。</p><p>电脑开机后，BIOS会确认硬件是否正常运行，没有异常的话会直接启动引导程序。引导程序的功能是吧在硬盘等记录的OS加载到内存中运行。虽然启动应用是OS的功能，但是OS不能启动自己，是通过引导程序启动的。</p><h2 id="DMA（Direct-Memory-Access）"><a href="#DMA（Direct-Memory-Access）" class="headerlink" title="DMA（Direct Memory Access）"></a>DMA（Direct Memory Access）</h2><p>DMA是指在不通过CPU的情况下，外围设备直接和主存进行数据传输。通过DMA大量数据可以在短时间内实现传输，因为CPU作为中介的事件被节省了。</p><p>参考: 王道考研 <a href="https://www.bilibili.com/video/BV1YE411D7nH">计算机操作系统</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;操作系统举例&quot;&gt;&lt;a href=&quot;#操作系统举例&quot; class=&quot;headerlink&quot; title=&quot;操作系统举</summary>
      
    
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://leslieaibin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch7.6.1 入门到实战</title>
    <link href="https://leslieaibin.github.io/2020/11/20/Java/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://leslieaibin.github.io/2020/11/20/Java/ElasticSearch/ElasticSearch%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2020-11-19T16:15:42.000Z</published>
    <updated>2020-11-20T13:30:03.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ElasticSearch</strong> ，简称为es，是一个开源的、高拓展的分布式全文检索引擎，它可以近乎实时的存储、检索数据。本身拓展性很好，可以拓展到上百台服务器，处理PB级别的数据。ElasticSearch使用java开发并且使用Lucene作为其核心来实现所有索引和搜索的功能，但是他的目的是通过简单的RestFul API来隐藏Lucene的复杂性，从而让全文检索变得简单。</p><h2 id="ElasticSearch和Solr的比较"><a href="#ElasticSearch和Solr的比较" class="headerlink" title="ElasticSearch和Solr的比较"></a>ElasticSearch和Solr的比较</h2><ul><li>es基本上是开箱即用，非常简单，Solr安装略麻烦；</li><li>Solr利用Zookeeper进行分布式管理，而elasticsearch自身就带有分布式协调管理功能；</li><li>Solr支持更多格式的数据，例如：json，xml，csv，而ElasticSearch仅仅支持json文件格式；</li><li>Solr官方提供的功能更多，而ElasticSearch本身更注重核心功能，高级功能多由第三方插件提供，例如图形化界面需要kibana友好支持；</li><li>Solr查询快，但更新索引时慢（即插入删除慢），用于电商的查询多的应用；<ul><li>ElasticSearch建立索引快（即查询慢），即实时性查询快，用于新浪的搜索；</li><li>Solr是传统搜索应用的解决方案，但ElasticSearch更适用于新兴的实时搜索应用。</li></ul></li><li>Solr比较成熟，有一个更大、更成熟的用户、开发和贡献者社区，而ElasticSearch相对开发维护者较少，更新太快，学习使用成本较高。</li></ul><h2 id="ElasticSearch安装及启动"><a href="#ElasticSearch安装及启动" class="headerlink" title="ElasticSearch安装及启动"></a>ElasticSearch安装及启动</h2><p>声明：ElasticSearch要求安装环境必须是要jdk1.8以上才行。</p><p><strong>1、下载安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f873770589" alt="在这里插入图片描述"></p><p><strong>2、解压安装包完成解压</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f87e35e972" alt="在这里插入图片描述"></p><p>解压完成即安装完成。</p><p><strong>3、ElasticSearch目录环境说明</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204157257.png" alt="image-20201120204157257"></p><ul><li>bin：可执行文件</li><li>config：配置文件<ul><li>elasticsearch.yml：项目配置文件</li><li>jvm.options：jvm相关的配置文件</li><li>log4j2.properties：日志相关配置文件</li></ul></li><li>jdk：相关的jdk环境</li><li>lib：项目所使用的相关jar包</li><li>logs：日志信息</li><li>modules：模块信息</li><li>plugins：插件信息</li></ul><p><strong>4、启动ElasticSearch</strong> 双击elasticsearch.bat运行。</p><p><strong>5、访问</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204350146.png" alt="image-20201120204350146"></p><p>访问成功！</p><h2 id="可视化界面的安装"><a href="#可视化界面的安装" class="headerlink" title="可视化界面的安装"></a>可视化界面的安装</h2><p>声明：可视化界面的安装必须基于node.js的环境</p><p><strong>1、下载可视化界面的项目压缩包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f882073b44" alt="在这里插入图片描述"></p><p><strong>2、解压</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204504275.png" alt="image-20201120204504275"></p><p><strong>3、启动可视化页面</strong></p><p>因为是基于node.js的前端项目，所以我们先要进入到项目文件，在cmd窗口中使用<code>npm install</code>命令安装相关环境，然后使用<code>npm run start</code>运行项目：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204553147.png" alt="image-20201120204553147"></p><p>启动完成，访问端口是9100。</p><h3 id="解决可视化界面访问ElasticSearch产生的跨域问题"><a href="#解决可视化界面访问ElasticSearch产生的跨域问题" class="headerlink" title="解决可视化界面访问ElasticSearch产生的跨域问题"></a>解决可视化界面访问ElasticSearch产生的跨域问题</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f89b18c48e" alt="在这里插入图片描述"></p><p>可视化界面的端口是9100，通过可视化界面去访问9200的ElasticSearch会产生跨域问题。</p><p><strong>修改ElasticSearch.yml文件让其支持跨域请求</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a5a5264d" alt="在这里插入图片描述"></p><p>在yml文件的最后加上允许跨域的配置，并重启ElasticSearch。</p><p>重启之后再使用可视化界面进行访问：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a538bc03" alt="在这里插入图片描述"></p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Kibana是一个针对ElasticSearch的开源分析及可视化平台，用于搜索、查看交互存储在ElasticSearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解，它操作简单，基于浏览器的用户界面可以快速创建仪表板实时显示ElasticSearch查询动态。设置Kibana非常简单，无需编码或者额外的基础架构，几分钟就可以完成安装并启动索引监测。</p><p><strong>注意事项</strong>：Kibana的版本必须要与安装的es版本一致。</p><p>我们可以将es理解为一个处理海量数据的数据库，Kibana可以监测并分析数据库中的数据信息。</p><h3 id="Kibana的安装和启动"><a href="#Kibana的安装和启动" class="headerlink" title="Kibana的安装和启动"></a>Kibana的安装和启动</h3><p><strong>1、下载安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8a95bfccc" alt="在这里插入图片描述"></p><p><strong>2、解压安装包</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204800373.png" alt="image-20201120204800373"></p><p><strong>3、启动Kibana</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204914227.png" alt="image-20201120204914227"></p><p><strong>4、访问</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120204935828.png" alt="image-20201120204935828"></p><p>访问成功！</p><h3 id="Kibana的汉化"><a href="#Kibana的汉化" class="headerlink" title="Kibana的汉化"></a>Kibana的汉化</h3><p>Kibana是支持汉化的，我们只需要在他的项目yml文件中进行相关配置即可：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8c8bc988d" alt="在这里插入图片描述"></p><p>配置保存之后重启Kibana：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8ca016c3f" alt="在这里插入图片描述"></p><p>汉化完成！</p><h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><p>ElasticSearch是一个面向文档的数据库，其中的所有数据都是json，以下是各种专用名词和关系型数据库的对比：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8d088a633" alt="在这里插入图片描述"></p><p>ElasticSearch中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档，每个文档中又包含多个字段。</p><p><strong>物理设计：</strong></p><p>ElasticSearch在后台把每个索引划分为多个分片，每份分片可以在集群的不同服务器间迁移。ElasticSearch一启动就是一个集群，哪怕只有一个，默认的集群名称为：elasticsearch。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120205122140.png" alt="image-20201120205122140"></p><p><strong>逻辑设计</strong></p><p>在ES中，一个索引中包含多个文档，当我们索引一篇文档时，可以通过这样的顺序找到它：索引&gt;类型&gt;文档ID。通过这个组合我们就能索引到某个具体的文档。</p><blockquote><p>文档</p></blockquote><p>文档的概念换算到关系型数据库中就类似于一条数据。</p><p>ES是面向文档的，也就意味着索引和搜索数据的最小单位是文档，在ElasticSearch中，文档有几个重要属性：</p><ul><li>自我包含：一片文档同时包含字段和对应的值，也就是同时包含key-value；</li><li>可以是层次型的：一个文档包含另一个文档；</li><li>灵活的结构：文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用。在ElasticSearch中，对于字段是非常灵活的，有时候我们可以忽略该字段，或者动态的添加一个新的字段。</li></ul><blockquote><p>类型</p></blockquote><p>类型是文档的逻辑容器，就像关系型数据库中表格是行的容器一样，类型对于字段的定义称之为映射，比如说<code>name</code>映射为字符串类型。</p><p>我们说文档是无模式的，我们不需要对我们新增的每一个字段的类型进行映射，在没有进行映射的时候Elasticsearch会对数据的类型进行猜测，但是也有可能会猜不对，所以最安全的方式提前定义好所需要的映射，这一部分就跟关系型数据库差不多了。</p><blockquote><p>索引</p></blockquote><p>索引就类似于关系型数据库中的数据库。</p><p>索引是映射类型的容器，ElasticSearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置，然后他们被保存到了各个分片上。</p><blockquote><p>物理设计：节点和分片如何工作</p></blockquote><p>一个集群至少有一个节点，就是最基本的elasticsearch进程，每个节点可以有多个索引，如果你创建索引，则，默认会创建5个分片（又称主分片），每一个分片都会有一个副本（又称复制分片）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8e4abf4d5" alt="在这里插入图片描述"></p><p>例如上图是一个有三个节点的集群，可以看到主分片对应的复制分片都不会在同一个节点内，这样就有利于如果某个节点挂掉了，数据也不至于丢失，</p><p>实际上，一个分片是一个lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使得ElasticSearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。</p><p>等等，倒排索引是什么？？？？</p><blockquote><p>倒排索引</p></blockquote><p>Lucene采用倒排索引作为底层，这种设计适用于快速的全文搜索。</p><p>在ElasticSearch中，倒排索引的做法是对索引中的每个单词都进行重构为一个索引列表， 这样就可以清楚的反应每个单词在文档中的位置，当我们想要查找某个数据的时候，根据倒排索引生成的索引列表就可以最大限度的避免不符合数据的重复查询，只会在包含该数据的文档中进行查询。</p><p>例如下图数据：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8e661322b" alt="在这里插入图片描述"></p><p>在以上数据中可以得知：python这个词条，在1，2，3号文档中都有出现，linux这个词条在3，4号文档中出现，当我们想要查询linux这个词条的时候，根据倒排索引生成的索引列表，就不会再去查询1，2这两个文档，最大限度的避免了无用数据的查询。</p><p><strong>ElasticSearch索引和Lucene索引的关系</strong></p><p>在ElasticSearch中，每创建一个索引就会生成多个分片，其实每个分片就是一个Lucene索引，所以一个ElasticSearch索引本质就是用多个Lucene索引构成的。</p><h2 id="ik分词器插件"><a href="#ik分词器插件" class="headerlink" title="ik分词器插件"></a>ik分词器插件</h2><blockquote><p>什么是分词器？</p></blockquote><p>分词的意思就是把一段文字分成一个个的关键字，我们在搜索的时候会把自己的信息进行分词，会把数据库中的数据进行分词，然后进行一个匹配操作。</p><p>例如，我搜索”奥特曼打小怪兽“，在搜索结果中你可能看到只包含”奥特曼“的信息，也有可能看到只包含”小怪兽”的信息，这就是程序对我们的搜索信息进行了分词。</p><p>而默认的中文分词器是将每一个字分成一个词，例如：”奥特曼“分解成”奥“”特“”曼“。这种粒度的分词显然是不太方便的，所以在此我们使用ik分词器插件。</p><p>ik分词器提供了两个分词算法：ik_smart和ik_max_word，其中ik_smart为最少切分，ik_max_word为最细粒度切分。</p><h3 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h3><p><strong>1、下载</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8ee6df28f" alt="在这里插入图片描述"></p><p><strong>2、将压缩包解压到ElsticSearch的插件包中</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8eef02040" alt="在这里插入图片描述"></p><p><strong>3、重启ElasticSearch</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f8f1893256" alt="在这里插入图片描述"></p><p>重启可以在日志中观察到ik分词器插件被加载。</p><p><strong>4、使用ElasticSearch的命令查看插件是否安装成功</strong></p><p>在ElasticSearch的bin目录中打开cmd窗口，输入命令<code>elasticsearch-plugin list</code>即可查看安装的插件列表：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f906288fc5" alt="在这里插入图片描述"></p><h3 id="使用Kibana发送请求展示ik分词器效果"><a href="#使用Kibana发送请求展示ik分词器效果" class="headerlink" title="使用Kibana发送请求展示ik分词器效果"></a>使用Kibana发送请求展示ik分词器效果</h3><p><strong>json代码：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET _analyze   //请求分词器</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,   <span class="comment">//选择分词算法</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;大连理工大学信息检索与文本挖掘&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>分词效果：</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120205327514.png" alt="image-20201120205327514"></p><p>由上可以看到，分词器会根据语句中的词语进行分割，但是他们怎么认使什么字连起来是一个词呢？这是因为在分词器的内部有一个自己的字典，可以识别常用的正常词语，当我们输入一个人名或者自己捏造的词语的时候就无法达到想要的效果。</p><h2 id="ElasticSearch基本操作"><a href="#ElasticSearch基本操作" class="headerlink" title="ElasticSearch基本操作"></a>ElasticSearch基本操作</h2><p>操作ElasticSearch的命令都是通过RestFul风格的请求命令去完成的，大致如下图：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9645bb539" alt="在这里插入图片描述"></p><blockquote><p>使用Kibana演示基础操作</p></blockquote><h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><p>语法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引名/类型名/文档id</span><br><span class="line">&#123;</span><br><span class="line">    请求体</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f92a72cc2f" alt="在这里插入图片描述"></p><p>在head页面上查看数据：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9436bf43b" alt="在这里插入图片描述"></p><p>由以上示例可知，我们通过put命令创建了一个索引并添加了文档数据，但是我们并没有给这个索引映射类型，在ElasticSearch中数据有多少的数据类型呢？</p><p>ElasticSearch相关的数据类型：</p><ul><li>字符串类型：text、keyword</li><li>数值类型：long、integer、short、byte、doule、float、half float、scaled float</li><li>日期类型：date</li><li>布尔值类型：boolean</li><li>二进制类型：binary</li><li>等等……</li></ul><h3 id="创建一个索引不赋值并指定类型"><a href="#创建一个索引不赋值并指定类型" class="headerlink" title="创建一个索引不赋值并指定类型"></a>创建一个索引不赋值并指定类型</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f936aa0804" alt="在这里插入图片描述"></p><p>以上json命令只创建了一个test2索引并映射类型</p><h3 id="查看索引信息"><a href="#查看索引信息" class="headerlink" title="查看索引信息"></a>查看索引信息</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9321042df" alt="在这里插入图片描述"></p><p>通过<code>GET</code>命令就可以查看到索引的信息，后面的目标准确到索引就查看索引信息，准确到文档就查看文档信息。</p><h3 id="修改文档信息"><a href="#修改文档信息" class="headerlink" title="修改文档信息"></a>修改文档信息</h3><p>修改文档信息有两种方式，第一种是通过PUT命令在原来的文档上添加数据进行覆盖，第二种是通过POST进行修改。</p><p>1）PUT覆盖修改</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f98191b029" alt="在这里插入图片描述"></p><p>使用PUT进行修改有一个弊端，就是他会将所有的数据都进行覆盖，如果你修改的字段有缺漏，则缺漏的部分会被覆盖为空，造成数据的丢失。</p><p>2)POST方式修改</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9450e430e" alt="img"></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除索引信息通过DELETE命令来完成。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f946619a01" alt="在这里插入图片描述"></p><p>DELETE操作和GET操作一样，后面的目标精确到文档就删除文档信息，精确到索引就删除索引信息。</p><h2 id="复杂查询操作"><a href="#复杂查询操作" class="headerlink" title="复杂查询操作"></a>复杂查询操作</h2><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET 索引名&#x2F;类型名&#x2F;_search?q&#x3D;字段名:字段值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9488dfd73" alt="在这里插入图片描述">关于基础条件查询语句的解析： 其中_search后面的q的意思是query，在语法中是一个对象，完整的写法应该如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9590bc229" alt="在这里插入图片描述"></p><p>如上图所示，我们可以在query对象中设置很多的参数来完成各种情况下的查询方式。查询的结果中包含一个hits对象，这个对象的参数就包含了所有具体的查询结果。</p><h3 id="条件查询-只显示某几个字段"><a href="#条件查询-只显示某几个字段" class="headerlink" title="条件查询_只显示某几个字段"></a>条件查询_只显示某几个字段</h3><p>默认情况下的条件查询会将文档的所有字段都查询出来，但是我们可以通过一个_source属性去指定想要查询出来的字段：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f95acc765b" alt="在这里插入图片描述"></p><p>由上图可以看到，当我们指定了只查询”name”字段的时候，后面查询出来的信息中就只包含了”name”字段信息。</p><h3 id="根据指定字段排序查询"><a href="#根据指定字段排序查询" class="headerlink" title="根据指定字段排序查询"></a>根据指定字段排序查询</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9674eeaa8" alt="在这里插入图片描述"></p><p>如上图所示，按照age字段进行降序排列，因为我们自定义了按照某种规则进行排序吗，所以之前的排序规则分数就会为Null。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9682f7fbd" alt="在这里插入图片描述"></p><p>我们可以通过设置”from”和”size”参数来设置分页查询的相关信息。</p><h3 id="布尔值查询"><a href="#布尔值查询" class="headerlink" title="布尔值查询"></a>布尔值查询</h3><p>通过布尔值查询的方式我们可以实现类似于数据库的多条件查询：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9686da4ea" alt="在这里插入图片描述"></p><p>例如通过这个must指令就可以实现多条件查询，在上图中，只有同时满足name中包含张三，并且年龄为18的数据才会被查询出。</p><p>简单的来说满足这两个条件就会返回true的布尔值然后被查询出来，所以被叫做布尔值查询，相当于sql语句中的where and条件语句。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f97b3bba44" alt="在这里插入图片描述"></p><p>而should命令则表示后方的两个条件只需要满足其中之一即可，就类似于sql语句中的where or条件语句。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9846bacda" alt="在这里插入图片描述"></p><p>同理，must_not表示查询出不满足条件的数据，例如上图查询出年龄不为18的信息，相当于sql中的not条件语句。</p><h3 id="过滤查询操作"><a href="#过滤查询操作" class="headerlink" title="过滤查询操作"></a>过滤查询操作</h3><p>在满足多种条件查询的同时，es也支持我们对查询的数据进行进一步的筛选过滤。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f987f687fc" alt="在这里插入图片描述"></p><p>通过上图的配置可以实现按照年龄大小进行进一步过滤的操作，gte是大于等于操作，lte是小于等于操作，gt只表示大于操作，lt只表示小于操作。</p><p>同时，也可以同时设置大于和小于来进行值的区间搜索操作，相当于sql中的between and条件。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9a430a6c0" alt="在这里插入图片描述"></p><h3 id="匹配多个条件查询"><a href="#匹配多个条件查询" class="headerlink" title="匹配多个条件查询"></a>匹配多个条件查询</h3><p>匹配多个条件查询就有点类似于sql中的in关键字。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9a77edf10" alt="在这里插入图片描述"></p><p>如图所示，tags是兴趣标签，在数据中是以数组的形式存在的，也就是说有多个值，通过这种方式就可以进行多个值的随意匹配。</p><h3 id="精确匹配term"><a href="#精确匹配term" class="headerlink" title="精确匹配term"></a>精确匹配term</h3><p><strong>term精确匹配和match的不同：</strong></p><p>term会将条件依据倒排索引进行精确匹配，而match则会将查询条件进行分词然后再匹配。简单的来说，match会产生类似与模糊查询的效果，而term不会，条件匹配不上即使数据包含查询条件也不会被查询出来。</p><p><strong>关于text和keyword类型：</strong></p><p>text类型和keyword的不同之处在于，text会被分词器进行分词，而keyword不会被分词器分词。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9ac0d8885" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9b6e25f4f" alt="在这里插入图片描述"></p><h3 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h3><p>ElasticSearch同时也支持高亮查询，他会将查询结果中的查询条件关键字进行自动的高亮显示。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9be9b79bf" alt="在这里插入图片描述"></p><h2 id="SpringBoot集成ElasticSearch"><a href="#SpringBoot集成ElasticSearch" class="headerlink" title="SpringBoot集成ElasticSearch"></a>SpringBoot集成ElasticSearch</h2><p>此次SpringBoot集成ElasticSearch采用SpringBoot脚手架来进行学习。</p><p><strong>1、勾选引入ElasticSearch依赖</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9d015dd3a" alt="在这里插入图片描述"></p><p>勾选之后需要注意的是，我们在此使用的SpringBoot版本为2.3.1，此版本的ES客户端并不是本地安装的7.6.1版本：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120210008727.png" alt="image-20201120210008727"></p><p>因此，我们需要在pom.xml进行ES客户端版本的自定义配置：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120210127576.png" alt="image-20201120210127576"></p><p>版本依赖导入完成！</p><p><strong>2、书写配置类将ES对象注入到Spring容器之中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/16 21:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//ES集群的相关信息，如果有多个就配置多个</span></span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，SpringBoot集成ElasticSearch就完成了。</p><h2 id="关于java操作ES索引的API"><a href="#关于java操作ES索引的API" class="headerlink" title="关于java操作ES索引的API"></a>关于java操作ES索引的API</h2><p>关于java API的学习都会在测试类中进行完成。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parse</span><span class="params">(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.parseContent(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span>String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span><span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span><span class="keyword">int</span> pageSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.searchPageHighlightBuilder(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建成功!</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9df034b64" alt="在这里插入图片描述"></p><h3 id="判断索引是否存在"><a href="#判断索引是否存在" class="headerlink" title="判断索引是否存在"></a>判断索引是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据放入es搜索中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">parseContent</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Content&gt; contents = <span class="keyword">new</span> HtmlParseUtil().parseJD(keywords);</span><br><span class="line">    <span class="comment">// 把查询到的数据放入es中</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contents.size(); i++) &#123;</span><br><span class="line">        bulkRequest.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;jd_goods&quot;</span>)</span><br><span class="line">                        .source(JSON.toJSONString(contents.get(i)),XContentType.JSON));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> !bulk.hasFailures();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9e05854a9" alt="在这里插入图片描述"></p><h3 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;测试删除索引</span><br><span class="line">    @Test</span><br><span class="line">    void deleteIndex() throws IOException &#123;</span><br><span class="line">        DeleteIndexRequest java_index &#x3D; new DeleteIndexRequest(&quot;java_index&quot;);</span><br><span class="line">        AcknowledgedResponse delete &#x3D; restHighLevelClient.indices().delete(java_index, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(delete.isAcknowledged());  &#x2F;&#x2F;获取删除成功与否的提示信息</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码效果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9e8afbaad" alt="在这里插入图片描述"></p><p>删除成功！</p><h2 id="关于java操作ES文档的API"><a href="#关于java操作ES文档的API" class="headerlink" title="关于java操作ES文档的API"></a>关于java操作ES文档的API</h2><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试添加文档</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//创建请求</span></span><br><span class="line">        IndexRequest java_index = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;java_index&quot;</span>);</span><br><span class="line">        <span class="comment">//填充规则</span></span><br><span class="line">        java_index.id(<span class="string">&quot;1&quot;</span>);  <span class="comment">//文档编号</span></span><br><span class="line">        <span class="comment">//将对象放入请求中</span></span><br><span class="line">        java_index.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">        <span class="comment">//客户端发送请求，接收响应结果</span></span><br><span class="line">        IndexResponse index = restHighLevelClient.index(java_index, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//打印响应结果</span></span><br><span class="line">        System.out.println(index.toString());  <span class="comment">//查看返回的具体json信息</span></span><br><span class="line">        System.out.println(index.status());  <span class="comment">//查看操作的状态</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因为ES只支持json格式的数据流通，所以在将对象放入请求的过程中需要将对象序列化为josn字符串，在此需要阿里巴巴的fastjson支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看添加文档结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0f9ffc955bd" alt="在这里插入图片描述"></p><p>添加成功！</p><h3 id="判断文档是否存在"><a href="#判断文档是否存在" class="headerlink" title="判断文档是否存在"></a>判断文档是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试判断文档是否存在</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExistDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">GetRequest java_index = <span class="keyword">new</span> GetRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> exists = restHighLevelClient.exists(java_index, RequestOptions.DEFAULT);</span><br><span class="line">System.out.println(exists);  <span class="comment">//返回布尔值表示是否存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa092d0cdf" alt="在这里插入图片描述"></p><p>一号文档存在！</p><h3 id="获取文档信息"><a href="#获取文档信息" class="headerlink" title="获取文档信息"></a>获取文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试获取文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetRequest java_index = <span class="keyword">new</span> GetRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    GetResponse getResponse = restHighLevelClient.get(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(getResponse.getSourceAsString());  <span class="comment">//打印文档的内容</span></span><br><span class="line">    System.out.println(getResponse);  <span class="comment">//getResponse对象就包含ES的所有查询信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码效果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa03154a2d" alt="在这里插入图片描述"></p><h3 id="修改文档记录"><a href="#修改文档记录" class="headerlink" title="修改文档记录"></a>修改文档记录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试修改文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UpdateRequest java_index = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;法外狂徒张三&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    java_index.doc(JSON.toJSONString(user),XContentType.JSON);</span><br><span class="line">    UpdateResponse update = restHighLevelClient.update(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(update.status());  <span class="comment">//查看更新状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa22459d38" alt="在这里插入图片描述"></p><p>修改成功！</p><h3 id="删除文档信息"><a href="#删除文档信息" class="headerlink" title="删除文档信息"></a>删除文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteRequest java_index = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;java_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    DeleteResponse delete = restHighLevelClient.delete(java_index,RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(delete.status());  <span class="comment">//查看删除状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa2230fc5d" alt="在这里插入图片描述"></p><p>删除成功！</p><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>ES同时也支持批量增删改的操作，在此只演示批量添加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试批量添加文档下信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bulkDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建批量操作对象</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    ArrayList&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三1&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三2&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三3&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三4&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;张三5&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        bulkRequest.add(</span><br><span class="line">                <span class="keyword">new</span> IndexRequest(<span class="string">&quot;java_index&quot;</span>).id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>))</span><br><span class="line">                        .source(JSON.toJSONString(list.get(i)),XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(bulk.hasFailures());  <span class="comment">//查看状态，是否失败，返回false代表成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa23f07bfa" alt="在这里插入图片描述"></p><h3 id="查询文档信息"><a href="#查询文档信息" class="headerlink" title="查询文档信息"></a>查询文档信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试查询文档信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建请求对象</span></span><br><span class="line">    SearchRequest java_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;java_index&quot;</span>);</span><br><span class="line">    <span class="comment">//构造搜索条件</span></span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//使用工具类构造搜索信息</span></span><br><span class="line">    MatchQueryBuilder query = QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三1&quot;</span>);</span><br><span class="line">    searchSourceBuilder.query(query);</span><br><span class="line">    java_index.source(searchSourceBuilder);</span><br><span class="line">    <span class="comment">//发送请求</span></span><br><span class="line">    SearchResponse search = restHighLevelClient.search(java_index, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(JSON.toJSONString(search.getHits()));  <span class="comment">//Hits对象就包含查询的各种信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查询结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa2895e40e" alt="在这里插入图片描述"></p><p>Hits对象中包含的是所有的查询结果信息，我们可以通过遍历想要的参数获得具体的信息。</p><p>对于复杂查询的各种操作都可以在searchSourceBuilder对象的方法中找到对应的方法：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa23f5904f" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa37d4fde0" alt="在这里插入图片描述"></p><h2 id="ElasticSeatch项目实战：京东搜索"><a href="#ElasticSeatch项目实战：京东搜索" class="headerlink" title="ElasticSeatch项目实战：京东搜索"></a>ElasticSeatch项目实战：京东搜索</h2><p>此次项目实战采用java爬虫爬取京东的数据放在es数据源中，然后通过页面来模拟京东搜索。</p><h3 id="1、项目搭建"><a href="#1、项目搭建" class="headerlink" title="1、项目搭建"></a>1、项目搭建</h3><p><strong>创建项目并引入相关pom依赖</strong></p><p>相关pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xsh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>es_jdsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>es_jdsearch<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>yml相关配置</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">  <span class="comment">#关闭thymeleaf缓存</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>引入静态资源</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211525026.png" alt="image-20201120211525026"></p><p><strong>编写控制器访问index.html页面</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xsh.es_jdsearch.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>访问页面</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa567c20bf" alt="在这里插入图片描述"></p><h3 id="2、使用jsoup爬取京东相关的数据"><a href="#2、使用jsoup爬取京东相关的数据" class="headerlink" title="2、使用jsoup爬取京东相关的数据"></a>2、使用jsoup爬取京东相关的数据</h3><p><strong>引入jsoup依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>编写工具类解析网页爬取数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhangaibin.pojo.Content;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/19 15:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlParseUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HtmlParseUtil().parseJD(<span class="string">&quot;大连理工&quot;</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Content&gt; <span class="title">parseJD</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求</span></span><br><span class="line">        <span class="comment">// String url = &quot;https://search.jd.com/Search?keyword=&quot; + keywords+&quot;&amp;enc=utf-8&quot;;</span></span><br><span class="line">        <span class="comment">// 指定编码集，防止中文乱码</span></span><br><span class="line">        Document document = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            document = Jsoup.parse(<span class="keyword">new</span> URL(<span class="string">&quot;https://search.jd.com/Search?keyword=&quot;</span> + keywords + <span class="string">&quot;&amp;enc=utf-8&quot;</span>), <span class="number">30000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---JDSearchHtmlParser.parse()失败---&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析网页（jsoup返回的document就是浏览器返回的Document对象）</span></span><br><span class="line">        <span class="comment">//Document document = Jsoup.parse(new URL(url), 30000);</span></span><br><span class="line">        <span class="comment">// 所有在js中的方法，都可以使用</span></span><br><span class="line">        Element element = document.getElementById(<span class="string">&quot;J_goodsList&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有的li元素</span></span><br><span class="line">        Elements elements = element.getElementsByTag(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        List&lt;Content&gt; goodList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取元素内容,每个li标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element el : elements) &#123;</span><br><span class="line">            String img = el.getElementsByTag(<span class="string">&quot;img&quot;</span>).eq(<span class="number">0</span>).attr(<span class="string">&quot;data-lazy-img&quot;</span>);</span><br><span class="line">            String price = el.getElementsByClass(<span class="string">&quot;p-price&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            String title = el.getElementsByClass(<span class="string">&quot;p-name&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            Content content = <span class="keyword">new</span> Content();</span><br><span class="line">            content.setImg(img);</span><br><span class="line">            content.setPrice(price);</span><br><span class="line">            content.setTitle(title);</span><br><span class="line">            goodList.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：该类可以通过jsoup爬取页面上的相关信息，在爬取图片的时候狂神使用的是source-data-lazy-img属性，但是我在写的时候这个属性是无效的，还是使用的src属性才获取到的图片地址。</p><h3 id="3、书写接口使用工具类将解析到的数据插入到ElasticSearch中"><a href="#3、书写接口使用工具类将解析到的数据插入到ElasticSearch中" class="headerlink" title="3、书写接口使用工具类将解析到的数据插入到ElasticSearch中"></a>3、书写接口使用工具类将解析到的数据插入到ElasticSearch中</h3><p><strong>创建jd_goods索引</strong></p><p>在此通过图形化界面快速创建索引：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211807101.png" alt="image-20201120211807101"></p><p><strong>注入ElasticSearch客户端对象</strong></p><p>要实现对ES数据进行操作，首先肯定要通过配置类来注入客户端对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/16 21:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//ES集群的相关信息，如果有多个就配置多个</span></span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Controller代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangaibin.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhangaibin.service.ContentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Leslie</span></span><br><span class="line"><span class="comment"> * 2020/11/19 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parse</span><span class="params">(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.parseContent(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span>String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span><span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span><span class="keyword">int</span> pageSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.searchPageHighlightBuilder(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析数据放入es搜索中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">parseContent</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Content&gt; contents = <span class="keyword">new</span> HtmlParseUtil().parseJD(keywords);</span><br><span class="line">    <span class="comment">// 把查询到的数据放入es中</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contents.size(); i++) &#123;</span><br><span class="line">        bulkRequest.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;jd_goods&quot;</span>)</span><br><span class="line">        .source(JSON.toJSONString(contents.get(i)),XContentType.JSON));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="keyword">return</span> !bulk.hasFailures();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问接口就可以调用jsoup工具类将解析到的网页数据插入到es索引中，结果如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120211945140.png" alt="image-20201120211945140"></p><h3 id="4、书写接口分页带条件查询信息"><a href="#4、书写接口分页带条件查询信息" class="headerlink" title="4、书写接口分页带条件查询信息"></a>4、书写接口分页带条件查询信息</h3><p>数据有了之后，就是做数据展示，在此接口接收查询的关键字和分页的信息进行分页并带条件的查询：</p><p><strong>Controller接口代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询数据接口</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span> <span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span> <span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> jdService.search(keyword,pageNo,pageSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="number">0</span>)&#123;</span><br><span class="line">            pageNo=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建搜索对象</span></span><br><span class="line">        SearchRequest jd_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_goods&quot;</span>);</span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置分页信息</span></span><br><span class="line">        sourceBuilder.from(pageNo);</span><br><span class="line">        sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        TermQueryBuilder query = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">        <span class="comment">//封装搜索条件</span></span><br><span class="line">        sourceBuilder.query(query);</span><br><span class="line">        <span class="comment">//封装搜索对象</span></span><br><span class="line">        jd_index.source(sourceBuilder);</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        SearchResponse response = restHighLevelClient.search(jd_index, RequestOptions.DEFAULT);</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            list.add(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5、采用Vue-axios进行前后端分离数据展示"><a href="#5、采用Vue-axios进行前后端分离数据展示" class="headerlink" title="5、采用Vue+axios进行前后端分离数据展示"></a>5、采用Vue+axios进行前后端分离数据展示</h3><p><strong>使用npm下载vue.js和axios.js的相关文件</strong></p><p>首先我们随便创建一个英文名称的文件夹，在其中使用cmd命令行<code>npm init</code>来初始化，使用<code>npm install vue</code>和<code>npm install axios</code>来下载依赖。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa70f8d7eb" alt="在这里插入图片描述"></p><p>下载结果：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa69d12f5a" alt="在这里插入图片描述"></p><p>在项目中引入vue.min.js和axios.min.js文件：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa84b0d7b6" alt="在这里插入图片描述"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1724f0fa79343ca1" alt="在这里插入图片描述"></p><p>修改页面信息，动态绑定搜索框的数据和搜索按钮的单击事件，实现单击搜索按钮就发送请求进行ES库的查询，并且使用v-for将查询结果进行遍历显示，以下仅展示vue对象的相关代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--前端使用vue，实现前后端分离--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            keyword: <span class="string">&#x27;&#x27;</span>,<span class="comment">//搜索的关键字</span></span></span><br><span class="line"><span class="javascript">            results: []<span class="comment">//搜索的结果</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">searchKey</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> keyword = <span class="built_in">this</span>.keyword;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(keyword);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 对接后端的接口</span></span></span><br><span class="line"><span class="javascript">                axios.get(<span class="string">&#x27;search/&#x27;</span>+keyword+<span class="string">&quot;/1/20&quot;</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//对接后端代码</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.results = response.data;<span class="comment">// 绑定数据</span></span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>查看页面查询效果</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201120212100093.png" alt="image-20201120212100093"></p><p>以上，我们就通过代码完成了es数据库的查询操作，可以用来做页面的搜索功能。</p><p>但是如上图所示，我们不仅实现了搜索功能，还实现了关键字结果的高亮，这是因为接口的不同：</p><h3 id="6、分页待条件且关键字高亮查询"><a href="#6、分页待条件且关键字高亮查询" class="headerlink" title="6、分页待条件且关键字高亮查询"></a>6、分页待条件且关键字高亮查询</h3><p><strong>ServiceImpl代码展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高亮分页查询</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; searchHighLight(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pageNo==<span class="number">0</span>)&#123;</span><br><span class="line">            pageNo=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建搜索对象</span></span><br><span class="line">        SearchRequest jd_index = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_index&quot;</span>);</span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置分页信息</span></span><br><span class="line">        sourceBuilder.from(pageNo);</span><br><span class="line">        sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装高亮显示条件</span></span><br><span class="line">        HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">        highlightBuilder.field(<span class="string">&quot;title&quot;</span>);  <span class="comment">//对哪个字段进行高亮</span></span><br><span class="line">        highlightBuilder.preTags(<span class="string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>);  <span class="comment">//设置高亮前缀</span></span><br><span class="line">        highlightBuilder.postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);  <span class="comment">//高亮后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造搜索条件</span></span><br><span class="line">        TermQueryBuilder query = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">        <span class="comment">//封装搜索条件</span></span><br><span class="line">        sourceBuilder.query(query);</span><br><span class="line">        sourceBuilder.highlighter(highlightBuilder);  <span class="comment">//封装高亮搜索条件</span></span><br><span class="line">        <span class="comment">//封装搜索对象</span></span><br><span class="line">        jd_index.source(sourceBuilder);</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        SearchResponse response = restHighLevelClient.search(jd_index, RequestOptions.DEFAULT);</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">            HighlightField title = highlightFields.get(<span class="string">&quot;title&quot;</span>);  <span class="comment">//高亮之后的title</span></span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();  <span class="comment">//未高亮之前的结果集</span></span><br><span class="line">            <span class="comment">//接下来就是将高亮的title与结果集中未高亮的title进行替换</span></span><br><span class="line">            <span class="keyword">if</span>(title!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Text[] fragments = title.fragments();</span><br><span class="line">                String newTitle=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (Text text : fragments) &#123;</span><br><span class="line">                    newTitle+=text;</span><br><span class="line">                &#125;</span><br><span class="line">                sourceAsMap.put(<span class="string">&quot;title&quot;</span>,newTitle);  <span class="comment">//替换掉未高亮的title</span></span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sourceAsMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7-运行"><a href="#7-运行" class="headerlink" title="7. 运行"></a>7. 运行</h3><ol><li>启动ElasticSear</li><li>启动ElasticSearch-head</li><li>运行主启动类EsJdApplication.class</li><li>浏览器输入<a href="http://localhost:9090/parse/java">http://localhost:9090/parse/java</a> (要爬取的书籍)(将爬取结果放入es)</li><li><a href="http://localhost:9090/">http://localhost:9090</a> ，在搜索栏中输入java，就得到结果了，不过要先执行第4步，在es中有相应的东西才能有结果，目前中文不支持(即可以放进es，但得不到搜索结果)</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV17a4y1x7zq">狂神说</a> 他公众号有相应资源<br>         <a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">nodejs安装</a><br>         <a href="https://blog.csdn.net/wjnf012/article/details/80422313">cnpm安装</a><br>         <a href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&O=D">ElasticSearch</a><br>         <a href="https://mirrors.huaweicloud.com/logstash/?C=N&O=D">logstash</a><br>         <a href="https://mirrors.huaweicloud.com/kibana/?C=N&O=D">kibana</a></p><p><a href="https://juejin.cn/post/6844904168835006477#heading-46">小白必看_从入门到实战的ElasticSearch7.6.1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt; ，简称为es，是一个开源的、高拓展的分布式全文检索引擎，它可以近乎实时的存储、</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
    <category term="ElasticSearch" scheme="https://leslieaibin.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>100的阶乘是0？</title>
    <link href="https://leslieaibin.github.io/2020/11/18/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/100%E9%98%B6%E4%B9%98/"/>
    <id>https://leslieaibin.github.io/2020/11/18/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8B%E6%83%85/100%E9%98%B6%E4%B9%98/</id>
    <published>2020-11-17T16:15:42.000Z</published>
    <updated>2020-11-17T16:26:26.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="100的阶乘的0？"><a href="#100的阶乘的0？" class="headerlink" title="100的阶乘的0？"></a>100的阶乘的0？</h2><h3 id="有趣的疑问"><a href="#有趣的疑问" class="headerlink" title="有趣的疑问"></a>有趣的疑问</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/86735519.jpg" alt="img"></p><p>超出数据类型取值范围 会输出什么数字：</p><p> 数据类型：int</p><p> 取值范围：-2^31–2^31-1</p><p> 测试1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>  i3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">34</span>;i++)&#123;</span><br><span class="line">i3=i3*<span class="number">2</span>;</span><br><span class="line">System.out.println(i3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">512</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">2048</span></span><br><span class="line"><span class="number">4096</span></span><br><span class="line"><span class="number">8192</span></span><br><span class="line"><span class="number">16384</span></span><br><span class="line"><span class="number">32768</span></span><br><span class="line"><span class="number">65536</span></span><br><span class="line"><span class="number">131072</span></span><br><span class="line"><span class="number">262144</span></span><br><span class="line"><span class="number">524288</span></span><br><span class="line"><span class="number">1048576</span></span><br><span class="line"><span class="number">2097152</span></span><br><span class="line"><span class="number">4194304</span></span><br><span class="line"><span class="number">8388608</span></span><br><span class="line"><span class="number">16777216</span></span><br><span class="line"><span class="number">33554432</span></span><br><span class="line"><span class="number">67108864</span></span><br><span class="line"><span class="number">134217728</span></span><br><span class="line"><span class="number">268435456</span></span><br><span class="line"><span class="number">536870912</span></span><br><span class="line"><span class="number">1073741824</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>为了更详细的看出其变化，将在临界值前后输出更多值，测试2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i3=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">31</span>;i++)&#123;</span><br><span class="line">i3=i3*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=(i3-<span class="number">3</span>)*<span class="number">2</span>;k&lt;<span class="number">15</span>;j++,k++)&#123;</span><br><span class="line">System.out.println(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">测试结果</span><br><span class="line"></span><br><span class="line"><span class="number">2147483642</span></span><br><span class="line"><span class="number">2147483643</span></span><br><span class="line"><span class="number">2147483644</span></span><br><span class="line"><span class="number">2147483645</span></span><br><span class="line"><span class="number">2147483646</span></span><br><span class="line"><span class="number">2147483647</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line">-<span class="number">2147483647</span></span><br><span class="line">-<span class="number">2147483646</span></span><br><span class="line">-<span class="number">2147483645</span></span><br><span class="line">-<span class="number">2147483644</span></span><br><span class="line">-<span class="number">2147483643</span></span><br><span class="line">-<span class="number">2147483642</span></span><br><span class="line">-<span class="number">2147483641</span></span><br><span class="line">-<span class="number">2147483640</span></span><br></pre></td></tr></table></figure><p>分析：当前int型数据达到最大值2147483647时，是第一位为0，其余31位为全1，01111111111111111111111111111111；再加1则进1，第一位为1，其余全零，10000000000000000000000000000000。系统把第一位判断为负号，而且同时代表值，所以是-2147483648，当再继续相加时，系统会把之前的数当做负数，再加上正数1，则为-2147483647，10000000000000000000000000000001，后面以此类推。结合测试1，当为10000000000000000000000000000000时，即-2147483648，再乘以2将溢出，溢出位娶不到，全0，即为00000000000000000000000000000000，此时为0（-2147483648再乘以2为什么是0的理解） . 再乘以2依然为0.</p><p>为了解决这样大数的问题 引入了BigInteger 和 BigDecimal</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi &#x3D; new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">System.out.println(bi.pow(5)); &#x2F;&#x2F; 2867971860299718107233761438093672048294900000</span><br></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 &#x3D; new BigInteger(&quot;1234567890&quot;);</span><br><span class="line">BigInteger i2 &#x3D; new BigInteger(&quot;12345678901234567890&quot;);</span><br><span class="line">BigInteger sum &#x3D; i1.add(i2); &#x2F;&#x2F; 12345678902469135780</span><br></pre></td></tr></table></figure><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i &#x3D; new BigInteger(&quot;123456789000&quot;);</span><br><span class="line">System.out.println(i.longValue()); &#x2F;&#x2F; 123456789000</span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); &#x2F;&#x2F; java.lang.ArithmeticException: BigInteger out of long range</span><br></pre></td></tr></table></figure><p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure><p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比较BigDecimal</strong></p><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 &#x3D; new BigDecimal(&quot;123.456&quot;);</span><br><span class="line">BigDecimal d2 &#x3D; new BigDecimal(&quot;123.45600&quot;);</span><br><span class="line">System.out.println(d1.equals(d2)); &#x2F;&#x2F; false,因为scale不同</span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); &#x2F;&#x2F; true,因为d2去除尾部0后scale变为2</span><br><span class="line">System.out.println(d1.compareTo(d2)); &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p> 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h3 id="100的阶乘实现"><a href="#100的阶乘实现" class="headerlink" title="100的阶乘实现"></a>100的阶乘实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JieCheng</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法int</span></span><br><span class="line">        jichengint();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法biginteger</span></span><br><span class="line">        jiechengbiginteger();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用方法bigdecimal</span></span><br><span class="line">        jiechengbigdecimal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jichengint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘Int:  &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiechengbiginteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger result = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1&quot;</span>);<span class="comment">//为result赋初始值，为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            BigInteger num = <span class="keyword">new</span> BigInteger(String.valueOf(i));</span><br><span class="line">            result = result.multiply(num);<span class="comment">//调用自乘方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘BigInTeger  &quot;</span>+result);<span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;位数： &quot;</span>+String.valueOf(result).length());<span class="comment">//输出长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jiechengbigdecimal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//求一百的阶乘之和</span></span><br><span class="line">        <span class="comment">//只能用math里边的BigDecimal来存储数据</span></span><br><span class="line">        <span class="comment">//定义变量保存阶乘的和</span></span><br><span class="line">        BigDecimal result = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>);<span class="comment">//为result赋初始值，为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            BigDecimal num = <span class="keyword">new</span> BigDecimal(String.valueOf(i));</span><br><span class="line">            result = result.multiply(num);<span class="comment">//调用自乘方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘BigDecimal  &quot;</span>+result);<span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;位数： &quot;</span>+String.valueOf(result).length());<span class="comment">//输出长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">阶乘Int:  <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">阶乘BigInTeger <span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br><span class="line">位数： <span class="number">158</span></span><br><span class="line">    </span><br><span class="line">阶乘BigDecimal  <span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br><span class="line">位数： <span class="number">158</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;100的阶乘的0？&quot;&gt;&lt;a href=&quot;#100的阶乘的0？&quot; class=&quot;headerlink&quot; title=&quot;100的阶乘的0？&quot;&gt;&lt;/a&gt;100的阶乘的0？&lt;/h2&gt;&lt;h3 id=&quot;有趣的疑问&quot;&gt;&lt;a href=&quot;#有趣的疑问&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Java" scheme="https://leslieaibin.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
