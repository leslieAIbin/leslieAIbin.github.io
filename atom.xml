<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>天下熙熙，皆为利来；天下攘攘，皆为利往</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2020-11-08T14:14:40.250Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构简介</title>
    <link href="https://leslieaibin.github.io/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
    <id>https://leslieaibin.github.io/2020/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-07T16:15:42.000Z</published>
    <updated>2020-11-08T14:14:40.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构简介"><a href="#数据结构简介" class="headerlink" title="数据结构简介"></a>数据结构简介</h2><p>数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率。</p><p>如下图所示，常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1599638810-SZDwfK-Picture1.png" alt="Picture1.png"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/1599587176-JAxwpf-Picture2.png" alt="Picture2.png"></p><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h3><h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>为了在程序中使用一个数组，必须声明一个引用该数组的变量，并指明整个变量可以引用的数组类型。声明一维数组的语法格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName; <span class="comment">//数据类型[] 数组名;</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">type arrayName[]; <span class="comment">//数据类型 数组名[];</span></span><br></pre></td></tr></table></figure><p>数组的声明有两种形式：一种是中括号”[]“跟在元素数据类型之后，另一种是中括号”[]“跟在变量名之后。</p><p>对于以上两种语法格式而言，Java 更推荐采用第一种声明格式，因为第一种格式不仅具有更好的语意，而且具有更好的可读性。其中的数据类型既可以是基本数据类型，也可以是引用数据类型。数组名可以是任意合法的变量名。声明数组就是要告诉计算机该数组中数据的类型是什么。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] score;<span class="comment">//存储学生的成绩，类型是整型</span></span><br><span class="line"><span class="keyword">double</span>[] price;<span class="comment">//存储商品的价格，类型是浮点型</span></span><br><span class="line">String[] name;<span class="comment">//存储商品名称，类型为字符串型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在声明数组时不需要规定数组的长度，例如：</span></span><br><span class="line"><span class="keyword">int</span> score[<span class="number">10</span>];<span class="comment">//这是错误的</span></span><br></pre></td></tr></table></figure><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>声明了数组，只是得到了一个存放数组的变量，并没有为数组元素分配内存空间，不能使用。因此要为数组分配内存空间，这样数组的每一个元素才有一个空间进行存储。</p><p>简单地说，分配空间就是要告诉计算机在内存中为它分配几个连续的位置来存储数据。在 Java 中可以使用 new 关键字来给数组分配空间。分配空间的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[size];<span class="comment">//数组名 = new 数据类型[数组长度]</span></span><br></pre></td></tr></table></figure><p>其中，数组长度就是数组中能存放的元素个数，显然应该为大于 0 的整数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">price = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br><span class="line">name = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>这里的 score 是已经声明过的 int[] 类型的变量，当然也可以在声明数组时就给它分配空间，语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> type[size];    <span class="comment">// 数据类型[] 数组名 = new 数据类型[数组长度];</span></span><br></pre></td></tr></table></figure><p>例如，声明并分配一个长度为 5 的 int 类型数组 arr，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/3-1Q016111945238.jpg" alt="img"></p><p>在图  中 arr 为数组名称，方括号“[]”中的值为数组的下标。数组通过下标来区分数组中不同的元素，并且下标是从 0 开始的。因此这里包含 5 个元素的 arr 数组最大下标为 4。</p><p>注意：一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。</p><h4 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h4><p>Java 语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。</p><p>能不能只分配内存空间，不赋初始值呢？</p><p>不行，一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容为空，这个空也是一个值（null）。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种形式，一种由系统自动分配，另一种由程序员指定。</p><p>数组在初始化数组的同时，可以指定数组的大小，也可以分别初始化数组中的每一个元素。在 Java 语言中，初始化数组有以下 3 种方式。</p><ul><li><strong>使用new指定数组大小后进行初始化</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br></pre></td></tr></table></figure><p>创建数组后元素是不确定的，需要对数组的元素进行赋值，其下标从0开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">number[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">number[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">number[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">number[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>如果程序员只指定了数组的长度，那么系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值。</p><p>数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的值是 0。</p><p>数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是 0.0。</p><p>数组元素的类型是基本类型中的字符类型（char），则数组元素的值是‘\u0000’。</p><p>数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是 false。</p><p>数组元素的类型是引用类型（类、接口和数组），则数组元素的值是 null。</p><ul><li><strong>使用 new 指定数组元素的值</strong></li></ul><p>使用上述方式初始化数组时，只有在为元素赋值时才确定值。可以不使用上述方式，而是在初始化时就已经确定值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> type[]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,值 <span class="number">4</span>,• • •,值 n&#125;;</span><br></pre></td></tr></table></figure><p>指定数组元素的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p>上述代码的效果等价于第一种的效果。</p><p>注意：不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值，这样会造成代码错误。例如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">5</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">//这样是错误的</span></span><br></pre></td></tr></table></figure><ul><li>直接指定数组元素的值</li></ul><p>在上述两种方式的语法中，type 可以省略，如果已经声明数组变量，那么直接使用这两种方式进行初始化。如果不想使用上述两种方式，那么可以不使用 new 直接指定数组元素的值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = &#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,...,值 n&#125;;</span><br></pre></td></tr></table></figure><p>在前面例子的基础上更改代码，直接使用上述语法实现 number 数组的初始化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p>使用这种方式时，数组的声明和初始化操作要同步，即不能省略数组变量的类型。如下的代码就是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number;</span><br><span class="line">number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="获取单个元素"><a href="#获取单个元素" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>获取单个元素是指获取数组中的一个元素，如第一个元素或最后一个元素。获取单个元素的方法非常简单，指定元素所在数组的下标即可。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[index];</span><br></pre></td></tr></table></figure><p>其中，arrayName 表示数组变量，index 表示下标，下标为 0 表示获取第一个元素，下标为 array.length-1 表示获取最后一个元素。当指定的下标值超出数组的总长度时，会拋出 ArraylndexOutOfBoundsException 异常。</p><p>获取 number 数组中的第一个元素、最后一个元素和第六个元素，并将元素的值输出。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;获取第一个元素：&quot;</span>+number[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取最后一个元素：&quot;</span>+number[number.length-<span class="number">1</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取第6个元素：&quot;</span>+number[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure><p>执行上述代码，输出结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第一个元素：1</span></span><br><span class="line"><span class="comment">//获取最后一个元素：8</span></span><br><span class="line"><span class="comment">//java.lang.ArrayIndexOutOfBoundsException: 5</span></span><br></pre></td></tr></table></figure><h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h3><h4 id="声明数组-1"><a href="#声明数组-1" class="headerlink" title="声明数组"></a>声明数组</h4><p>在 Java 中二维数组被看作数组的数组，即二维数组为一个特殊的一维数组，其每个元素又是一个一维数组。Java 并不直接支持二维数组，但是允许定义数组元素是一维数组的一维数组，以达到同样的效果。声明二维数组的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[][];    <span class="comment">// 数据类型 数组名[][];</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type[][] arrayName;    <span class="comment">// 数据类型[][] 数组名;</span></span><br></pre></td></tr></table></figure><p>其中，type 表示二维数组的类型，arrayName 表示数组名称，第一个中括号表示行，第二个中括号表示列。</p><p>下面分别声明 int 类型和 char 类型的数组，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] age;</span><br><span class="line"><span class="keyword">char</span>[][] sex;</span><br></pre></td></tr></table></figure><h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p>二维数组可以初始化，和一维数组一样，可以通过 3 种方式来指定元素的初始值。这 3 种方式的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[][] arrayName = <span class="keyword">new</span> type[][]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,…,值 n&#125;;    <span class="comment">// 在定义时初始化</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> type[size1][size2];    <span class="comment">// 给定空间，在赋值</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> type[size][];    <span class="comment">// 数组第二维长度为空，可变化</span></span><br></pre></td></tr></table></figure><p>使用第一种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>使用第二种方式声明 int 类型的二维数组，然后初始化该二维数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>使用第三种方式声明 int 类型的二维数组，并且初始化数组。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure><h4 id="获取单个元素-1"><a href="#获取单个元素-1" class="headerlink" title="获取单个元素"></a>获取单个元素</h4><p>在上部分使用的前 2 种方式创建并初始化了一个二行二列的 int 类型数组 temp。当需要获取二维数组中元素的值时，也可以使用下标来表示。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>其中，arrayName 表示数组名称，i 表示数组的行数，j 表示数组的列数。例如，要获取第二行第二列元素的值，应该使用 temp[1][1]来表示。这是由于数组的下标起始值为 0，因此行和列的下标需要减 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123;&#123;<span class="number">10.0</span>,<span class="number">99</span>,<span class="number">99</span>&#125;,&#123;<span class="number">100</span>,<span class="number">98</span>,<span class="number">97</span>&#125;,&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">99.5</span>&#125;,&#123;<span class="number">99.5</span>,<span class="number">99</span>,<span class="number">98.5</span>&#125;&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;第二行第二列元素的值：&quot;</span>+class_score[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四行第一列元素的值：&quot;</span>+class_score[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二行第二列元素的值：<span class="number">98.0</span></span><br><span class="line">第四行第一列元素的值：<span class="number">99.5</span></span><br></pre></td></tr></table></figure><h4 id="获取全部元素"><a href="#获取全部元素" class="headerlink" title="获取全部元素"></a>获取全部元素</h4><p>在一维数组中直接使用数组的 length 属性获取数组元素的个数。而在二维数组中，直接使用 length 属性获取的是数组的行数，在指定的索引后加上 length（如 array[0].length）表示的是该行拥有多少个元素，即列数。</p><p>如果要获取二维数组中的全部元素，最简单、最常用的办法就是使用 for 语句。在一维数组全部输出时，我们使用一层 for 循环，而二维数组要想全部输出，则使用嵌套 for 循环（2 层 for 循环）。</p><p>使用 for 循环语句遍历 double 类型的 class_score 数组的元素，并输出每一行每一列元素的值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; class_score.length; i++) &#123; <span class="comment">// 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; class_score[i].length; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;class_score[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;]=&quot;</span> + class_score[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用嵌套 for 循环语句输出二维数组。在输出二维数组时，第一个 for 循环语句表示以行进行循环，第二个 for 循环语句表示以列进行循环，这样就实现了获取二维数组中每个元素的值的功能。</p><p>执行上述代码，输出结果如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class_score[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">98.0</span></span><br><span class="line">class_score[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">97.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">100.0</span></span><br><span class="line">class_score[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">99.5</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">99.5</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">99.0</span></span><br><span class="line">class_score[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">98.5</span></span><br></pre></td></tr></table></figure><h3 id="创建多维数组"><a href="#创建多维数组" class="headerlink" title="创建多维数组"></a>创建多维数组</h3><p>除了一维数组和二维数组外，Java中还支持更多维的数组，如三维数组、四维数组和五维数组等，它们都属于多维数组。经过前面一维，二维的练习后不难发现，想要提高数组的维数，只要在声明数组时将索引与中括号再加一组即可，所以三维数组的声明为 int score[][][]，而四维数组为 int score[][][][]，以此类推。</p><p>通常也将二维数组看作是多维数组。本文以三维数组为例来介绍多维数组。</p><p>三维数组有三个层次，可以将三维数组理解为一个一维数组，其内容的每个元素都是二维数组。依此类推，可以获取任意维数的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[][][] namelist = &#123; &#123; &#123; <span class="string">&quot;张阳&quot;</span>, <span class="string">&quot;李风&quot;</span>, <span class="string">&quot;陈飞&quot;</span> &#125;, &#123; <span class="string">&quot;乐乐&quot;</span>, <span class="string">&quot;飞飞&quot;</span>, <span class="string">&quot;小曼&quot;</span> &#125; &#125;,</span><br><span class="line">            &#123; &#123; <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Kimi&quot;</span> &#125;, &#123; <span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span> &#125; &#125;, &#123; &#123; <span class="string">&quot;徐璐璐&quot;</span>, <span class="string">&quot;陈海&quot;</span> &#125;, &#123; <span class="string">&quot;李丽丽&quot;</span>, <span class="string">&quot;陈海清&quot;</span> &#125; &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; namelist.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; namelist[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; namelist[i][j].length; k++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;namelist[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;][&quot;</span> + k + <span class="string">&quot;]=&quot;</span> + namelist[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=张阳</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=李风</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>]=陈飞</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=乐乐</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=飞飞</span><br><span class="line">namelist[<span class="number">0</span>][<span class="number">1</span>][<span class="number">2</span>]=小曼</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=Jack</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]=Kimi</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=Lucy</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=Lily</span><br><span class="line">namelist[<span class="number">1</span>][<span class="number">1</span>][<span class="number">2</span>]=Rose</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">0</span>][<span class="number">0</span>]=徐璐璐</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">0</span>][<span class="number">1</span>]=陈海</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">1</span>][<span class="number">0</span>]=李丽丽</span><br><span class="line">namelist[<span class="number">2</span>][<span class="number">1</span>][<span class="number">1</span>]=陈海清</span><br></pre></td></tr></table></figure><h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><h4 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h4><p>将一个数组(变长参数的语法糖实现就是数组)转变成一个List(确切的来说是ArrayList)，注意这个List是定长的，企图添加或者删除数据都会报错（java.lang.UnsupportedOperationException）.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//3,4,2,1,5,7,6</span></span><br></pre></td></tr></table></figure><p>但是，对于基础类型（比如byte,int,float等）千万不要想着这么实现（案例1-2，勿效仿）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br></pre></td></tr></table></figure><p>因为List list = Arrays.asList(a);会变成List&lt;int[]&gt; list = Arrays.asList(a);所以遍历需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] arr:list)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作就显得非常的烦琐。因为预想List是List<Integer>形式的，没想到是List&lt;int[]&gt;形式的。使用的时候要特别的注意一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a[] = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List list = Arrays.asList(a);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><strong>对数组进行排序</strong>。适合byte,char,double,float,int,long,short等基本类型，还有Object类型（实现了Comparable接口），如果提供了比较器Comparator也可以适用于泛型。</p><p>案例（基础类型，输出：[1, 1, 4, 4, 5, 6, 7, 9]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure><p>案例（String类型(Object)，实现了Comparable接口，输出：[s1, s2, s3, s4]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br></pre></td></tr></table></figure><p>案例 （自定义类型，实现了Comparable接口，输出：[jj:17, zzh:18, qq:19]）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person1 persons[] = <span class="keyword">new</span> Person1[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Person1(<span class="string">&quot;zzh&quot;</span>,<span class="number">18</span>),<span class="keyword">new</span> Person1(<span class="string">&quot;jj&quot;</span>,<span class="number">17</span>),<span class="keyword">new</span> Person1(<span class="string">&quot;qq&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(persons);</span><br><span class="line">System.out.println(Arrays.toString(persons));</span><br></pre></td></tr></table></figure><p>案例（泛型，如果类型没有实现Comparable接口，可以通过Comparator实现排序）[jj:17, zzh:18, qq:19]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person2 persons2[] = <span class="keyword">new</span> Person2[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Person2(<span class="string">&quot;zzh&quot;</span>,<span class="number">18</span>),<span class="keyword">new</span> Person2(<span class="string">&quot;jj&quot;</span>,<span class="number">17</span>),<span class="keyword">new</span> Person2(<span class="string">&quot;qq&quot;</span>,<span class="number">19</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(persons2,<span class="keyword">new</span> Comparator&lt;Person2&gt;()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person2 o1, Person2 o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 == <span class="keyword">null</span> || o2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(persons2));</span><br></pre></td></tr></table></figure><h4 id="binarySearch"><a href="#binarySearch" class="headerlink" title="binarySearch"></a>binarySearch</h4><p>通过二分查找法对已排序（譬如经过Arrays.sort排序，且按照升序进行排序。如果数组没有经过排序，那么检索结果未知）的数组进行查找。适合byte,char,double,float,int,long,short等基本类型，还有Object类型和泛型（参考sort那段）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line"><span class="keyword">int</span> ans = Arrays.binarySearch(str, <span class="string">&quot;s1&quot;</span>);</span><br><span class="line">System.out.println(ans);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s1, s2, s3, s4]</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="copyOf"><a href="#copyOf" class="headerlink" title="copyOf"></a>copyOf</h4><p>数组拷贝，底层采用System.arrayCopy（native方法）实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOf(str, str.length);</span><br><span class="line">System.out.println(Arrays.toString(str2));</span><br><span class="line">System.out.println(str.equals(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s2, s4, s1, s3]</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h4><p><strong>数组拷贝，指定一定的范围</strong>，譬如（public static T[] copyOfRange(T[] original, int from, int to)）。底层采用System.arrayCopy（native方法）实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOfRange(str,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(Arrays.toString(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s4, s1]</span></span><br></pre></td></tr></table></figure><h4 id="equals和deepEquals"><a href="#equals和deepEquals" class="headerlink" title="equals和deepEquals"></a>equals和deepEquals</h4><p><strong>equals</strong>：判断两个数组的每一个对应的元素是否相等（equals, 对于两个数组的元素o1和o2有o1==null ? o2==null : o1.equals(o2)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str1[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>,<span class="keyword">null</span>&#125;;</span><br><span class="line">String str2[] = Arrays.copyOf(str1, str1.length);</span><br><span class="line">System.out.println(Arrays.equals(str1, str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Arrays.equals(array1, array2)：</span></span><br><span class="line"><span class="comment">//检查两个数组是否包含相同数量的元素，并且两个数组中的所有相应元素对是否相等。</span></span><br><span class="line"><span class="comment">//array1.equals(array2)：</span></span><br><span class="line"><span class="comment">//将该对象与另一个对象进行比较，只有当两个对象的引用相同时才返回true `Object.equals()`</span></span><br></pre></td></tr></table></figure><p><strong>deepEquals</strong>：主要针对一个数组中的元素还是数组的情况，类似deepToString, deepHashCode如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a4[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a5[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a6[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a4,a5,a6&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.equals(a, b));</span><br><span class="line">System.out.println(Arrays.deepEquals(a, b));</span><br><span class="line"></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>给数组赋值。填充数组之用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str[] = &#123;<span class="string">&quot;s2&quot;</span>,<span class="string">&quot;s4&quot;</span>,<span class="string">&quot;s1&quot;</span>,<span class="string">&quot;s3&quot;</span>,<span class="keyword">null</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line">Arrays.fill(str, <span class="string">&quot;s5&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(str));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[s2, s4, s1, s3, null]</span></span><br><span class="line"><span class="comment">//[s5, s5, s5, s5, s5]</span></span><br></pre></td></tr></table></figure><h4 id="toString和deepToString"><a href="#toString和deepToString" class="headerlink" title="toString和deepToString"></a>toString和deepToString</h4><p><strong>toString</strong>：对于一个数组int a[] = new int[]{1,9,5,4,6,4,7,1};如果按照System.out.println(a);打印企图可以打印出[1,9,5,4,6,4,7,1]，实际上只会打印出[I@3e2de41d这种。在打印数组的时候需要写成Arrays.toString(a)的形式。可参考sort的详解。<br>        <strong>deepToString</strong>：当数组中又包含数组，那么就不能单存的利用Arrays.toString()了，请看例子。<br>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">System.out.println(Arrays.deepToString(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//[[I@1b6b7f83, [I@2e807f85, [I@76340c9c]</span></span><br><span class="line"><span class="comment">//[[1, 2, 3], [1, 3, 3], [4, 3, 2, 1]]</span></span><br></pre></td></tr></table></figure><h4 id="hashCode和deepHashCode"><a href="#hashCode和deepHashCode" class="headerlink" title="hashCode和deepHashCode"></a>hashCode和deepHashCode</h4><p><strong>hashCode</strong>：计算一个数组的hashCode.对于一个数组Object[], hashCode方法返回的值取决于：数组中每个元素的元素oi.hashCode()的值初级计算result = 31 * result + (oi== null ? 0 : oi.hashCode());<br>        <strong>deepHashCode</strong>: 对于一个数组Object[], deepHashCode取决于：数组中每个元素oi，如果oi还是一个数组，那么就继续深入的去获取hashCode，这段比较绕，来个例子比较形象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a3[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a [] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;a1,a2,a3&#125;;</span><br><span class="line">System.out.println(Arrays.hashCode(a));</span><br><span class="line">System.out.println(Arrays.deepHashCode(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1683374023</span></span><br><span class="line"><span class="comment">//31646847</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构简介&quot;&gt;&lt;a href=&quot;#数据结构简介&quot; class=&quot;headerlink&quot; title=&quot;数据结构简介&quot;&gt;&lt;/a&gt;数据结构简介&lt;/h2&gt;&lt;p&gt;数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈BFS和DFS</title>
    <link href="https://leslieaibin.github.io/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/BFS%E5%92%8CDFS%E8%AF%A6%E8%A7%A3/"/>
    <id>https://leslieaibin.github.io/2020/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/BFS%E5%92%8CDFS%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-11-06T16:15:42.000Z</published>
    <updated>2020-11-07T13:39:01.874Z</updated>
    
    <content type="html"><![CDATA[<p>深度优先遍历（Depth First Search, 简称DFS）与广度优先遍历（Breath First Search，简称BFS）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫）、搜索引擎、爬虫等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89.gif" alt="DFS 与 BFS 对比"></p><h2 id="DFS-Deep-First-Search"><a href="#DFS-Deep-First-Search" class="headerlink" title="DFS (Deep First Search)"></a>DFS (Deep First Search)</h2><p>DFS：从当前节点开始，先标记当前节点，再寻找与当前节点相邻，且未标记过的节点（ 这是一个递归思想的DFS）</p><ul><li>当前节点不存在下一个节点，则返回前一个节点进行DFS</li><li>当前节点存在下一个节点，则从下一个节点进行DFS</li></ul><p><strong>DFS 遍历使用递归遍历：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是比较两段代码的话，最直观的感受就是：DFS 遍历的代码比 BFS 简洁太多了！这是因为递归的方式隐含地使用了系统的 栈，我们不需要自己维护一个数据结构。如果只是简单地将二叉树遍历一遍，那么 DFS 显然是更方便的选择。</p><h3 id="网格结构中的-DFS"><a href="#网格结构中的-DFS" class="headerlink" title="网格结构中的 DFS"></a>网格结构中的 DFS</h3><p> <strong>网格问题的基本概念</strong></p><p>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p><p>网格问题是由 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p><p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204300931.png" alt="image-20201107204300931"></p><p>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p><p> <strong>DFS 的基本结构</strong></p><p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的<strong>图</strong>结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travese</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问两个相邻节点：左子节点，右子节点</span></span><br><span class="line">    travese(root.left);</span><br><span class="line">    travese(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，二叉树的DFS有两个要素：【<strong>访问相邻节点</strong>】 和 【<strong>判断base case</strong>】。</p><p>第一个要素是<strong>访问相邻的节点</strong>。二叉树的相邻节点非常简单，只有左子树和右子树。二叉树本身就是一个递归定义的结构：一颗二叉树，他的左子树和右子树也是一颗二叉树。那么我们的DFS遍历只需要调用左子树和右子树即可。</p><p>第二个要素就是判断<strong>base case</strong>。一般来说，二叉树遍历的base case是 root == null。这样一个条件判断其实有两个含义:</p><ul><li>表示root指向指向的子树为空，不需要再往下遍历了。</li><li>在root == null的时候及时返回，可以让后面的root.left 和root.right操作不会出现空指针异常</li></ul><p>对于网格上的DFS，可以参考二叉树的DFS，写出网格的DFS的两个要素：</p><ul><li>相邻节点对于格子 <code>(r, c)</code> 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 <code>(r-1, c)</code>、<code>(r+1, c)</code>、<code>(r, c-1)</code>、<code>(r, c+1)</code>。换句话说，网格结构是「四叉」的。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204116039.png" alt="image-20201107204116039"></p><ul><li>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、<code>grid[r][c]</code> 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201107204315074.png" alt="image-20201107204315074"></p><h3 id="DFS遍历网格的框架代码"><a href="#DFS遍历网格的框架代码" class="headerlink" title="DFS遍历网格的框架代码"></a>DFS遍历网格的框架代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免重复遍历将已经遍历的格子设置为2</span></span><br><span class="line"><span class="comment">// 0 —— 海洋格子</span></span><br><span class="line"><span class="comment">// 1 —— 陆地格子（未遍历过）</span></span><br><span class="line"><span class="comment">// 2 —— 陆地格子（已遍历过）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][],grid <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">//将已经遍历过得格子 变为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//访问上、下、左、右相邻节点、</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断坐标（r,c）是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">         &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿问题解决"><a href="#岛屿问题解决" class="headerlink" title="岛屿问题解决"></a>岛屿问题解决</h3><h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h4><p>这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = area(grid, r , c);</span><br><span class="line">            res = Math.max(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">inArea</span><span class="params">(grid, r ,c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] == <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        + are(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + are(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + are(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + are(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt;= grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h4><p>实话说，这道题用 DFS 来解并不是最优的方法。对于岛屿，直接用数学的方法求周长会更容易。不过这道题是一个很好的理解 DFS 遍历过程的例题，不信你跟着我往下看。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/640" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimter</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; grid.length; r++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//题目限制只有一个岛屿，只计算一个即可</span></span><br><span class="line">                <span class="keyword">return</span> dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//函数因为（坐标（r,c)超出网格范围，对应一条黄色的边</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数因为当前格式是海洋格子返回，对应一条蓝色的边</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS-Breath-First-Search"><a href="#BFS-Breath-First-Search" class="headerlink" title="BFS(Breath First Search)"></a>BFS(Breath First Search)</h2><p>BFS: 广度优先算法便如其名字，他是以广度为优先的，一层一层搜索下去，就像病毒感染，扩散性的传播下去。</p><ul><li>比如每遍历start周围的一个“1”节点的时候，就把跟它相关联的“2”节点保存到队列中</li><li>然后依次访问队列内容，并对每个队列元素重复上个步骤</li><li>由此重复下去，直到队列为空或者搜索到终点</li></ul><p><strong>BFS 遍历使用队列数据结构：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-的应用一：层序遍历"><a href="#BFS-的应用一：层序遍历" class="headerlink" title="BFS 的应用一：层序遍历"></a>BFS 的应用一：层序遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">[102. 二叉树的层序遍历]</a></p><p>什么是层序遍历呢？简单来说，层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/ce41cf1cabfa7a56387f63d927c8819fe1479ecf6f193a2a1b47964f5a8d1c8e.jpg" alt="二叉树的层序遍历"></p><p>乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg" alt="BFS 遍历与层序遍历的输出结果不同"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif" alt="BFS 遍历的过程（动图）"></p><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p><p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 nn（也就是这一层的结点数量），然后一口气处理完这一层的 nn 个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="comment">//变量i无实际意义只是为了循环n次</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif" alt="img"></p><p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p><p>最终我们得到的题解代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">       <span class="keyword">int</span> n = queue.size();</span><br><span class="line">       List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           level.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.add(level);</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-的应用二：最短路径"><a href="#BFS-的应用二：最短路径" class="headerlink" title="BFS 的应用二：最短路径"></a>BFS 的应用二：最短路径</h3><p>在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径，其中哪条路最近呢？这一类问题称为最短路径问题。最短路径问题也是 BFS 的典型应用，而且其方法与层序遍历关系密切。</p><p>在二叉树中，BFS 可以实现一层一层的遍历。在图中同样如此。从源点出发，BFS 首先遍历到第一层结点，到源点的距离为 1，然后遍历到第二层结点，到源点的距离为 2…… 可以看到，用 BFS 的话，距离源点更近的点会先被遍历到，这样就能找到到某个点的最短路径了。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/01a3617511b1070216582ae59136888072116ccba360ab7c2aa60fc273351b85.jpg" alt="层序遍历与最短路径"></p><p>要解最短路径问题，我们首先要写出层序遍历的代码，仿照上面的二叉树层序遍历代码，类似地可以写出网格层序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网格结构的层序遍历</span></span><br><span class="line"><span class="comment">// 从格子 (i, j) 开始遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span>[] node = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r = node[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = node[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r-<span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r+<span class="number">1</span> &lt; N &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r+<span class="number">1</span>][c] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r][c-<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c+<span class="number">1</span> &lt; N &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                grid[r][c+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的层序遍历代码有几个注意点：</p><p>队列中的元素类型是 int[] 数组，每个数组的长度为 2，包含格子的行坐标和列坐标。<br>为了避免重复遍历，这里使用到了和 DFS 遍历一样的技巧：把已遍历的格子标记为 2。注意：我们在将格子放入队列之前就将其标记为 2。想一想，这是为什么？<br>在将格子放入队列之前就检查其坐标是否在网格范围内，避免将「不存在」的格子放入队列。<br>这段网格遍历代码还有一些可以优化的地方。由于一个格子有四个相邻的格子，代码中判断了四遍格子坐标的合法性，代码稍微有点啰嗦。我们可以用一个 moves 数组存储相邻格子的四个方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">    &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后把四个 if 判断变成一个循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[][] move : moves) &#123;</span><br><span class="line">    <span class="keyword">int</span> r2 = r + move[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c2 = c + move[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == <span class="number">0</span>) &#123;</span><br><span class="line">        grid[r2][c2] = <span class="number">2</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r2, c2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好了层序遍历的代码，接下来我们看看如何来解决本题中的最短路径问题。</p><p>这道题要找的是距离陆地最远的海洋格子。假设网格中只有一个陆地格子，我们可以从这个陆地格子出发做层序遍历，直到所有格子都遍历完。最终遍历了几层，海洋格子的最远距离就是几。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/8e108e43731bd61a225f79cde11783ae0df17f171974896dc631bbdcda637aa9.gif" alt="从单个陆地格子出发的距离（动图）"></p><p>那么有多个陆地格子的时候怎么办呢？一种方法是将每个陆地格子都作为起点做一次层序遍历，但是这样的时间开销太大。</p><p>BFS 完全可以以多个格子同时作为起点。我们可以把所有的陆地格子同时放入初始队列，然后开始层序遍历，这样遍历的效果如下图所示：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/0a7e2f150e95617c19ff7eddb9f2a8d795c23d02b8c1e51a1ff45920d493047b.gif" alt="从多个陆地格子出发的距离"></p><p>这种遍历方法实际上叫做「多源 BFS」。多源 BFS 的定义不是今天讨论的重点，你只需要记住多源 BFS 很方便，只需要把多个源点同时放入初始队列即可。</p><p>需要注意的是，虽然上面的图示用 1、2、3、4 表示层序遍历的层数，但是在代码中，我们不需要给每个遍历到的格子标记层数，只需要用一个 distance 变量记录当前的遍历的层数（也就是到陆地格子的距离）即可。</p><p>最终，我们得到的题解代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = grid.length;</span><br><span class="line"></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将所有的陆地格子加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果地图上只有陆地或者海洋，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty() || queue.size() == N * N) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">        &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> distance = -<span class="number">1</span>; <span class="comment">// 记录当前遍历的层数（距离）</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        distance++;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="keyword">int</span>[] node = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r = node[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = node[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] move : moves) &#123;</span><br><span class="line">                <span class="keyword">int</span> r2 = r + move[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> c2 = c + move[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (inArea(grid, r2, c2) &amp;&amp; grid[r2][c2] == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[r2][c2] = <span class="number">2</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r2, c2&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深度优先遍历（Depth First Search, 简称DFS）与广度优先遍历（Breath First Search，简称BFS）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫）、搜索引擎、爬虫等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://te</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="BFS" scheme="https://leslieaibin.github.io/tags/BFS/"/>
    
    <category term="DFS" scheme="https://leslieaibin.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前、中、后序遍历（递归和循环）</title>
    <link href="https://leslieaibin.github.io/2020/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF%EF%BC%89/</id>
    <published>2020-11-01T16:15:42.000Z</published>
    <updated>2020-11-02T15:43:30.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树节点结构"><a href="#二叉树节点结构" class="headerlink" title="二叉树节点结构"></a>二叉树节点结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p><strong>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</strong>  （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>前序遍历：1 2 4 6 7 8 3 5</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></p><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//一共到达三次root的节点</span></span><br><span class="line">        preorderTraversal(root.left);</span><br><span class="line">        <span class="comment">//返回root</span></span><br><span class="line">        preorderTraversal(root.right);</span><br><span class="line">        <span class="comment">//返回root</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-c0aa74a23a4d357d.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val); <span class="comment">//先将节点加入结果队列</span></span><br><span class="line">                stack.push(root);  <span class="comment">//不断将该节点左子树入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">//栈顶节点出栈</span></span><br><span class="line">            root = root.right; <span class="comment">//转向该节点右子树的左子树（下一个循环）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p><strong>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</strong> （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>中序遍历 ：4 7 6 8 2 1 3 5</strong></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></p><h2 id="递归算法-1"><a href="#递归算法-1" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h2><p><img src="https://upload-images.jianshu.io/upload_images/2405011-c0aa74a23a4d357d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);  <span class="comment">//不断将该节点左子树入栈</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">//栈顶节点出栈</span></span><br><span class="line">            res.add(root.val); <span class="comment">//将节点加入结果队列</span></span><br><span class="line">            root = root.right; <span class="comment">//转向该节点右子树的左子树（下一个循环）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h1><p><strong>后序遍历： 左子树 —&gt; 右子树 —&gt;根结点</strong>  （根节点在 前中后 那个位置 就叫什么遍历）</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/2405011-5f5b0b136713f744.jpg" alt="img"></p><p><strong>后序遍历：7 8 6 4 2 5 3 1</strong> </p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></p><h2 id="递归算法-2"><a href="#递归算法-2" class="headerlink" title="递归算法"></a>递归算法</h2><p><strong>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</strong>（根节点在 前中后 那个位置 就叫什么遍历）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>; <span class="comment">//pre节点用于记录前一次访问的节点</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root); <span class="comment">//不断将左节点压栈</span></span><br><span class="line">                root = root.left; </span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="keyword">null</span> || root.right==pre)&#123; <span class="comment">//若右节点为空 或右节点访问过</span></span><br><span class="line">                res.add(root.val); <span class="comment">//此时可以访问根结点啦</span></span><br><span class="line">                pre = root;</span><br><span class="line">                stack.pop();</span><br><span class="line">                root = <span class="keyword">null</span>; <span class="comment">//此时下一轮循环不要将左子树压栈，直接判断栈顶元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = root.right; <span class="comment">//先不出栈 把它右节点入栈</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="comment">//修改前序遍历代码中，节点写入结果链表的代码：将插入队尾修改为插入队首</span></span><br><span class="line"><span class="comment">//修改前序遍历代码中，每次先查看左节点再查看右节点的逻辑：变为先查看右节点再查看左节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList res = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.addFirst(root.val); <span class="comment">//插入队首</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.right; <span class="comment">//先右后左</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树节点结构&quot;&gt;&lt;a href=&quot;#二叉树节点结构&quot; class=&quot;headerlink&quot; title=&quot;二叉树节点结构&quot;&gt;&lt;/a&gt;二叉树节点结构&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="树" scheme="https://leslieaibin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    
    
    <category term="二叉树" scheme="https://leslieaibin.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Win10连接linux服务器的工具</title>
    <link href="https://leslieaibin.github.io/2020/10/31/%E5%B7%A5%E5%85%B7/win10%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://leslieaibin.github.io/2020/10/31/%E5%B7%A5%E5%85%B7/win10%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2020-10-31T15:40:42.000Z</published>
    <updated>2020-10-31T15:44:03.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用的远程连接Linux工具"><a href="#常用的远程连接Linux工具" class="headerlink" title="常用的远程连接Linux工具"></a>常用的远程连接Linux工具</h2><p>常用的远程连接Linux工具有：Vscode、XShell、FinallShell等。下面重点介绍该三种工具：</p><h2 id="1-VsCode的Remote插件"><a href="#1-VsCode的Remote插件" class="headerlink" title="1 VsCode的Remote插件"></a>1 VsCode的Remote插件</h2><p>Vscode是一款开源的跨平台编辑器。默认情况下，vscode使用的语言为英文(us)</p><h3 id="1-1-下载安装"><a href="#1-1-下载安装" class="headerlink" title="1.1 下载安装"></a>1.1 下载安装</h3><p>官方下载地址：<a href="https://links.jianshu.com/go?to=https://code.visualstudio.com/%23alt-downloads">https://code.visualstudio.com/#alt-downloads</a></p><p>选择自己的系统版本，安装时一直下一步即可，安装完成后直接运行code.exe</p><h3 id="1-2-修改vscode为中文环境"><a href="#1-2-修改vscode为中文环境" class="headerlink" title="1.2 修改vscode为中文环境"></a>1.2 修改vscode为中文环境</h3><ul><li><p>使用快捷键【Ctrl+Shift+X】，在搜索框中输入“chinese”，选择安装   中文（简体） install；</p></li><li><p> 再次使用快捷键【Ctrl+Shift+P】，在搜索框中输入“configure display language”，选择 zh-CN ，确认重启即可。</p></li></ul><h3 id="1-3-修改主题颜色"><a href="#1-3-修改主题颜色" class="headerlink" title="1.3 修改主题颜色"></a>1.3 修改主题颜色</h3><p>使用快捷键【Ctrl+K 】【Ctrl+T 】弹出选择框，选择自己喜欢的主题</p><h3 id="1-4-安装Remote-SSH"><a href="#1-4-安装Remote-SSH" class="headerlink" title="1.4 安装Remote-SSH"></a>1.4 安装Remote-SSH</h3><p>直接打开vscode中的插件搜索SSH找到Remote-SSH直接安装即可。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130400.png" alt="image-20201016130400637"></p><h3 id="1-5-配置Remote-SSH"><a href="#1-5-配置Remote-SSH" class="headerlink" title="1.5 配置Remote-SSH"></a>1.5 配置Remote-SSH</h3><p>​        安装完成后会出现一个远程资源管理器图标，其中可以选择SSH Targets。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130451.webp" alt="img"></p><p>然后点击配置：</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016130523.webp" alt="img"></p><p>此时打开一个config配置文件，让你输入HostName和User：</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016131335.png" alt="image-20201016131326006"></p><h3 id="1-6-连接远程服务器"><a href="#1-6-连接远程服务器" class="headerlink" title="1.6 连接远程服务器"></a>1.6 连接远程服务器</h3><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132016.png" alt="image-20201016132016082"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132050.png" alt="image-20201016132050898"></p><p><strong>输入密码为test</strong></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132432.png" alt="image-20201016132252488"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201016132440.png" alt="image-20201016132323464"></p><p>打开文件夹 命令行</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016132600856.png" alt="image-20201016132600856"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016132650554.png" alt="image-20201016132650554"></p><h3 id="1-7安装插件"><a href="#1-7安装插件" class="headerlink" title="1.7安装插件"></a>1.7安装插件</h3><p>​        本机中的插件是无法在远程服务器中使用的，这就需要我们从新安装插件，这个也比较简单，在连接上远程服务器后在vscdoe的插件侧边栏中就可以看到一个专为远程服务器显示 安装插件的区域，此后的操作与本地安装基本一样。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016135335446.png" alt="image-20201016135335446"></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016135433543.png" alt="image-20201016135433543"></p><h2 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h2><p>​        Xshell：是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。软件强大，在windows环境下使用用户多，非常重要的一点是：对个人、教育用户是免费的。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101034.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p>​        它的使用方式略有区别，第一次双击软件图标，打开后，需要先点击软件界面左上角的文件，点击新建，然后才能出来主机信息配置界面。输入主机别名、ip地址和端口，然后点击确定。就会弹到服务器列表，在列表中选择你刚才添加的服务器名称，然后点击连接。就开始自动连接对应的服务器。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101140.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101124.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101124.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p>​        输入用户名，点击确定，再输入密码。认证成功后就进入到了服务器的shell界面。显示你上一次的登录时间以及IP地址。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101212.png" alt="Windows下连接Linux的ssh工具有哪些"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016101220.png" alt="Windows下连接Linux的ssh工具有哪些"></p><h2 id="FinallShell"><a href="#FinallShell" class="headerlink" title="FinallShell"></a>FinallShell</h2><p>​        FinalShell一款很好用的ssh链接工具，标准免费版本就可以基本满足一般用户的需求，和xshell工具相比，虽然没有那么多绚丽多彩的功能，但是小巧实用，而且关键是免费。</p><p>​        xshell虽然也是免费，但是过了评估试用期还需要重新下载安装。</p><p>​        先来看一下FinalShell的链接界面。</p><p>​        界面简洁，但是基本上可以满足普通用户的基本需求了，因为在左侧可以一目了然服务器的基本情况。</p><p>​        磁盘使用情况，内存，cpu负载情况等等。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102020.png" alt="如何通过FinalShell连接linux服务器"></p><p>​        点击上方类似文件夹的图标，点开后，下方是我已经链接过的机器列表，如果是第一次使用，这个列表是空的。连接列表里面的机器，直接双击即可连接。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102103.png" alt="如何通过FinalShell连接linux服务器"></p><p>​            然后，点击第一个+号，在弹出的下拉列表处，选择ssh连接。这里可以看到有一个远程桌面链接（windows），FinalShell还是比较实用的。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102251.png" alt="如何通过FinalShell连接linux服务器"></p><p>​        在弹出的对话框中，写入要连接的服务器的ip地址和端口。名称可以随意填写，方便自己记忆。</p><p>可以直接在这个窗口填入用户名和密码。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102452.png" alt="如何通过FinalShell连接linux服务器"></p><p>​            当连接机器时，会提示输入用户名和密码的。也可以勾选保存，这样下次连接时就不用再次输入用户名和密码了。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102545.png" alt="如何通过FinalShell连接linux服务器"></p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102551.png"></p><p>​        如果是要连接已经连接的机器，打开列表框，双击某个记录就可以了。红框标出的就是我所有连接过的机器。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/img/20201016102621.png" alt="如何通过FinalShell连接linux服务器"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常用的远程连接Linux工具&quot;&gt;&lt;a href=&quot;#常用的远程连接Linux工具&quot; class=&quot;headerlink&quot; title=&quot;常用的远程连接Linux工具&quot;&gt;&lt;/a&gt;常用的远程连接Linux工具&lt;/h2&gt;&lt;p&gt;常用的远程连接Linux工具有：Vscode</summary>
      
    
    
    
    <category term="ssh" scheme="https://leslieaibin.github.io/categories/ssh/"/>
    
    
    <category term="ssh" scheme="https://leslieaibin.github.io/tags/ssh/"/>
    
    <category term="linux" scheme="https://leslieaibin.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-（6-11章）</title>
    <link href="https://leslieaibin.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%886-11%E7%AB%A0%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%886-11%E7%AB%A0%EF%BC%89/</id>
    <published>2020-10-29T16:15:42.000Z</published>
    <updated>2020-10-30T08:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6. HTTP首部"></a>6. HTTP首部</h1><h2 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h2><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf41c1eadc" alt="httpstructure"></p><p>上图是HTTP<strong>请求报文</strong>的结构</p><p>HTTP请求报文由方法、URI、HTTP版本、HTTP首部字段等组成。</p><p>请求报文首部信息实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>; WOW64; rv:<span class="number">13.0</span>) Gecko/<span class="number">2010010</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*; q=0</span></span><br><span class="line"><span class="comment">Accept-Language: ja,en-us;q=0.7,en;q=0.3</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate</span></span><br><span class="line"><span class="comment">DNT: 1</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT</span></span><br><span class="line"><span class="comment">If-None-Match: &quot;45bae1-16a-46d776ac&quot;</span></span><br><span class="line"><span class="comment">Cache-Control: max-age=0</span></span><br></pre></td></tr></table></figure><p>HTTP响应报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段三部分组成。</p><p>下面是HTTP<strong>响应报文</strong>结构：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf4203c6ba" alt="httpresstructure"></p><p>响应报文的首部实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line">Date: Thu, <span class="number">07</span> Jun <span class="number">2012</span> <span class="number">07</span>:<span class="number">21</span>:<span class="number">36</span> GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Connection: close</span><br><span class="line">Etag: <span class="string">&quot;45bae1-16a-46d776ac&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h2><h3 id="6-2-1-HTTP首部字段结构"><a href="#6-2-1-HTTP首部字段结构" class="headerlink" title="6.2.1 HTTP首部字段结构"></a>6.2.1 HTTP首部字段结构</h3><p>HTTP首部字段传递重要信息，其结构基本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首部字段名： 字段值</span><br><span class="line">例如：</span><br><span class="line">Content-Type: text/html</span><br><span class="line">另外，有些首部字段可以有多个值，如下：</span><br><span class="line">    Keep-Alive:timeout=<span class="number">15</span>,max=<span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="6-2-2-HTTP首部字段类型"><a href="#6-2-2-HTTP首部字段类型" class="headerlink" title="6.2.2 HTTP首部字段类型"></a>6.2.2 HTTP首部字段类型</h3><p>HTTP首部字段根据实际用途被分为四种类型：</p><ul><li><strong>通用首部字段</strong>  请求报文和响应报文都会使用到的首部字段</li><li><strong>请求首部字段</strong>  从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级的信息。</li><li><strong>响应首部字段</strong>  从服务端向客户端发送响应报文时的首部。补充了响应的附加内容，也会要求客户端附加的内容信息。</li><li><strong>实体首部字段</strong>  针对请求报文和响应报文的实体部分 使用的首部。补充了资源内容更新时间等与实体内容相关的信息。</li></ul><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">逐跳首部、连接的管理</td></tr><tr><td align="center">Data</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末尾的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他 协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Authorization</td><td align="center">Web信息认证</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在的服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与If-Match相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体Byte的范围请求</td></tr><tr><td align="center">If-Unmodifield-Since</td><td align="center">比较实体标记（与If-Match相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中URL的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码优先级</td></tr><tr><td align="center">Use-Agent</td><td align="center">HTTP客户端程序的信息</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配资源</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的HTTP方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小（字节）</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的URI</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改时间</td></tr></tbody></table><p>以上就是最常用的一些 HTTP 首部字段。</p><p>其他还有一些非 HTTP/1.1 规范的首部字段也用的比较多，比如 Set-Cookie、Cookie 等等。</p><p>此外，HTTP 首部根据将定义成缓存代理和非缓存代理的行为，分成了两种类型——端到端首部（End-to-End Header）和逐跳首部（Hop-by-Hop Header）。</p><p>端到端首部类的首部字段会转发给请求/响应的最终接受对象，且必须保存在由缓存生成的响应中，另外规定它必须转发；</p><p>逐跳首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 之后的版本中使用逐跳首部需要提供 Connection 首部字段。</p><p>下面这些字段都属于逐跳首部字段：</p><ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><p>所有其余字段皆为端到端首部字段。</p><p>下面开始详细介绍各个首部字段。</p><h3 id="6-2-3-HTTP-1-1-通用首部字段"><a href="#6-2-3-HTTP-1-1-通用首部字段" class="headerlink" title="6.2.3  HTTP/1.1 通用首部字段"></a>6.2.3  HTTP/1.1 通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段Cache-Control,就能操作缓存的工作机制。</p><p>Cache-Control 的指令参数是可选的，多个指令之间通过逗号分开。该首部字段在请求和响应时都可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:<span class="keyword">private</span>, max-age = <span class="number">0</span> , no-cache</span><br></pre></td></tr></table></figure><p><strong>Cache-Control 可用指令如下：</strong></p><p><strong>请求指令</strong></p><table><thead><tr><th align="center">指令</th><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">no-cache</td><td align="center">无</td><td align="center">强制向源服务器再次验证</td></tr><tr><td align="center">no-store</td><td align="center">无</td><td align="center">不缓存请求或响应的任何内容</td></tr><tr><td align="center">max-age=[秒]</td><td align="center">必需</td><td align="center">响应的最大 age 值</td></tr><tr><td align="center">max-stale(=[秒])</td><td align="center">可省略</td><td align="center">接受已过期的响应</td></tr><tr><td align="center">min-fresh=[秒]</td><td align="center">必需</td><td align="center">期望在指定的时间内的响应仍然有效</td></tr><tr><td align="center">no-transform</td><td align="center">无</td><td align="center">代理不可更改媒体类型</td></tr><tr><td align="center">only-if-cached</td><td align="center">无</td><td align="center">从缓存获得资源</td></tr><tr><td align="center">cache-extension</td><td align="center">-</td><td align="center">新指令标记（token）</td></tr></tbody></table><p><strong>响应指令</strong></p><table><thead><tr><th align="center">指令</th><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">无</td><td align="center">可向任意方提供响应的缓存</td></tr><tr><td align="center">private</td><td align="center">可省略</td><td align="center">仅向特定用户返回响应</td></tr><tr><td align="center">no-cache</td><td align="center">可省略</td><td align="center">缓存前必须确认其有效性</td></tr><tr><td align="center">no-store</td><td align="center">无</td><td align="center">不缓存请求或响应的任何内容</td></tr><tr><td align="center">no-transform</td><td align="center">无</td><td align="center">代理不可更改媒体类型</td></tr><tr><td align="center">must-revalidate</td><td align="center">无</td><td align="center">可缓存但必须再向源服务器进行确认</td></tr><tr><td align="center">proxy-revalidate</td><td align="center">无</td><td align="center">要求中间缓存服务器对缓存的响应有效性再进行确认</td></tr><tr><td align="center">max-age=[秒]</td><td align="center">必需</td><td align="center">响应的最大 age 值</td></tr><tr><td align="center">s-maxage=[秒]</td><td align="center">必需</td><td align="center">公共缓存服务器响应的最大 age 值</td></tr><tr><td align="center">cache-extension</td><td align="center">-</td><td align="center">新指令标记（token）</td></tr></tbody></table><p>规定是否缓存的指令：</p><p>**public指令 **  当指定使用public指令时 ，则明确表明其他用户也可以利用缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">public</span></span><br></pre></td></tr></table></figure><p>当指定使用public指令时，则明确表明其他用户也可以利用缓存。</p><p><strong>private指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">private</span></span><br></pre></td></tr></table></figure><p>当指定private指令后响应只以特定的用户作为对象，当该对象向服务器发起请求时，服务器会返回缓存的资源</p><p><strong>no-cache指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>该指令的目的是为了防止使用过期的缓存资源</p><p>如果客户端发送的请求包含no-cache指令，则表示客户端将不会接受过期的缓存过得响应。于是，中间的代理服务器必须把请求转发给原服务器。</p><p>如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存，源服务器以后也将不在对缓存服务器请求中提出的资源有效性进行确认，且进制其对资源响应进行缓存操作。</p><p>控制可执行缓存对象的指令</p><p><strong>no-store指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure><p>当使用no-store指令时，按时请求或响应中包含机密信息。</p><p>因此该指令规定缓存不能在本地存储请求或响应的任一部分。</p><p><strong>s-maxage 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: s-maxage&#x3D;604800（单位：秒）</span><br></pre></td></tr></table></figure><p>该指令功能和max-age相同，不同点是s-maxage指令只适合于供多位用户使用的公共缓存服务器。当使用smax-age 指令之后，直接会忽略 Expires 字段及 max-age 指令的处理。</p><p><strong>max-age 指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=<span class="number">604800</span>（单位：秒）</span><br></pre></td></tr></table></figure><p><strong>当客户端发送的请求中包含 max-age 指令时</strong>，如果判定缓存资源的缓存时间数值比指定的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器（相当于是 no-cache）。</p><p><strong>当服务器返回的响应中包含 max-age 指令时</strong>，缓存服务器将不对资源的有效性再做确认，而 max-age 数值代表的是资源保存为缓存的最长时间。</p><p>应用 HTTP/1.1 版本的缓存的服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而应用 HTTP/1.0 版本的服务器则恰恰相反。</p><p><strong>min-fresh 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: min-fresh&#x3D;60（单位：秒）</span><br></pre></td></tr></table></figure><p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源（即指定时间过后仍然是未过期的资源）。</p><p><strong>max-stale 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-stale&#x3D;3600（单位：秒） </span><br></pre></td></tr></table></figure><p>使用 max-stale 表示接受过期的缓存资源，后面的值表示具体过期的时长，表示响应不能已经过时超过该给定的时间。如果不传递数值，则表示无论经过多久，客户端都能够接受。</p><p><strong>only-if-cached 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: only-if-cached</span><br></pre></td></tr></table></figure><p>使用该指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。即只接受已缓存的资源，并且不用向源服务器检查资源的有效性。若代理服务器本地缓存无响应，则返回 504 Gateway Timeout。</p><p><strong>must-revalidate 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure><p>使用该指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p><p>使用 must-revalidate 指令会忽略 max-stale 指令。</p><p><strong>proxy-revalidate 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: proxy-revalidate</span><br></pre></td></tr></table></figure><p>该指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再验证资源的有效性。</p><p><strong>no-transform 指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure><p>该指令规定无论在请求还是响应中缓存都不能改变实体的媒体类型。</p><p>这样可以防止缓存或者代理压缩图片等类似操作。</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>这个首部字段有一下两个作用：</p><ul><li>控制不再转发给代理的首部自担</li><li>管理持久连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: 不再转发的首部字段名</span><br></pre></td></tr></table></figure><p>这条语句就表示指定的首部字段不再转发到下一级服务器（可能是代理）。</p><p><a href="https://github.com/zhongdeming428/MyMemorandum/blob/master/%E5%9B%BE%E8%A7%A3HTTP/pics/httpconn.png"><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf42172df1" alt="httpconn"></a></p><p>除了上面的功能以外，该首部还可以管理持久连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>该指令明确指定断开当前连接。（HTTP/1.1 的所有连接默认都是长连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>以上指令明确指定当前连接为长连接。（适用于 HTTP/1.1 版本之前）</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>该字段表明 HTTP 报文创建的日期和时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure><h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><p>该字段是 HTTP/1.1 版本的遗留字段，为了向后兼容而定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>功能一致。</p><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p>该字段事先说明在报文主体后记录了哪些首部字段，可用于 HTTP/1.1 版本分块传输编码时。</p><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>该首部字段指定了在传输报文主体时所使用的编码方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>该首部字段用于检测 HTTP 协议及其他协议是否可以升级为更高版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>该首部字段是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p><p>报文经过代理或者网关时，会在首部字段 Via 中附加该服务器的信息，然后再进行转发。而且这个字段不仅可以用于追踪报文的转发，还可以避免请求回环发生。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bbf499ebbc8" alt="httpvia"></p><p>各个代理服务器会向 Via 添加自身服务器的信息。</p><p>其中 <code>1.0</code> 以及 <code>1.1</code> 的开头表示服务器的 HTTP 协议版本。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>该首部自担通常告诉用户一些缓存相关的问题的警告，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</span><br></pre></td></tr></table></figure><h3 id="6-2-4-HTTP-1-1-请求首部字段"><a href="#6-2-4-HTTP-1-1-请求首部字段" class="headerlink" title="6.2.4 HTTP/1.1 请求首部字段"></a>6.2.4 HTTP/1.1 请求首部字段</h3><p>请求首部字段是从客户端发往服务器端时请求报文中所使用的字段。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,*<span class="comment">/*;q=0.8</span></span><br></pre></td></tr></table></figure><p>该首部字段可以通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可以使用 <code>type/subtype</code> 的形式一次指定多种媒体类型。</p><p>常用媒体类型：</p><ul><li><p>文本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html,text&#x2F;plain,text&#x2F;css,application&#x2F;xhtml+xml,application&#x2F;xml...</span><br></pre></td></tr></table></figure></li><li><p>图片文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image&#x2F;jpg,image&#x2F;gif,image&#x2F;png...</span><br></pre></td></tr></table></figure></li><li><p>视频文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video&#x2F;mpeg,video&#x2F;quicktime...</span><br></pre></td></tr></table></figure></li><li><p>应用程序使用的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application&#x2F;octet-stream,application&#x2F;zip...</span><br></pre></td></tr></table></figure></li></ul><p>多个协议之间使用逗号分隔，分号之前代表媒体类型，分号之后代表权重。</p><p>当服务器提供多种内容时，会首先返回权重最高的媒体类型。</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5,unicode-1-1;q&#x3D;0.8</span><br></pre></td></tr></table></figure><p>该字段可用来通知服务器用户代理支持的字符集以及字符集的权重。</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br></pre></td></tr></table></figure><p>该字段用来告知服务器用户代理支持的内容编码及内容编码格式的优先级。</p><p>以下是最常用的几个内容编码格式：</p><ul><li><p>gzip</p><p>由文件压缩程序gzip(GNU zip)生成的编码 格式(RFC1952)</p></li><li><p>compress</p><p>由UNIX文件压缩程序compress生成的编码格式</p></li><li><p>deflate</p><p>组和使用zlib格式及有deflate压缩算法生成的编码格式</p></li><li><p>identity</p><p>不执行压缩或者不会变化的默认编码格式</p></li></ul><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>告知服务器能够处理的自然语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-cn,zh;q = <span class="number">0.7</span>, en-us,en; q = <span class="number">0.3</span></span><br></pre></td></tr></table></figure><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>该字段用于告知服务器用户代理的认证信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure><h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect: <span class="number">100</span>-<span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">From: info<span class="meta">@hackr</span>.jp</span><br></pre></td></tr></table></figure><p>该字段用来告知服务器使用用户代理的用户电子邮箱地址</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>很多时候一台服务器上部署了多个网站，对应着多个域名，当 DNS 解析到服务器之后，我们需要知道用户访问的是哪个网址，以便分配到对应的端口给对应的程序进行处理，所以 Host 就用来告知服务器端用户访问的主机名称和端口号。</p><p>Host 首部是唯一一个必须被包含在请求内的首部字段。</p><p>如果服务器未设定主机名，那么发送一个空值即可</p><h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>形如 If-xxx 的请求首部字段，都可以称为条件请求。服务器接收到条件请求之后，只有在判断条件为真时才会执行请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><p>该首部字段属于附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag，后面会讲）值。服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时才会执行请求。反之会返回状态码 412 Precondition Failed 的响应。</p><p>使用 <code>*</code> 时，服务器会匹配任意的 ETag 值。</p><h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p>该首部字段指定一个时间点，如果在该时间点之后有修改过资源，则会响应请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Thu, <span class="number">15</span> Apr <span class="number">2004</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> GMT </span><br></pre></td></tr></table></figure><p>如果在这个时间点之后没有修改过资源，则返回304 Not Modified状态码的响应</p><h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>该字段与If-Match的作用相反。当该字段的值不匹配资源的ETag时才会响应请求。</p><h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p>该字段的值若是跟 ETag 的值或更新的日期时间相匹配，那么就作为范围请求处理；如果无法匹配的话就返回全体资源。</p><h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure><p>该首部字段和 <code>If-Modified-Since</code> 作用相反，它的作用是告知服务器指定的资源只有在指定日期之后没有发生变更的情况下才处理请求，否则就返回 412 Precondition Failed 状态码。</p><h4 id="Max-Forward"><a href="#Max-Forward" class="headerlink" title="Max-Forward"></a>Max-Forward</h4><p>通过 TRACE 方法或者 OPTIONS 方法发送包含首部字段 Max-Forward 的请求时，该字段以十进制整数形式指定可经过的服务器的最大数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Forward: <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwObjkNLAGFfY5</span><br></pre></td></tr></table></figure><p>该字段告知服务器认证所需要的的信息。该认证行为发生在客户端与代理服务器之间。</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes = <span class="number">5001</span>-<span class="number">10000</span></span><br></pre></td></tr></table></figure><p>该字段适用于只获取部分资源的范围请求，他告知了服务器所需要的服务器资源的指定范围。</p><p>接收到携带该字段请求的服务器返回状态码为206  Partil Content的响应，如果无法处理该范围请求，则服务器会返回状态码为220 OK的响应以及全部资源。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http:<span class="comment">//www.hackr.jp/index.htm</span></span><br></pre></td></tr></table></figure><p>该首部字段告知服务器请求的原始资料的URI</p><h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip,deflate;q=<span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>该字段会告知服务器客户端能够处理的响应传世编码方式及相对的优先级，其功能和Transfer-Enconding的功能相似。</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko&#x2F;20100101 Firefox&#x2F;13.0.1</span><br></pre></td></tr></table></figure><p>该字段会将创建请求的浏览器和用户代理名称的相关信息发送给服务器。当爬虫发起请求时，有可能会在该字段添加作者的地址。</p><p>值得一提的是有些网站会做出反爬虫策略，他们会验证 User-Agent 字段是否来自于浏览器，如果不是的话就会拒绝爬虫的请求；所以如果要想继续拿到想要的信息的话就会通过该字段将爬虫伪造成浏览器。</p><h3 id="6-2-4-HTTP-1-1-响应首部字段"><a href="#6-2-4-HTTP-1-1-响应首部字段" class="headerlink" title="6.2.4 HTTP/1.1 响应首部字段"></a>6.2.4 HTTP/1.1 响应首部字段</h3><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求信息等。</p><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p>该字段用于告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。当服务器能够处理客户端的范围请求时，其值为 bytes，反之为 none。</p><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aag: 600</span><br></pre></td></tr></table></figure><p>该首部字段告知客户端<strong>源服务器</strong>在多久之前创建了响应，字段的值的单位为秒。</p><p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到再次认证完成的时间值。</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span>: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure><p>首部字段 ETag 能告知客户端实体标志。它是一种能够将资源以字符串形式做唯一性标志的方式。服务器会为每份资源分配对应的 ETag 值。</p><p>当资源更新时，ETag 值也要更新。完成 ETag 值时，并没有统一的算法规则，仅仅由服务器分配。</p><p>访问某个资源的 URI 一般不会发生改变，但是当资源本身发生了变化时，资源对应的 ETag 也会更新。</p><p><strong>强 ETag 和弱 ETag</strong></p><p>ETag 值有强弱之分，强 ETag 值不管资源发生多么细微的变化都会随之变化，而弱 ETag 值只有在资源发生了根本改变并产生差异时才会发生变化。</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Location</span>: http://www.usagidesign.jp/sample.html</span><br></pre></td></tr></table></figure><p>该首部字段可以将接受响应的客户端引导到某一个与其请求 URI 位置不同的资源。</p><p>基本上该字段会配合 3xx 重定向状态码一起使用。</p><h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Proxy-Authenticate</span>: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>该首部字段会把代理服务器所要求的认证信息发送给客户端。</p><h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry After"></a>Retry After</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Retry-After：120</span></span><br></pre></td></tr></table></figure><p>该首部字段告知客户端在多久之后再次发起请求。该字段可以指定为具体的时间或者创建响应后的秒数。</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>该首部字段会告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Server</span>: Apache/2.2.17 (Unix)</span><br></pre></td></tr></table></figure><h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Vary</span>: Accept-Language</span><br></pre></td></tr></table></figure><p>该首部字段可对缓存进行控制，源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p><p>具体来说，该首部字段会指定一个其他的首部字段，比如上面的 Accept-Encoding，当指定字段的值未发生变化时，则使用缓存资源；如果指定字段的值发生了变化时，则需要向源服务器请求最新的资源。</p><p>这个字段可以指定 User-Agent，防止移动端浏览器访问页面时访问了 PC 端页面的缓存。</p><p>当该字段指定为 <code>*</code> 时，所有的请求都会被视为唯一的并且会被缓存。</p><h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">WWW-Authenticate</span>: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>该首部字段用于 HTTP 访问认证。</p><h3 id="6-2-4-HTTP-1-1-实体首部字段"><a href="#6-2-4-HTTP-1-1-实体首部字段" class="headerlink" title="6.2.4 HTTP/1.1 实体首部字段"></a>6.2.4 HTTP/1.1 实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间和实体相关的信息。</p><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Allow：GET，HEAD</span></span><br></pre></td></tr></table></figure><p>该首部字段用于通知客户端服务器能够支持的 HTTP 方法，当服务器接收到不支持的请求方法时，会返回 405 Not Allowed 状态码。</p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding：gzip</span></span><br></pre></td></tr></table></figure><p>该首部字段会告知客户端对实体的主体部分所使用的内容编码格式。</p><p>具体编码格式可以参考 2.5.3 Accept-Encoding。</p><h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language； zh-CN</span><br></pre></td></tr></table></figure><p>该首部字段用于通知客户端实体主体所使用的自然语言。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length：15000</span></span><br></pre></td></tr></table></figure><p>该首部字段表明了实体主体的大小（单位是字节）。</p><p>如果对实体主体采用了内容编码传输时，不能再使用 Content-Length 首部字段。</p><h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Location：http://www.hackr.jp/index-ja.html</span></span><br></pre></td></tr></table></figure><p>该首部字段给出与报文主体相对应的 URI。当返回的页面内容与请求的实际对象不相同时，首部字段 Content-Location 会写明 URI。</p><h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-MD5</span>: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure><p>客户端会对接收到的报文主体采用 MD5 算法进行散列计算，然后与 Content-MD5 的值进行比较以对接收到的主体内容进行完整性校验。</p><p>散列算法进行计算的做法主要用于防止传输内容被篡改，因为同一个输入通过散列算法计算以后得到的结果是相同的，不同的输入经过散列算法计算之后得到的结果基本不会重复。这也是许多提供资源下载的网站同时会给出资源对应 HASH 值的原因。</p><p>但是 Content-MD5 并不可靠，因为如果传输主体的内容可以被修改的话，Content-MD5 的值同样也可能被修改过，所以并不可靠。为了确保资源不被篡改，最好还是使用 HTTPS。</p><h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range</span>: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure><p>针对范围请求，该首部字段告知客户端返回的响应的实体的哪些部分符合范围请求，单位为字节。</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>该首部字段说明了实体主体内的媒体类型。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><p>该首部字段将资源失效的日期告知客户端。</p><p>当首部字段 Cache-Control 有指定 max-age 指令时，会优先处理 max-age 指令。</p><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span>: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure><p>该首部字段指明了资源的最终修改时间。</p><h3 id="Cookie-服务的首部字段"><a href="#Cookie-服务的首部字段" class="headerlink" title="Cookie 服务的首部字段"></a>Cookie 服务的首部字段</h3><p><strong>Cookie 的工作机制是用户识别及状态管理</strong>。</p><p>为 cookie 服务的首部字段：</p><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应首部字段</td></tr><tr><td>Cookie</td><td>服务器接收到的 Cookie 信息</td><td>请求首部字段</td></tr></tbody></table><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><p>当服务器开始准备管理客户端的状态时，会实现告知各种信息。</p><p>下面的表格列举了 Set-Cookie 的字段值。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>NAME=VALUE</td><td>赋予 Cookie 的键和对应值</td></tr><tr><td>expires=DATE</td><td>Cookie 的有效期</td></tr><tr><td>path=PATH</td><td>将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）</td></tr><tr><td>domain=域名</td><td>作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td></tr><tr><td>Secure</td><td>仅在 HTTPS 安全通信时才发送 Cookie</td></tr><tr><td>HttpOnly</td><td>加以限制，使 Cookie 不能被 JavaScript 所访问</td></tr></tbody></table><p>下面详细讲讲 Cookie 的各个属性。</p><ul><li><p><code>expires</code>：该属性指定浏览器可以发送 Cookie 的有效期。当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器关闭之前。</p><p>另外需要注意的是一旦 Cookie 从服务器端发送到客户端，服务器端就不存在可以显式删除 Cookie 的方法。只能通过覆盖已有的 Cookie 来达到删除的目的。</p></li><li><p><code>path</code>：该属性用于限定指定 Cookie 的发送范围的文件目录。但是有其他办法可以避开这个限制，所以不要对它抱有太大期望。</p></li><li><p><code>domain</code>：该属性的域名可做到与结尾匹配一致，比如指定 domain 为 example.com，此时 <a href="http://www.example.com/">www.example.com</a> 和 www2.example.com 也都可以访问 Cookie。所以不指定域名的情况下更加安全，因为默认只有当前响应的服务器的域名可以访问 Cookie。</p></li><li><p><code>secure</code>：该属性限制 Web 页面仅在 HTTPS 安全连接时才发送 Cookie。当省略该属性时，HTTP 和 HTTPS 协议的指定域名都可以访问 Cookie。</p></li><li><p><code>HttpOnly</code>：该属性使得 JavaScript 无法对 Cookie 进行读取操作。</p></li></ul><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie：status=enable</span><br></pre></td></tr></table></figure><p>首部字段 Cookie 会告知服务器，当客户端想要获得 HTTP 状态管理的支持时，就会在请求中包含从服务器中获取到的 Cookie。</p><h3 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h3><p>HTTP 首部字段是可以自行扩展的，所以在 Web 服务器和浏览器的应用上，会出现一些非标准的首部字段。</p><p>下面是比较常用的非标准首部字段：</p><ul><li>X-Frame-Options</li><li>X-XSS-Protection</li><li>DNT</li><li>P3P</li></ul><h4 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Frame-Options</span>: DENY</span><br><span class="line">此处的 Frame 包括 iframe、frame、object 等标签</span><br></pre></td></tr></table></figure><p>该首部字段属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是防止点击劫持攻击（clickjacking）。</p><p>该字段可以指定三类值：</p><ul><li><code>DENY</code>：拒绝被嵌套到 Frame，即使是相同域名下的页面也不行</li><li><code>SAMEORIGIN</code>：该页面只可以被嵌入到相同域名页面的 Frame 中</li><li><code>ALLOW-FROM uri</code>：表示可以在指定来源的页面中被嵌套</li></ul><h4 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h4><p>该字段属于响应首部，是针对跨域脚本攻击的一种策略，用于控制浏览器 XSS 防护机制的开关。</p><p>该字段可以设置一下了两个值：</p><ul><li>0：将 XSS 过滤设置成无效状态</li><li>1：将 XSS 过滤设置成有效状态</li></ul><h4 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">DNT：1</span></span><br></pre></td></tr></table></figure><p>该首部字段属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，表示拒绝个人信息被收集。</p><p>0 表示同意被追踪，1 表示拒绝被追踪。</p><h4 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h4><p>该首部字段属于响应首部，通过利用 P3P 技术让网站上的个人隐私变成仅供程序可理解的形式。</p><h1 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h1><h2 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h2><p>HTTP在通信过程中会面临以下三种安全问题：</p><ul><li>通信使用明文（不加密），内容可能会被监听</li><li>不验证通信方的身份，可能会遭遇伪装</li><li>无法验证报文的完整性，可能已经被篡改</li></ul><p><strong>谷歌浏览器强制要求https</strong></p><h3 id="7-1-1-窃听"><a href="#7-1-1-窃听" class="headerlink" title="7.1.1 窃听"></a>7.1.1 窃听</h3><p>HTTP本身不具备加密功能，所以传输的过程中都是以明文 方式发送</p><p>由于在网络的传输过程中，我们所发送的信息要 经过许多的网络节点和设备，在这个过程中这些设备是可能会拦截我们的信息并且进行窃听的，直接通过一些常用的抓包工具就可以窃听未加密的网络传输信息。</p><p><strong>通过加密防止窃听</strong></p><ul><li><p><strong>通信的加密</strong>  为了防止传输内容被窃听，我们采取的方式之一就是通信加密，HTTP本身没有加密机制，但是我们可以通过将HTTP和SSL（Secure Socket Layer 安全套接层） 或者 TLS（Transport Layer Security 安全传输协议）组和使用来加密传输内容。</p><p>用 SSL 建立安全通信线路以后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure）</p></li><li><p><strong>内容的加密</strong>  还有一种方式就是将参与通信的内容本身进行加密。这样的话就需要客户端对HTTP报文加密后再请求发送。由于该方式不同于HTTPS将整个通信线路加密的方式，所以内容仍然会有被篡改的风险。</p></li></ul><h3 id="7-1-2-伪装"><a href="#7-1-2-伪装" class="headerlink" title="7.1.2 伪装"></a>7.1.2 伪装</h3><p>HTTP 协议本身并不会对通信的另一方进行身份验证，所以任何人都能对服务器发起请求。</p><p>不验证通信方可能就会存在各种安全隐患：</p><ul><li>客户端无法确认自己的请求是否发送到了目标服务器或者返回响应的服务器是否是目标服务器，有可能是伪装了的服务器。</li><li>服务器无法确认向自己发起请求的客户端以及自己返回响应的客户端是否是目标中的客户端。</li><li>无法确认通信方是否具备访问权限，因为某些服务器只想给特定的用户访问。</li><li>即使是无意义的请求也会照单全收，使得服务器可能遭受到 DDoS 攻击。</li></ul><p><strong>通过查明对方证书来防止伪装</strong></p><p>SSL不仅提供加密处理，而且使用了一种称为证书的手段，可用于确认对方身份。</p><p><strong>证书由第三方机构颁发，用以证明服务器的客户端是实际存在的。</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38aa5f65f" alt="httpcert"></p><p>通过使用证书可以证明通信方就是意料中的服务器。对使用者而言，也减少了个人信息泄露的风险。</p><p>另外，客户端持有证书即可完成个人身份的认证，也可用于对网站的认证环节。</p><h3 id="7-1-3-篡改"><a href="#7-1-3-篡改" class="headerlink" title="7.1.3 篡改"></a>7.1.3 篡改</h3><p>HTTP协议通常无法确认信息的完整性，一旦传输的信息被篡改，那么信息就失去了准去性，导致信息有误。比如你想在某一个网站的下载一个资源，而你的资源传输已经被被人劫持，在你发起下载请求的时候，你所接收到的资源正在被人修改，所以你下载到的资源就不是你想要的那个了。</p><p>像这样，请求或者响应在传输途中遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack, MitM）。</p><p><strong>如何防止篡改</strong></p><p>之前的章节有提到过Content-MD5 实体首部字段可用于确认实体内容是否完整，但是由于Content-MD5本身的值也有可能被篡改，所以这个字段并不可靠，所以需要其他方法来确保传输的内容不被篡改。</p><p>通过其他散列算法来计算传输内容是否完整也不可靠，那么我们最终还是需要HTTPS来帮我解决这个问题。SSL提供认证和加密处理以及<strong>摘要功能</strong>。</p><h2 id="7-2-HTTPS"><a href="#7-2-HTTPS" class="headerlink" title="7.2 HTTPS"></a>7.2 HTTPS</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPS = HTTP + 加密 + 认证 + 摘要</span><br></pre></td></tr></table></figure><h3 id="7-2-1-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-1-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.1 HTTPS是身披SSL外壳的HTTP"></a>7.2.1 HTTPS是身披SSL外壳的HTTP</h3><p>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替而已。</p><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 的时候，就先和 SSL 通信，再由 SSL 和 TCP 通信了。所以简而言之，HTTPS 就是身披 SSL 外壳的 HTTP 协议。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38ab5952f" alt="https"></p><p>在采用 SSL 以后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护功能了。</p><p>SSL 协议是独立于 HTTP 的协议，所以其他协议也可以采用 SSL 协议，它是当今世界上应用最广泛的网络安全技术</p><h3 id="7-2-2-相互交换秘钥的公开秘钥加密技术"><a href="#7-2-2-相互交换秘钥的公开秘钥加密技术" class="headerlink" title="7.2.2 相互交换秘钥的公开秘钥加密技术"></a>7.2.2 相互交换秘钥的公开秘钥加密技术</h3><p>在将SSL之前可以了解一下加密技术，SSL采用一种叫做公开秘钥加密（Public-key Cryptography）的加密处理技术。</p><p>近代的加密方法中，加密算法是公开的，但是秘钥是保密的。加密和解密都会用到秘钥。没有秘钥无法对秘钥进行解密。反过来说没任何人只要拿到秘钥就可以解密信息。如果秘钥被攻击者获得，那加密就失去了意义</p><ul><li><p><strong>共享密钥加密的困境</strong></p><p><strong>加密和解密使用同一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密</strong>。</p><p>采用共享密钥加密方式加密时，需要将密钥一起发送给通信方，所以有需要考虑密钥传输的安全性，需要设法安全地保管密钥，这便是共享密钥加密方式的困扰。</p></li><li><p><strong>使用两把秘钥加密的公开秘钥加密方式</strong></p><p>公开密钥加密方式很好的解决了共享密钥加密方式的困扰。</p><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能被其他任何人知道，而公开密钥则可以仁任意传播，任何人都可以拿到。</p><p>使用公开密钥加密方式（非对称加密），发送密文的一方使用公钥进行加密处理，而接收方拿到被加密后的信息之后再使用自己的私钥进行解密。利用这种方式进行传输，就不需要发送密钥，也就不用担心密钥被攻击者拿走了。</p></li><li><p><strong>HTTPS采用混合加密机制</strong></p><p>HTTPS采用共享秘钥加密方式和公开秘钥加密方式混合的加密方式。</p><p>如果秘钥可以被安全传输，则HTTPS会考虑采用共享加密方式，否则将采用公开秘钥加密方式。这是因为公开密钥加密方式的速度比共享密钥加密方式要慢。HTTPS充分地利用了两者的有点，将多种方法组合起来用于通信。<strong>在使用公开密钥加密方式交换密钥之后，之后的信息传输使用共享密钥加密方式</strong>。</p></li></ul><h3 id="7-2-3-证明公开密钥正确性的证书"><a href="#7-2-3-证明公开密钥正确性的证书" class="headerlink" title="7.2.3 证明公开密钥正确性的证书"></a>7.2.3 证明公开密钥正确性的证书</h3><p>遗憾的是公开密钥加密方式本身也是有缺陷的，那就是无法证明公开的密钥本身是货真价实的。</p><p>为了解决上面说到的问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机构颁发的公开密钥证书。</p><p>数字证书认证机构处于客户端与服务端双方都信赖的第三方机构的立场上，威瑞新（VeriSign）就是其中一家非常有名的数字证书认证机构。</p><p>下面讲解一下数字证书认证机构的业务流程：</p><p>首先，服务器的运营人员会向数字机构提出公开密钥申请，CA 在认证申请者的身份信息之后，会对已申请的公开密钥进行数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书之后绑定在一起。</p><p>服务器会将这份 CA 颁发的公钥证书发送给客户端，以进行公钥加密方式通信，公钥证书也可叫做数字证书或者直接称为证书。</p><p>接到证书的客户端可使用 CA 的公钥对证书的数字签名进行认证，一旦验证通过，客户端便可确认两件事：</p><ul><li>认证服务器公钥的机构是真实有效的 CA 机构</li><li>服务器的公钥是值得信任的</li></ul><p>于是这就达到了确认公钥真实有效性的目的。</p><p>安全地转交 CA 机构的密钥给客户端是一件困难的事，因此多数浏览器会在内部植入常用认证机构的公钥。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd850947bf0" alt="httpskey"></p><ul><li><p>可证明组织真实性的 EV SSL 证书</p><p>证书的一个作用是证明作为通信一方的服务器是否符合规范，另一个作用是确认服务器运营商企业是否真实存在。能够证明企业真实性的正式就是 EV SSL 证书（Extended Validation SSL Certificate）。</p><p>该证书的目的是为了防止钓鱼攻击（Phishing）。</p></li><li><p>用以确认客户端的客户端证书</p><p>HTTPS 中还可以使用客户端证书对客户端进行认证。</p></li></ul><h2 id="7-4-HTTPS的安全通信机制"><a href="#7-4-HTTPS的安全通信机制" class="headerlink" title="7.4 HTTPS的安全通信机制"></a>7.4 HTTPS的安全通信机制</h2><p>为了更好的理解 HTTPS，我们来观察一下 HTTPS 的通信步骤。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-3badd05d6f7e3d84.png" alt="img"></p><ul><li>步骤1：客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</li><li>步骤2：服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>步骤3：之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</li><li>步骤4：最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</li><li>步骤5：SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</li><li>步骤6：接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret密钥加密。</li><li>步骤7：客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>步骤8：服务器同样发送 Change Cipher Spec 报文。</li><li>步骤9：服务器同样发送 Finished 报文。</li><li>步骤10：服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完毕。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</li><li>步骤11：应用协议通信，即发送 HTTP 响应。</li><li>步骤12：最后由客户端断开连接。断开连接时，发送 close_notify 报文。</li></ul><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><p>下面是对整个流程的图解。图中说明了从仅适用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022150748120.png" alt="image-20201022150748120"></p><h3 id="SSL-速度慢吗"><a href="#SSL-速度慢吗" class="headerlink" title="SSL 速度慢吗"></a>SSL 速度慢吗</h3><p>HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。</p><p>SSL 的慢是分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p><p>和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求/响应外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。</p><p>另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。</p><p>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。</p><h3 id="为什么不一直使用-HTTPS"><a href="#为什么不一直使用-HTTPS" class="headerlink" title="为什么不一直使用 HTTPS"></a>为什么不一直使用 HTTPS</h3><ol><li>因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量也必然减少。因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。</li><li>除此之外，想要节约购买证书的开销也是原因之一。</li></ol><h1 id="8-确认访问用户身份的认证"><a href="#8-确认访问用户身份的认证" class="headerlink" title="8. 确认访问用户身份的认证"></a>8. 确认访问用户身份的认证</h1><h2 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h2><p>计算机本身无法判断坐在显示器前的使用者的身份，为了确认是谁在访问服务器，需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。核对的信息通常是指以下这些：</p><ul><li>密码：只有本人才会知道的字符串信息。</li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。</li><li>数字证书：仅限本人（终端）持有的信息。</li><li>生物认证：指纹和虹膜等本人的生理信息</li><li>IC 卡等：仅限本人持有的信息。</li></ul><p> <strong>HTTP/1.1 使用的认证方式如下所示：</strong></p><ul><li>BASIC认证（基本认证）</li><li>DIGEST认证（摘要认证）</li><li>SSL 客户端认证</li><li>FormBase 认证（基于表单认证）</li></ul><h2 id="8-2-BASIC-认证"><a href="#8-2-BASIC-认证" class="headerlink" title="8.2 BASIC 认证"></a>8.2 BASIC 认证</h2><p>BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022151634964.png" alt="image-20201022151634964"></p><p>步骤1：当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm）。</p><p>步骤2：接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（：）连接后，再经过 Base64 编码处理。将编码后的字符串写入首部字段 Authorization 后，发送请求。</p><p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。</p><p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解密。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。</p><p>另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。</p><p>BASIC 认证使用上不够灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。</p><h2 id="8-3-DIGEST-认证"><a href="#8-3-DIGEST-认证" class="headerlink" title="8.3 DIGEST 认证"></a>8.3 DIGEST 认证</h2><p>为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。DIGEST 认证同样使用质询/响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。</p><p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的咨询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-bb8255a4cfc8db60.png" alt="img"></p><p>因为发送给对方的只是响应摘要及由知讯码产生的计算结果，所以比起 BASIC 认证，密码泄露的可能性就降低了。</p><ul><li>DIGEST 认证的认证步骤</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/4179925-37e273e40111f18a.png" alt="img"></p><p>步骤1：请求需认证的资源时，服务器会随着状态码 401 Authorication Required，返回带  WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需要的临时咨询码（随机数，nonce）。</p><p>首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。</p><p>nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现</p><p>步骤2：接收到401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息，其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。</p><p>步骤3：接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则会返回包含 Request-URI 资源的响应。</p><p>并且这时会在首部字段 Authorization-Info 写入一些认证成功的相关信息。</p><h2 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h2><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自登录的客户端。</p><ul><li>SSL 客户端认证的认证步骤</li></ul><p>为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。</p><p>步骤1：接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</p><p>步骤2：用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</p><p>步骤3：服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</p><ul><li>SSL 客户端认证采用双因素认证</li></ul><p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p><p>换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。</p><ul><li>SSL 客户端认证必要的费用</li></ul><p>使用 SSL 客户端认证需要用到客户端证书，而客户端证书需要支付一定费用才能使用。</p><h2 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h2><p>基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息，按登录信息的验证结果认证。</p><p>多数情况下，输入已事先登录的用户 ID 和密码等登录信息后，发送给 Web 应用程序，基于认证结果来决定认证是否成功。</p><h4 id="8-5-1-Session-管理及-Cookie-应用"><a href="#8-5-1-Session-管理及-Cookie-应用" class="headerlink" title="8.5.1 Session 管理及 Cookie 应用"></a>8.5.1 Session 管理及 Cookie 应用</h4><p>第八章要讲的内容不多，所以把最重要的一点挪到了这一篇笔记。</p><p>关于用户身份的认证，现在多数是采用表单认证，一般会采用 Cookie 来管理 Session（会话）。</p><p>大致流程如下：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bd38ab3ca24" alt="httpsession"></p><p>具体步骤如下：</p><ul><li>客户端把用户的 ID 密码等登录信息放入报文的实体部分，通常用 POST 方法发送至服务器端。</li><li>服务器生成并发放用来识别客户的 Session ID，这个 Session ID 同时会在服务器端保存，然后通过 Set-Cookie 字段绑定到客户端。顺便可以使用 <code>httponly</code> 属性来禁止 JavaScript 修改 Cookie，防止跨站脚本攻击。</li><li>客户端把 Session ID 保存在本地 Cookie，下次访问时再带上。服务器端通过验证接收到的 Session ID 来识别用户，从数据库中可以顺便取到与用户相关的一系列信息。</li></ul><h1 id="9-基于-HTTP-的功能追加协议"><a href="#9-基于-HTTP-的功能追加协议" class="headerlink" title="9.基于 HTTP 的功能追加协议"></a>9.基于 HTTP 的功能追加协议</h1><h2 id="9-1-基于-HTTP-的协议"><a href="#9-1-基于-HTTP-的协议" class="headerlink" title="9.1 基于 HTTP 的协议"></a>9.1 基于 HTTP 的协议</h2><p>HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。</p><h2 id="9-2-消除-HTTP-瓶颈的-SPDY"><a href="#9-2-消除-HTTP-瓶颈的-SPDY" class="headerlink" title="9.2 消除 HTTP 瓶颈的 SPDY"></a>9.2 消除 HTTP 瓶颈的 SPDY</h2><p>Google 在 2010 年发布了 SPDY，其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p><h3 id="9-2-1-HTTP-的瓶颈"><a href="#9-2-1-HTTP-的瓶颈" class="headerlink" title="9.2.1 HTTP 的瓶颈"></a>9.2.1 HTTP 的瓶颈</h3><p>HTTP 存在以下缺点和不足：</p><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收除响应以外的指令</li><li>请求/响应首部未经压缩就发送，首部信息越多延迟越大</li><li>发送冗长的首部，每次互相发送相同的首部造成的浪费较多</li><li>可任意选择数据压缩格式，非强制压缩发送</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154013733.png" alt="image-20201022154013733"></p><ol><li>Ajax 的解决办法</li></ol><p>Ajax 是一种有效利用 JavaScript 和 DOM 的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少。</p><p>而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154032725.png" alt="image-20201022154032725"></p><ol><li>Comet 的解决办法<br> 一旦服务器有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延时应答，模拟实现服务器向客户端推送的功能。</li></ol><p>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154055953.png" alt="image-20201022154055953"></p><h3 id="9-2-2-SPDY-的设计与功能"><a href="#9-2-2-SPDY-的设计与功能" class="headerlink" title="9.2.2 SPDY 的设计与功能"></a>9.2.2 SPDY 的设计与功能</h3><p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。</p><p>SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法，Cookie 以及 HTTP 报文等。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154125271.png" alt="image-20201022154125271">spdy.png</p><p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p><ul><li>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</li><li>赋予请求优先级：SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li>压缩 HTTP 首部：压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了</li><li>推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</li><li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。</li></ul><h3 id="9-2-3-SPDY-消除-Web-瓶颈了吗"><a href="#9-2-3-SPDY-消除-Web-瓶颈了吗" class="headerlink" title="9.2.3 SPDY 消除 Web 瓶颈了吗"></a>9.2.3 SPDY 消除 Web 瓶颈了吗</h3><p>因为 SPDY 基本上只是将多个域名（IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会收到限制。</p><h2 id="9-3-使用浏览器进行全双工通信的-WebSocket9"><a href="#9-3-使用浏览器进行全双工通信的-WebSocket9" class="headerlink" title="9.3 使用浏览器进行全双工通信的 WebSocket9"></a>9.3 使用浏览器进行全双工通信的 WebSocket9</h2><p>WebSocket 是为解决 HTTP 协议所面临的困难的一种新的协议及 API。</p><h3 id="9-3-1-WebSocket-的设计与功能"><a href="#9-3-1-WebSocket-的设计与功能" class="headerlink" title="9.3.1 WebSocket 的设计与功能"></a>9.3.1 WebSocket 的设计与功能</h3><p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。</p><h3 id="9-3-2-WebSocket-协议"><a href="#9-3-2-WebSocket-协议" class="headerlink" title="9.3.2 WebSocket 协议"></a>9.3.2 WebSocket 协议</h3><p>一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可相互发送 JSON、XML、HTML 或图片等任意格式的数据。</p><p>由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p><p>下面我们列举一下 WebSocket 协议的主要特点：</p><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应较少了。</li></ul><p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次 “握手” 的步骤。</p><ol><li>握手·请求<br> 为了实现 WebSocket 通信，需要用到 HTTP 的 <code>Upgrade</code> 首部字段，告知服务器通信协议发送改变，已达到握手的目的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“GET /chat HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span>”</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Protocol</code> 字段内记录着握手过程中必不可少的键值，<code>Sec-WebSocket-Protocol</code> 字段内记录使用的子协议。</p><p>子协议按 <code>WebSocket</code> 协议标准在连接分开使用时，定义那些连接的名称。</p><ol><li>握手·响应<br> 对于之前的请求，返回状态码 <code>101 Switching Protocols</code> 的响应。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat”</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Accept</code> 的字段值是由握手请求中的 <code>Sec-WebSocket-Accept</code> 的字段值生成的。</p><p>成功握手确立 <code>WebSocket</code> 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201022154245807.png" alt="image-20201022154245807"></p><h2 id="9-4-期盼已久的-HTTP-2-0"><a href="#9-4-期盼已久的-HTTP-2-0" class="headerlink" title="9.4 期盼已久的 HTTP/2.0"></a>9.4 期盼已久的 HTTP/2.0</h2><p>HTTP/2.0 在 2014 年 11 月实现标准化。</p><ul><li>HTTP/2.0 的特点<br> HTTP/2.0 的目标是改善用户在使用 Web 时的速断体验。</li></ul><p>HTTP/2.0 围绕着主要的 7 项技术进行讨论。</p><table><thead><tr><th align="center">压缩</th><th align="center">SPDY、Friendly</th></tr></thead><tbody><tr><td align="center">多路复用</td><td align="center">SPDY</td></tr><tr><td align="center">TLS 义务化</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">协商</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">客户端拉拽</td><td align="center">Speed + Mobility</td></tr><tr><td align="center">流量控制</td><td align="center">SPDY</td></tr><tr><td align="center">WebSocket</td><td align="center">Speed + Mobility</td></tr></tbody></table><h1 id="11-常见的Web攻击技术"><a href="#11-常见的Web攻击技术" class="headerlink" title="11.常见的Web攻击技术"></a>11.常见的Web攻击技术</h1><h2 id="11-1-跨站脚本攻击"><a href="#11-1-跨站脚本攻击" class="headerlink" title="11.1 跨站脚本攻击"></a>11.1 跨站脚本攻击</h2><p>跨站脚本攻击(Cross-Site Scripting , XSS) 是指通过存在安全漏洞的web网站注册用户的浏览器运行非法的HTML标签或者JavaScrip代码的一种攻击方式。动态创建的HTML可能存在安全漏洞。</p><p>该攻击可能造成以下影响：</p><ul><li>利用虚假输入表单骗取用户个人信息</li><li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求</li><li>显示伪造的文章或者图片</li></ul><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c05bf024b37126" alt="xss"></p><p>上图的表单输入以后直接把输入内容当做 HTML 展示在页面上，所以存在着安全漏洞，攻击者可以直接在输入框内编辑危险的代码，然后就会在页面上运行。</p><h2 id="11-2-SQL-注入攻击"><a href="#11-2-SQL-注入攻击" class="headerlink" title="11.2 SQL 注入攻击"></a>11.2 SQL 注入攻击</h2><p>SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的安全威胁，有时会直接导致个人信息及机密信息的泄露。</p><p>SQL 注入可能会导致如下影响：</p><ul><li>非法查看或篡改数据库内的数据</li><li>规避认证</li><li>执行和数据库服务器业务关联的程序等</li></ul><p>如果我们不对输入进行验证就直接拿去拼接 SQL 的话，是可能会被执行 SQL 注入攻击的。</p><h2 id="11-3-目录遍历攻击"><a href="#11-3-目录遍历攻击" class="headerlink" title="11.3 目录遍历攻击"></a>11.3 目录遍历攻击</h2><p>目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也被叫做路径遍历攻击（Path Traversal）。</p><h2 id="11-4-会话劫持"><a href="#11-4-会话劫持" class="headerlink" title="11.4 会话劫持"></a>11.4 会话劫持</h2><p>会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</p><p>具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理认证状态的主流方式。会话 ID 中记录客户端的 Cookie 等信息，服务器端将会话 ID 与认证状态进行一对一匹配管理。</p><p>攻击者可能通过以下方式获得会话 ID：</p><ul><li>通过非正规的生成方法推测会话 ID</li><li>通过窃听或 XSS 攻击盗取会话 ID</li><li>通过会话固定攻击（Session Fixation）强行获取会话 ID</li></ul><p>通常情况下攻击者在发现网站存在的 XSS 攻击漏洞之后，会注入一段 JavaScript 代码，通过 <code>document.cookie</code> 盗取到会话 ID，之后植入到自己的浏览器，就可以伪装成被盗窃的用户访问被攻击的网站。</p><h2 id="11-5-跨站点请求伪造"><a href="#11-5-跨站点请求伪造" class="headerlink" title="11.5 跨站点请求伪造"></a>11.5 跨站点请求伪造</h2><p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</p><p>最常见的例子就是在一个需要登录才能进行操作的网站，攻击者在该网站伪造了一个可以触发危险操作的内容（比如 a 和 button 标签），用户在不经意间点击这些伪造的内容后就自动发起了请求，而这些请求如果是指向当前网站的话，用户的会话 ID 等信息也会被带上，使得被攻击者不经意之间完成了一次可能极为危险的操作。</p><h2 id="11-6-点击劫持"><a href="#11-6-点击劫持" class="headerlink" title="11.6 点击劫持"></a>11.6 点击劫持</h2><p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱导用户在不知情的情况下点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</p><p>这种攻击最常见的案例就是某些小网站……</p><h2 id="11-7-DoS-攻击"><a href="#11-7-DoS-攻击" class="headerlink" title="11.7 DoS 攻击"></a>11.7 DoS 攻击</h2><p>DoS 攻击（Denial of Service Attack）是一种让运行中的服务呈停止状态的攻击。有时也叫作停止服务攻击或者拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。</p><p>DoS 主要有以下两种攻击方式：</p><ul><li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态</li><li>通过攻击安全漏洞是服务停止</li></ul><p>由此可见所有使得服务停止的攻击都可以称为 DoS 攻击。</p><p>DoS 攻击在中国前端届比较著名的案例就是阮一峰老师的博客遭到过的一次攻击：<a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html">DDOS 攻击的防范教程</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-HTTP首部&quot;&gt;&lt;a href=&quot;#6-HTTP首部&quot; class=&quot;headerlink&quot; title=&quot;6. HTTP首部&quot;&gt;&lt;/a&gt;6. HTTP首部&lt;/h1&gt;&lt;h2 id=&quot;6-1-HTTP报文首部&quot;&gt;&lt;a href=&quot;#6-1-HTTP报文首部&quot; c</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://leslieaibin.github.io/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP-（1-5章）</title>
    <link href="https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%881-5%E7%AB%A0%EF%BC%89/"/>
    <id>https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3Http/%E5%9B%BE%E8%A7%A3HTTP-%EF%BC%881-5%E7%AB%A0%EF%BC%89/</id>
    <published>2020-10-29T12:15:42.000Z</published>
    <updated>2020-10-30T08:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-了解Web及网络基础"><a href="#1-了解Web及网络基础" class="headerlink" title="1.了解Web及网络基础"></a>1.了解Web及网络基础</h1><h2 id="1-1-Web基于HTTP通信"><a href="#1-1-Web基于HTTP通信" class="headerlink" title="1.1 Web基于HTTP通信"></a>1.1 Web基于HTTP通信</h2><p>​        Web使用一种名为HTTP（HyperText Transfer Protocol,超文本传输协议，“超文本转义协议”）的协议作为规范，完成从客户端到服务端等一系列运作流程。而协议是规则的约定。可以说，Web是建立在HTTP协议上通信的。</p><h2 id="1-2-HTTP的诞生"><a href="#1-2-HTTP的诞生" class="headerlink" title="1.2 HTTP的诞生"></a>1.2 HTTP的诞生</h2><h3 id="1-2-1-HTTP的诞生"><a href="#1-2-1-HTTP的诞生" class="headerlink" title="1.2.1 HTTP的诞生"></a>1.2.1 HTTP的诞生</h3><p>​        这一节主要讲 HTTP 的诞生背景，了解 HTTP 协议的诞生背景有利于我们学习理解 HTTP 协议。</p><p><img src="https://raw.githubusercontent.com/leslieAIbin/Picture/main/20201015235336.webp" alt="httpbackground"></p><p>​        HTTP起初的诞生是为了知识共享，最初的设想是借助多文档之间的相互关联行程超文本，连成可相互参阅的WWW（word wide Web,万维网）</p><p>​        现在已经提出了三项构建技术：</p><ul><li>把SGML,即Standard Generalized Markup Language(标准通用标记语言)作为页面的文本标记语言的HTML(HyperText Markup Language,超文本标记语言)</li><li>作为文本传输协议的HTTP</li><li>指定文档所在地址的URL（Uniform Resource Location,统一资源定位符）</li></ul><p>可以看出上面的三项分别构成只是共享的内容（HTML)、知识共享的方式（HTTP传输）和知识共享位置。</p><h3 id="1-2-2-发展缓慢的HTTP"><a href="#1-2-2-发展缓慢的HTTP" class="headerlink" title="1.2.2 发展缓慢的HTTP"></a>1.2.2 发展缓慢的HTTP</h3><p><strong>HTTP/0.9</strong></p><p>​        HTTP诞生于<strong>1990年</strong>，此时还没有正式的标准，此时的HTTP含有HTTP/1.0之前版本的意思所以称为HTTP/0.9</p><p><strong>HTTP/1.0</strong></p><p>​        <strong>1996年5月</strong>，HTTP被正式作为标准，版本被命名为HTTP/1.0。</p><p><strong>HTTP/1.1</strong></p><p>​        <strong>1997年1月</strong>发布了HTTP/1.1版本，至今任然是主流的HTTP协议。</p><p>​        由此可见，作为 Web 文档传输协议的 HTTP 协议版本更新十分缓慢，新一代的 HTTP 2.0 还在制定中，但是要大规模覆盖，还需要假以时日。</p><h2 id="1-3-网络基础TCP-IP"><a href="#1-3-网络基础TCP-IP" class="headerlink" title="1.3 网络基础TCP/IP"></a>1.3 网络基础TCP/IP</h2><p>​        计算机之间要进行通信，需要基本相同的方法，比如如何探测目标，那一边先发起通信，使用什么语言通信，什么时候结束通信等等。所有的这一切都需要事前约定好，所以约定的规则就别成为协议（protocol)。</p><p>​        一种说法认为TCP/IP指的是TCP和IP两种协议，另一种说法认为只在IP协议通信的过程中所用到的协议族的统称，该书偏向后一种说法。</p><h3 id="1-3-1-TCP-IP的分层管理"><a href="#1-3-1-TCP-IP的分层管理" class="headerlink" title="1.3.1 TCP/IP的分层管理"></a>1.3.1 TCP/IP的分层管理</h3><p>​        TCP/IP协议族最重要的一点就是分层管理，通常来说分为四层：<strong>应用层、传输层、网络层和数据链路层</strong>。</p><p>​        分层管理的最大好处就是将各个阶段的书记进行隔离解耦，类似编程时的模块化。处于某一层的应用只需要考虑该层所需要完成的任务，而不用管其他多余的事情。这样做使得各层协议的实现变得自由了，要修改某一层的协议时，只需要修改该层的协议而不用设计到其他层级的协议。</p><p>各层的作用如下：</p><ul><li><strong>应用层</strong>     决定向用户提供应用服务时的通信活动。HTTP、FTP（File Transfer Protocol,文件传输协议）和DNS（Domain Name System,域名解析系统）都属于该层。</li><li><strong>传输层</strong>    相较于上一层的应用层，该层提供处于网络连接中的两台计算机的数据传输。该层协议主要是TCP（Transmission Control Protocol) 和 UDP（User Data Protocol)。</li><li><strong>网络层</strong>    用于处理网络上流动的数据包（数据传输的最小单位），该层规定了通过怎样的路径到达对方计算机，并将数据传送给对方。该层协议主要是IP协议和APR（Address Solution Protocol)协议。</li><li><strong>链路层</strong>    用于处理网络连接的硬件部分，包括操作系统，设备驱动等，硬件上的范畴基本都在链路层的范围内。该层主要洗衣为以太网协议（Ethernet)</li></ul><h3 id="1-3-2-TCP-IP通信传输流"><a href="#1-3-2-TCP-IP通信传输流" class="headerlink" title="1.3.2 TCP/IP通信传输流"></a><strong>1.3.2 TCP/IP通信传输流</strong></h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7f659bb6b" alt="httpstream"></p><p>​        利用TCP/IP通信时，会通过分层顺序与对方进行通信。发送方的数据流从上往下走，接收方的数据流从下往上走。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7b2367900" alt="httptransfer"></p><p>​        在传输过程中的每一层中国，都会对数据进行<strong>装箱和拆箱</strong>。发送端在层与层之间传输数据时，每经过一层时，必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。</p><p>​        这种把数据信息包装起来的做法成为封装。</p><h3 id="1-3-3-与-HTTP-关心密切的协议：IP、TCP-和-DNS"><a href="#1-3-3-与-HTTP-关心密切的协议：IP、TCP-和-DNS" class="headerlink" title="1.3.3 与 HTTP 关心密切的协议：IP、TCP 和 DNS"></a>1.3.3 与 HTTP 关心密切的协议：IP、TCP 和 DNS</h3><p><strong>IP 协议</strong></p><p>​        IP协议负责网络传输，处于网络层。IP不是IP地址，我们通常说的IP是一种协议。IP地址指明了节点被分配到的地址，MAC地址是网卡所属的固定地址，每块网卡出厂时，都有一个世界独一无二的MAC地址，长度是48位二进制位，用12个十六进制位数表示。IP地址可以和MAC地址配对，但同一个机器IP地址可能会变，MAC是固定不变的。</p><p>​        IP间的通信依赖MAC地址，实际生活中同一局域网内的网络通信比较少，大部分都是广域网的通信，数据需要经过多个节点路由的转发才能到达目的地。而在中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时会采用ARP协议（Address Resolution Protocol), 根据对方的IP地址即可查出对应的MAC地址，但这个两台设备必须在同一个子网内。</p><p>​        数据在网络中的传输类似于现实生活中的快递传输，中转设备就类似于物流中转中心。快递到达一个中转站之后，中转站会哦按标段下一个中转站的地址然后接续派送，直到到达客户所在的中转站。</p><p><strong>TCP协议</strong></p><p>​        TCP 位于传输层，提供可靠的字节流服务。</p><p>​        字节流服务（Byte Stream Service）是指为了传输方便，把大块的数据切割成以报文段（segment）为单位的数据包进行管理。TCP 的可靠之处在于它会确保数据被送到了接收方。</p><p>​        为了确保数据被准确无误地送到了接收方，TCP 采用了三次握手（three-way handshaking）的策略。握手过程中包含了两个重要的标志（flag）——SYN（synchronize）和 ACK（acknowledgement）。</p><p>​        发送端会先发送一个带有 SYN 的数据包给对方，接收端接收到数据之后返回一个 带有 SYN/ACK 标志的数据包给发送端，最后发送端再传回一个带有 ACK 标志的数据包表示“握手”结束。如果握手意外结束，那么 TCP 协议会再次以相同的顺序发送相同的数据包。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7c3199713" alt="tcphandshaking"></p><p>​        除了以上三次握手，TCP 还有其他方法确保可靠性。</p><p><strong>DNS</strong></p><p>​        DNS 也位于应用层，它提供域名解析服务。能够把域名解析为 IP 地址。</p><p>​        各种协议与 HTTP 之间的关系：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7cd972a8c" alt="relationship"></p><h3 id="1-3-4-URI-和URL"><a href="#1-3-4-URI-和URL" class="headerlink" title="1.3.4 URI 和URL"></a>1.3.4 URI 和URL</h3><p>​        URI（Uniform Resource Identifier，统一资源标识符）RFC2396 对名称中的三个单词做了解释：</p><ul><li><p>Uniform，规定统一的格式可方便处理不同的资源，而不用根据上下文环境来识别资源指定的访问方式，另外加入新的协议（http、ftp）也更容易。</p></li><li><p>Resource，指任何可标识的东西。不仅限于文档、图片或服务。</p></li><li><p>Identifier，表示可标识的对象，也称为标识符。</p><p>除了 HTTP 外，URI 还可以使用 mailto、ftp、telnet 等协议方案。</p><p>URI 用字符串标识某一互联网资源，而 URL 用字符串标识资源的地点。所以 URL 是 URI 的子集。</p></li></ul><p><strong>URI 的格式</strong></p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000a7ae4bccff" alt="urlformat"></p><p>其中：</p><ul><li><strong>登录信息（认证）</strong> 指定用户名密码作为从服务端获取资源时的登录信息，此项可选。</li><li><strong>服务器地址</strong>，可以是域名、IP。</li><li><strong>服务器端口号</strong>，指定服务器连接的网络端口号，此项可选，省略时用默认端口号。</li><li><strong>带层次的文件路径</strong>，指定服务器上资源的文件路径。</li><li><strong>查询字符串</strong>，通过查询字符串可以传入参数。</li><li><strong>片段标识符</strong>，指定已获取资源中的子资源（文档内的某个位置）。</li></ul><h1 id="2-简单的HTTP协议"><a href="#2-简单的HTTP协议" class="headerlink" title="2. 简单的HTTP协议"></a>2. 简单的HTTP协议</h1><p>在两台计算机之间使用HTTP协议进行通讯时，在一条通讯线路上必定有一端是客户端，另一端则是服务器端。请求访问文本或图像等资源的一端成为客户端，而提供资源相应的一端成为服务器端。HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p><h2 id="2-1-请求和相应报文的组成"><a href="#2-1-请求和相应报文的组成" class="headerlink" title="2.1 请求和相应报文的组成"></a>2.1 请求和相应报文的组成</h2><p>某个客户端发出的请求如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.htm HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure><p>其中，GET表示请求访问服务器的类型，称为方法（Method)。随后的字符串/index.htm表示请求访问的资源对象，也叫做请求URL。最后的HTTP/1.1表示有所使用的HTTP版本号，用于提示客户端所使用的HTTP版本。</p><p>所以上面这段请求表示使用GET方法请求hackr.jp服务器上的Index.htm资源，客户端使用的是HTTP版本是1.1.</p><p><strong>总结而言</strong>  请求报文是由请求方法，请求URL，协议版本，可选的请求首部字段和内容实体构成的。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000cf6d936261" alt="requestcontent"></p><p>上图 解释了请求报文的组成。</p><p>接收到请求的服务器，返回了如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Tue, <span class="number">10</span> Jul <span class="number">2012</span> <span class="number">06</span>:<span class="number">50</span>:<span class="number">15</span> GMT</span><br><span class="line">Content-Length: <span class="number">362</span></span><br><span class="line">Content-Type: text/html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其中，HTTP/1.1 表示服务器对应的 HTTP 版本；后面的200K 表示请求的处理结果的状态码（status code）。下一行表示响应创建的时间，是响应首部字段（header field）的一个属性。空一行之后的内容表示资源主体的实体（entity body）。</p><p>总结：<strong>响应报文基本上由协议版本、状态码（表示请求成功或者失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成</strong>。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c000cf6c6630a4" alt="responsecontent"><br>    上图是响应报文的组成。</p><h2 id="2-2-HTTP-是无状态协议"><a href="#2-2-HTTP-是无状态协议" class="headerlink" title="2.2 HTTP 是无状态协议"></a>2.2 HTTP 是无状态协议</h2><p>HTTP 是一种不保存状态，即无状态（stateless）的协议。HTTP 自身不对请求和响应之间的通信状态进行保存。每次有新的请求建立时，就会有对应的响应产生，与之前或者之后的请求都没有任何关系。</p><p>HTTP 的无状态特点，既有好处也有坏处。好处在于无状态的特点使得 HTTP 不用维护客户端状态，大大简化了协议内容和服务器的工作，确保了协议的可伸缩性。坏处在于随着 Web 的发展，网站应用越来越复杂，无状态的协议需要通过其他手段维持客户端状态（登录信息），比如 Cookie 技术，就是从 HTTP 1.1 开始引入的维持状态的手段。</p><h2 id="2-3-告知服务器意图的HTTP方法"><a href="#2-3-告知服务器意图的HTTP方法" class="headerlink" title="2.3 告知服务器意图的HTTP方法"></a>2.3 告知服务器意图的HTTP方法</h2><p>HTTP 1.1 主要包含了以下可以使用的方法。</p><ul><li><p><strong>GET方法</strong>用来请求访问已被URL识别的资源。指定的资源经过服务器解析后返回响应内容。</p></li><li><p><strong>POST方法</strong>用来传输实体的主体。虽然用GET的方法也可以传输实体的主体，但是一般不用GET方法。虽说POST方法的功能和GET相似，但是POST的主要目的并不是获取响应的主体内容。</p></li><li><p><strong>DELETE</strong> 方法主要用于删除服务器上的文件，与 PUT 相反，DELETE 方法删除 URI 指定的服务器文件。同样由于存在安全隐患，所以一般不采用 DELETE 方法。</p></li><li><p><strong>HEAD</strong> 方法主要用于确认 URI 的有效性及资源更新的日期时间等，不会返回报文的主体内容。</p></li><li><p><strong>OPTIONS</strong> 方法用来查询针对请求 URI 指定的资源所支持的方法。</p></li><li><p><strong>TRACE</strong> 方法用来追踪路径，发送请求时，在请求首部字段中加入 <code>Max-Forwards</code> 字段，值为数字，每经过一个服务器，该字段就会减一，当到达某个使该字段为 0 的服务器时，就会返回状态码为 200 OK 的响应。通过 TRACE 方法可以查询发送出去的请求是怎样被加工/篡改的。TRACE 方法本身使用场景较少，而且存在跨站追踪攻击的隐患，所以使用场景更加少了。</p></li><li><p><strong>CONNECT</strong> 方法表示要求用隧道协议连接代理。在与代理服务器通信时，实现用隧道协议进行 TCP 通信，主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201016233414113.png" alt="image-20201016233414113"></p></li></ul><p><strong>GET 相对 POST 的优势是什么</strong></p><p>最大的优势是， GET 的URL可以人肉手输啊。。。你在地址栏打个POST给我看看。本质上面， GET 的所有信息都在URL， 所以很方便的记录下来重复使用。</p><p>所以如果你希望<br>                －  请求中的URL可以被手动输入<br>                － 请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。<br>                － 请求中的URL是可以被搜索引擎收录的。<br>                － 带云压缩的浏览器，比如Opera mini/Turbo 2, 只有GET才能在服务器端被预取的。<br>                － 请求中的URL可以被缓存。</p><p>请使用GET. </p><p>大家有没有注意到，其实这里面很多方面的要求是和网站的运营相关的，而不是技术相关的。任何的技术行为中，其实多多少少都能看到商业的影子。</p><p>反之，就用POST. 特别是有一些东西你是不想让人家可以在浏览器地址栏里面可以输入的。比如，如果你设计一个blog系统, 设计这样一个URL来删掉所有帖子。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://myblog.com/?action=delete_all</span><br></pre></td></tr></table></figure><p>我只能说很快你就知道什么叫不作死就不会死这个道理了，搜索引擎的爬虫分分钟教你做人。另外一个准则是，可以重复的交互，比如取个数据，跳个页面， 用GET不可以重复的操作， 比如创建一个条目/修改一条记录， 用POST, 因为POST不能被缓存，所以浏览器不会多次提交.</p><h2 id="2-4-持久连接"><a href="#2-4-持久连接" class="headerlink" title="2.4 持久连接"></a>2.4 持久连接</h2><p>我们知道HTTP协议基于TCP协议，而TCP协议每次建立之前都会进项“三次握手”，所以如果每次发送HTTP请求都要建立TCP连接的话，会造成过多的“握手”浪费服务器资源。而HTTP协议的初始版本中，每次HTTP通信都需要建立TCP请求，这个是一个很大的缺点。</p><p>为了解决的而上述问题，HTTP1.1引入了持久连接（HTTP Persistent Connections,也成为HTTP keep-alive 或者 HTTP connection reuse)。持久连接的特点是只要任意一方没有提出断开TCP连接，就会一直维持TCP的连接状态。</p><p>持久连接的好处杂鱼减少了TCP连接的重复建立和断开所造成的额外开销，减轻了么服务器的负载。在HTTP1.1中，所哟普的连接默认都是持久连接。</p><h2 id="2-5-管线化"><a href="#2-5-管线化" class="headerlink" title="2.5 管线化"></a>2.5 管线化</h2><p>持久连接使得多数请求以管线化（pipeline)方式成为可能，以前发送请求后需要等待响应之后次啊能发送下一个请求，但是管线化技术出现后，不用等待响应，就可以发送下一个请求。这样能够做到多个请求并行发送，大大减少了页面加载的时间。</p><h2 id="2-6-使用Cookie管理状态"><a href="#2-6-使用Cookie管理状态" class="headerlink" title="2.6 使用Cookie管理状态"></a>2.6 使用Cookie管理状态</h2><p>之前提到过 HTTP 是无状态协议，我们通过 Cookie 维持客户端状态。</p><p>Cookie 会根据从服务端发送的响应报文内的一个叫做 <code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><p>服务器发现从客户端发送过来的 Cookie 之后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p>设置 Cookie 的响应报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Thu, <span class="number">12</span> Jul <span class="number">2012</span> <span class="number">07</span>:<span class="number">12</span>:<span class="number">20</span> GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid=<span class="number">1342077140226724</span>; path=/; expires=Wed,</span><br><span class="line"><span class="number">10</span>-Oct-<span class="number">12</span> <span class="number">07</span>:<span class="number">12</span>:<span class="number">20</span> GMT&gt;</span><br><span class="line">Content-Type: text/plain; charset=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>携带有 Cookie 信息的请求报文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /image/ HTTP/<span class="number">1.1</span></span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=<span class="number">1342077140226724</span></span><br></pre></td></tr></table></figure><h1 id="3-HTTP报文内的HTTP信息"><a href="#3-HTTP报文内的HTTP信息" class="headerlink" title="3. HTTP报文内的HTTP信息"></a>3. HTTP报文内的HTTP信息</h1><h2 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h2><p>用于HTTP协议交互的信息被称为HTTP报文，客户端的HTTP报文叫做请求报文，服务端的叫做响应报文。</p><p>HTTP报文大致可分为报文首部和报文主体两块，两者通过空行划分（CR+LF),通常并不一定要有报文主体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CR：Carriage Return，回车符，<span class="number">16</span> 进制的 <span class="number">0x0d</span></span><br><span class="line"></span><br><span class="line">LF：Line Feed，换行符，<span class="number">16</span> 进制的 <span class="number">0x0a</span></span><br></pre></td></tr></table></figure><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c00170b6e361f3" alt="httpbody"></p><p>下图展示了请求报文和响应报文的结构：</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c00170b429fc43" alt="bodystructure"></p><p>其中：</p><ul><li>请求行 包括用于请求的方法，请求URL和HTTP版本</li><li>状态行 包含表明响应结果的状态码，原因短语和HTTP版本</li><li>首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般抱哈通用首部，请求首部，响应首部和实体首部。</li><li>其他 包含一些未在RFC中的定义的首部（Cookie等）</li></ul><h2 id="3-2-通过编码提升传输速度"><a href="#3-2-通过编码提升传输速度" class="headerlink" title="3.2 通过编码提升传输速度"></a>3.2 通过编码提升传输速度</h2><p>HTTP在传输时可以按照原始数据直接传输，也可以预先将数据进行压缩后在传输。编码压缩后可以减少传输的数据量，能够提升传输速率，但是压缩过程会消耗更多的CPU资源。</p><h3 id="3-2-1-报文主体和实体主体的差异"><a href="#3-2-1-报文主体和实体主体的差异" class="headerlink" title="3.2.1  报文主体和实体主体的差异"></a>3.2.1  报文主体和实体主体的差异</h3><ul><li>报文（message) 是HTTP通信过程中的基本单位，由八位组字节流组成，通过HTTP传输。</li><li>实体（entiy) 作为请求或者相应的有效载荷数据被传输，其内容由实体首部和实体主体构成。</li></ul><p>HTTP报文的主体用于传输实体的主体（请求或者响应的）</p><p>通常情况下，报文主体就是实体主体。但是在进行编码压缩时，实体主体部分会被编码，导致与报文主体不同。</p><h3 id="3-2-2-压缩传输的内容编码"><a href="#3-2-2-压缩传输的内容编码" class="headerlink" title="3.2.2 压缩传输的内容编码"></a>3.2.2 压缩传输的内容编码</h3><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，压缩之后的内容在客户端被接受之后会进行解码还原。</p><p>常用的内容编码有以下几种：</p><ul><li><p>GZIP (GNU zip)</p></li><li><p>compress (UNIX系统的标准压缩)</p></li><li><p>deflate (zlib)</p></li><li><p>identity (不进行编码)</p></li></ul><p>现在还有一种新型的优秀算法——Brotli，但是目前还没有被广泛采用。</p><h3 id="3-2-3-分块传输编码"><a href="#3-2-3-分块传输编码" class="headerlink" title="3.2.3 分块传输编码"></a>3.2.3 分块传输编码</h3><p>在传输容量数据是，通过把数据分块成多块，能够让浏览器初步显示页面。这种功能称为分块传输编码（Chunked Transfer Coding)。</p><p>分块传输会将实体主体分割成多个块（chunk）来传输，每一个块都用十六进制来标记块的大小，而实体主体的最后一块会使用’0 (CR+LF)’ 来标记。</p><h2 id="3-3-发送多种数据的多部分对象集合"><a href="#3-3-发送多种数据的多部分对象集合" class="headerlink" title="3.3 发送多种数据的多部分对象集合"></a>3.3 发送多种数据的多部分对象集合</h2><p>邮件附件能够同时传送多种内容的数据，是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多种类型的数据。相应的，HTTP 也采纳了部分多部分对象集合。</p><p>多部分对象集合包含的对象如下：</p><ul><li>multipart/from-data: 在Web表单上传使用。</li><li>multipart/byteranges：状态码206(Partial Content，部分内容)响应报文包含了多个范围的内容时使用。</li></ul><p>可以通过制定Content-Type 请求头来使用多部分对象结合。</p><h2 id="3-4-获取部分内容的范围请求"><a href="#3-4-获取部分内容的范围请求" class="headerlink" title="3.4 获取部分内容的范围请求"></a>3.4 获取部分内容的范围请求</h2><p>指定范围发送的请求叫做范围请求（Range Request)。</p><p>对于一份10000字节大小的资源，可以通过范围请求一次只请求5001—10000字节的资源。</p><p>执行范围请求时，会通过Range首部字段来指定资源的byte范围，比如：</p><ul><li><p>5000—10000字节：</p><p>Range: bytes = 5001-10000</p></li><li><p>5000字节之后的所有内容：</p><p>Range: bytes = 5000-</p></li><li><p>从1开始到30000字节和5000字节到7000字节：</p><p>Range: byte=0-3000,5000-7000</p></li></ul><p>针对范围请求，响应会返回状态码为206 Partial Content的响应报文</p><p>对于多重范围的范围请求，响应会在首部字段Content-Tupe标明，multipart/byteranges后返回。</p><h2 id="3-5-内容协商发返回最合适的内容"><a href="#3-5-内容协商发返回最合适的内容" class="headerlink" title="3.5 内容协商发返回最合适的内容"></a>3.5 内容协商发返回最合适的内容</h2><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。</p><p>内容协商会以语言、字符集、编码方式等为基准判断响应的资源。</p><p>包含在请求报文中的一些首部字段就是服务端响应的判断标准：</p><ul><li><strong>Accept</strong></li><li><strong>Accept-Charset</strong></li><li><strong>Accept-Encoding</strong></li><li><strong>Accept-Language</strong></li><li><strong>Content-Language</strong></li></ul><h1 id="4-HTTP状态码"><a href="#4-HTTP状态码" class="headerlink" title="4. HTTP状态码"></a>4. HTTP状态码</h1><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，我们可以了解这次请求是否在服务器端得到正确的处理。</p><p>状态码可有分为五种：</p><table><thead><tr><th></th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td>1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接受的请求正在处理</td></tr><tr><td>2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td>3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td>5XX</td><td align="center">Server Error（服务端错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><p>下面介绍一下常用的一些状态码。</p><h2 id="4-1-2XX-成功"><a href="#4-1-2XX-成功" class="headerlink" title="4.1 2XX 成功"></a>4.1 2XX 成功</h2><ul><li><p><strong>200 OK</strong></p><p>表示从客户端发送的请求被服务器正常处理了</p></li><li><p><strong>204 No Content</strong> </p><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p></li><li><p><strong>206 Partial Content</strong></p><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的GET请求。响应报文中包含了有Contenet-Range指定范围的实体内容。</p></li></ul><h2 id="4-2-3XX-重定向"><a href="#4-2-3XX-重定向" class="headerlink" title="4.2 3XX 重定向"></a>4.2 3XX 重定向</h2><p>3XX响应状态码表示浏览器需要执行某些特殊的处理以正确处理请求。</p><ul><li><p><strong>301 Moved Permanently</strong></p><p>永久性重定向。</p><p>该状态码表示请求的资源已经被分配到新的URI,以后应使用资源指定的URI。新的URI会在HTTP响应头中的Location首部字段指定。</p></li><li><p><strong>302 Found</strong></p><p>临时重定向。</p><p>该状态码表示请求的资源被分配到了新的URI，希望本次能使用新的URI访问资源。和301 Moved Permanently 状态码相似，但是302 代表的资源不是被永久重定向，只是临时性质的。</p></li><li><p><strong>303 See Other</strong></p><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303状态码和302Found状态码有着相似的功能，但是303状态码明确表示客户端应当采用GET方法获取资源。</p><p>当301、302、303响应状态码返回时，几乎所有的浏览器都会吧POST改成GET，并删除清秋月报文内的主体，之后请求会再次自动发送。301、302标准是进制将POST方法变成GET方法的，但实际大家都会这样做。</p></li><li><p><strong>304 Not Modified</strong></p><p>该状态码表示客户端发送附带条件的请求时（GET 请求包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部）服务端允许访问请求访问资源，但因为请求没有满足条件，所以发生 304 Not Modified 重定向，直接使用客户端缓存的资源。</p></li><li><p><strong>307 Temporary Redirect</strong></p><p>临时重定向。</p><p>该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p></li><li><p><strong>307 会遵守浏览器标准，不会从 POST 变成 GET</strong>。</p><p>但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。</p></li></ul><h2 id="4-3-4XX客户端错误"><a href="#4-3-4XX客户端错误" class="headerlink" title="4.3  4XX客户端错误"></a>4.3  4XX客户端错误</h2><p>​    4XX的结果表明客户端是发生错误的原因所在</p><ul><li><p><strong>400 Bad Request</strong></p><p>该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。</p></li><li><p><strong>401 Unauthorized</strong></p><p>该状态码表示请求需要通过认证。</p></li><li><p><strong>403 Forbidden</strong></p><p>该状态码表明请求资源的访问被服务器拒绝，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明</p></li><li><p><strong>404 Not Found</strong></p><p>该状态码表明服务器尚无法找到请求的资源。</p></li></ul><h2 id="4-4-5XX服务端错误"><a href="#4-4-5XX服务端错误" class="headerlink" title="4.4 5XX服务端错误"></a>4.4 5XX服务端错误</h2><p>5XX的响应结果表明服务端本省发生了错误</p><ul><li><p><strong>500 Internet Server Error</strong> </p><p>该状态码表明服务端在执行请求时存在错误，越有可能是web应用存在Bug或者某些临时故障</p></li><li><p><strong>503 Service Unavailable</strong></p><p>该状态码表明服务器暂时处于超负载或者正在进行停机维护，现在无法处理请求。</p></li></ul><h1 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5. Web服务器"></a>5. Web服务器</h1><h2 id="5-1-用单台虚拟机实现多个域名"><a href="#5-1-用单台虚拟机实现多个域名" class="headerlink" title="5.1 用单台虚拟机实现多个域名"></a>5.1 用单台虚拟机实现多个域名</h2><p>基于虚拟主机的功能，可以只使用一台物理机实现多个域名的网站部署，在互联上，域名通过DNS域名解析系统可以映射到具体的IP上，多个域名可以映射到同一个IP，但是一个域名只能映射到一个IP上。如果服务器想知道请求来自哪个域名，可以通过请求头中的Host首部字段获取。</p><h2 id="5-2-代理、网关和隧道"><a href="#5-2-代理、网关和隧道" class="headerlink" title="5.2 代理、网关和隧道"></a>5.2 代理、网关和隧道</h2><p>HTTP通信时，除了服务端和客户端以外，还有一些用于通信数据转发处理的应用程序，例如代理、网关和隧道。他们可以配合服务器工作。</p><ul><li>代理是一种具有转发功能的应用程序，扮演着服务器和客户端的中间人的角色。代理接受客户端的请求转发给服务器，然后接受服务器的响应转发给客户端。</li><li>网管是转发其他服务器通信数据的服务器，接受从客户端发送来的请求时，他就想自己拥有资源的源服务器一样对请求进行处理。</li><li>隧道是在相隔甚远的客户端和服务器之间进行中转并保存双方连接的应用程序。</li></ul><h3 id="5-2-1-代理"><a href="#5-2-1-代理" class="headerlink" title="5.2.1 代理"></a>5.2.1 代理</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a37a349072" alt="webproxy"></p><p>代理服务器的基本行为就是在客户端和服务端之间转发请求和响应，代理不改变请求 URI，会直接发送给持有资源的服务器（称为<strong>源服务器</strong>）。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a380be8c6c" alt="multihttpproxy"></p><p>每次通过代理转发请求或者响应时，会追加写入 Via 首部字段，该字段会标记处经过的代理主机信息。</p><p>使用代理服务器的理由包括利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，获取访问日志等。</p><p>代理的使用方式可以按照是否使用缓存和是否修改报文来进行分类。</p><p><strong>缓存代理</strong>：代理转发响应时，会把资源保存在代理服务器上，当代理再接收到相同的资源请求时，会返回之前缓存的资源。</p><p><strong>透明代理</strong>：转发请求或者响应时，不对报文进行任何修改的代理类型称为透明代理，反之称为非透明代理。</p><h3 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2 网关"></a>5.2.2 网关</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a377ec7432" alt="httpgateway"></p><p>网关的工作机制和代理十分相似，但是网管可以使通信线路上的服务器提供非HTTP协议服务。</p><p>利用网关能提高通信的安全性，因为可以再客户端和网关之间的通信线路上加密以确保连接的安全性。</p><h3 id="5-2-3-隧道"><a href="#5-2-3-隧道" class="headerlink" title="5.2.3 隧道"></a>5.2.3 隧道</h3><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/image-20201018191451384.png" alt="image-20201018191451384"></p><p>隧道可以按照要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。<strong>隧道的目的是确保客户端与服务端能够进行安全的通信</strong></p><h2 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h2><p>缓存是指代理服务器或者客户端本地磁盘内保存的资源副本。利用缓存可以减少对源服务器的访问，可以减少通信流量和通信时间，缓存服务器是代理服务器的一种，并归类在缓存代理类型中。</p><h4 id="5-3-1-缓存的有效期限"><a href="#5-3-1-缓存的有效期限" class="headerlink" title="5.3.1 缓存的有效期限"></a>5.3.1 缓存的有效期限</h4><p>即使存在缓存，也会因为客户端的要求，缓存的有效期等因素向源服务器确认资源的有效性。若缓存失效，缓存服务器会再次向源服务器获取’新的’资源。</p><p><img src="http://test-1874253.oss-cn-beijing.aliyuncs.com/img/16c001a3846040ad" alt="httpcache"></p><h3 id="5-3-2-客户端缓存"><a href="#5-3-2-客户端缓存" class="headerlink" title="5.3.2 客户端缓存"></a>5.3.2 客户端缓存</h3><p>除了带来服务器内的缓存以外，客户端的浏览器也可以缓存。同时的客户端也会向源服务器确定资源的有效性，然后再返回有效的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-了解Web及网络基础&quot;&gt;&lt;a href=&quot;#1-了解Web及网络基础&quot; class=&quot;headerlink&quot; title=&quot;1.了解Web及网络基础&quot;&gt;&lt;/a&gt;1.了解Web及网络基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-Web基于HTTP通信&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://leslieaibin.github.io/tags/HTTP/"/>
    
    <category term="TCP/IP" scheme="https://leslieaibin.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>从新开始</title>
    <link href="https://leslieaibin.github.io/2020/10/28/Reboot/"/>
    <id>https://leslieaibin.github.io/2020/10/28/Reboot/</id>
    <published>2020-10-28T12:15:42.000Z</published>
    <updated>2020-10-30T08:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="天下熙熙，皆为利来；天下攘攘，皆为利往。"><a href="#天下熙熙，皆为利来；天下攘攘，皆为利往。" class="headerlink" title="天下熙熙，皆为利来；天下攘攘，皆为利往。"></a>天下熙熙，皆为利来；天下攘攘，皆为利往。</h2><p>周书曰：「农不出则乏其食，工不出则乏其事，商不出则三宝绝，虞不出则财匮少。」财匮少而山泽不辟矣。此四者，民所衣食之原也。原大则饶，原小则鲜。上则富国，下则富家。贫富之道，莫之夺予，而巧者有馀，拙者不足。故太公望封於营丘，地潟卤，人民寡，於是太公劝其女功，极技巧，通鱼盐，则人物归之，繦至而辐凑。故齐冠带衣履天下，海岱之间敛袂而往朝焉。其後齐中衰，管子修之，设轻重九府，则桓公以霸，九合诸侯，一匡天下；而管氏亦有三归，位在陪臣，富於列国之君。是以齐富彊至於威、宣也。</p><p>故曰：「仓廪实而知礼节，衣食足而知荣辱。」礼生於有而废於无。故君子富，好行其德；小人富，以適其力。渊深而鱼生之，山深而兽往之，人富而仁义附焉。富者得埶益彰，失埶则客无所之，以而不乐。夷狄益甚。谚曰：「千金之子，不死於市。」此非空言也。故曰：「天下熙熙，皆为利来；天下壤壤，皆为利往。」夫千乘之王，万家之侯，百室之君，尚犹患贫，而况匹夫编户之民乎！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;天下熙熙，皆为利来；天下攘攘，皆为利往。&quot;&gt;&lt;a href=&quot;#天下熙熙，皆为利来；天下攘攘，皆为利往。&quot; class=&quot;headerlink&quot; title=&quot;天下熙熙，皆为利来；天下攘攘，皆为利往。&quot;&gt;&lt;/a&gt;天下熙熙，皆为利来；天下攘攘，皆为利往。&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
