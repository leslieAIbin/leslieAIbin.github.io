<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Ai</title>
  
  <subtitle>天下熙熙，皆为利来；天下攘攘，皆为利往</subtitle>
  <link href="https://leslieaibin.github.io/atom.xml" rel="self"/>
  
  <link href="https://leslieaibin.github.io/"/>
  <updated>2020-10-30T03:02:55.662Z</updated>
  <id>https://leslieaibin.github.io/</id>
  
  <author>
    <name>Leslie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://leslieaibin.github.io/2020/10/30/hello-world/"/>
    <id>https://leslieaibin.github.io/2020/10/30/hello-world/</id>
    <published>2020-10-30T03:02:55.661Z</published>
    <updated>2020-10-30T03:02:55.662Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络（六）网络安全</title>
    <link href="https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2020-10-29T12:34:18.000Z</published>
    <updated>2020-10-30T03:12:06.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><ol><li> 机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密</li><li> 报文完整性（message integrity） 确保没有被改动</li><li> 端点鉴别（end-point authentication） 确定通信双方</li><li> 运行安全性（operational security）  </li></ol><h2 id="密码学的原则"><a href="#密码学的原则" class="headerlink" title="密码学的原则"></a>密码学的原则</h2><p>明文（plaintext， clear text）<br>密文（cipher text）<br>密钥（key）<br>加密算法（encryption algorithm）<br>解密算法（decryption algorithm）</p><h3 id="对称密钥密码体制-（symmetric）"><a href="#对称密钥密码体制-（symmetric）" class="headerlink" title="对称密钥密码体制 （symmetric）"></a>对称密钥密码体制 （symmetric）</h3><p>对称性加密，也叫共享密钥密码。用相同的密钥进行加密和解密。</p><p>有很多优秀的对称加密算法。在算法上无懈可击，拥有巨大的密钥空间，基本无法暴力破解而且加密过程快速。</p><p>但是，一切对称加密算法的软肋在于密钥的配送。可以用密钥交换算法或非对称加密算法。</p><h4 id="Diffie-Hellman密钥交换算法"><a href="#Diffie-Hellman密钥交换算法" class="headerlink" title="Diffie-Hellman密钥交换算法"></a>Diffie-Hellman密钥交换算法</h4><ol><li> Alice 和 Bob 协商出两个数字 N 和 G 作为生成元</li><li> 现在 Alice 和 Bob 心中各自想一个数字出来，分别称为 A 和 B</li><li> 现在 Alice 将自己心里的这个数字 A 和 G 通过某些运算得出一个数 AG，然后发给 Bob；Bob 将自己心里的数 B 和 G 通过相同的运算得出一个数 BG，然后发给 Alice</li><li> Alice 可以通过 BG 和自己的 A 通过某些运算得到一个数 ABG，Bob 也可以通过 AG 和自己的 B 通过某些运算得到 ABG，这个数就是 Alice 和 Bob 共有的秘密</li></ol><h3 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h3><p>公钥用于加密，私钥用于解密。（RSA）</p><p>但是非对称加密算法无法确定通信双方的身份，会遭到中间人的攻击。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的 Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。</p><h3 id="报文完整性和数字签名"><a href="#报文完整性和数字签名" class="headerlink" title="报文完整性和数字签名"></a>报文完整性和数字签名</h3><h4 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h4><p>密码散列函数的附加性质：找到任意两个不同的报文x和y使得<code>$H(x)=H(y)$</code>,在计算上是不可能的。</p><p>报文鉴别码：</p><ol><li> Alice生成报文m并计算散列<code>$H(m)$</code></li><li> 然后Alice将<code>$H(m)$</code>附加到报文m上，生成一个扩展报文（m, H(m)),并将该扩展报文发给Bob</li><li> Bob接收到一个扩展报文（m，h）并计算<code>$H(m)$</code>，如果<code>$H(m)=h$</code>,Bob会认为一切正常。</li></ol><p>缺陷： 其他人可以生成虚假报文（m’, H(m’)),Bob无法发现这种行为。</p><p>为解决这种缺陷，需要鉴别密钥（authentication key），共享秘密s。</p><ol><li> Alice生成报文m, 用s级联m以生成m+s，并计算散列<code>$H(m+s)$</code>。<code>$H(m+s)$</code>称为<strong>报文鉴别码</strong>（Message Authentication Code，MAC）</li><li> 然后Alice将MAC附加到报文m上，生成一个扩展报文（m, H(m+s)),并将该扩展报文发给Bob</li><li> Bob接收到一个扩展报文（m，h）并计算<code>$H(m+s)$</code>，如果<code>$H(m+s)=h$</code>,Bob会认为一切正常。</li></ol><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名是一种在数字领域表明身份的密码技术。</p><p>用私钥加密数据，然后把加密的数据公布出去，这就是数字签名。</p><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>证书就是公钥+签名，由第三方认证机构颁发。<br>证书认证的流程：</p><ol><li> Bob去可信任的认证机构正是本人真实身份，并提供自己的公钥</li><li> Alice想和Bob通信时，先向认证机构请求Bob的公钥，认证机构会将一张证书（bob的公钥以及自己对其公钥的签名）发送给Alice</li><li> Alice检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。</li><li> Alice通过这个公钥加密数据，开始和Bob通信。</li></ol><p>正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份。</p><h3 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h3><p>当HTTP加上加密处理和认证以及完整性保护后就是HTTPS。</p><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（secure socket layer）和TLS（transport layer security）协议代替。</p><p>采用了SSL后，HTTP就有了HTTPS的加密、证书、和完整性保护这些功能。</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E5%92%8CHTTPS.png"></p><h2 id="使用TCP连接安全：SSL"><a href="#使用TCP连接安全：SSL" class="headerlink" title="使用TCP连接安全：SSL"></a>使用TCP连接安全：SSL</h2><p>安全套接字层（Secure Socket Layer）SSL<br>运输层安全性（Transport Layer Security） TLS</p><p>类SSL(和SSL)具有三个阶段：握手、密钥导出和数据传输。</p><h4 id="1-握手"><a href="#1-握手" class="headerlink" title="1.握手"></a>1.握手</h4><p>在握手阶段，Bob需要：<br>    1.  与Alice创建一条TCP连接<br>    2.  验证Alice是真实的Alice<br>    3.  发送给Alice一个主密钥（MS），Bob和Alice持用该主密钥生成SSL会话所需的所有对称密钥</p><h4 id="2-密钥导出"><a href="#2-密钥导出" class="headerlink" title="2.密钥导出"></a>2.密钥导出</h4><p>Alice和Bob用MS生成4个密钥：</p><ul><li><code>$E_B$</code>,用于从Bob发送到Alice的数据的会话加密密钥</li><li><code>$M_B$</code>,用于从Bob发送到Alice的数据的会话MAC密钥</li><li><code>$E_A$</code>,用于从Alice发送到Bob的数据的会话加密密钥</li><li><code>$M_A$</code>,用于从Alice发送到Bob的数据的会话MAC密钥</li></ul><h4 id="3-数据传输"><a href="#3-数据传输" class="headerlink" title="3.数据传输"></a>3.数据传输</h4><p>用密钥传输并维护一个序号计数器。防止被人乱序或删除报文。</p><h4 id="4-SSL记录"><a href="#4-SSL记录" class="headerlink" title="4.SSL记录"></a>4.SSL记录</h4><p>由类型字段、版本字段、长度字段、数据字段和MAC字段组成。前三个字段不加密。</p><p>类型字段用于指出该字段是握手报文还是包含应用数据的报文，也用于关闭SSL连接。、</p><p>在接受端的SSL使用长度字段从到达的TCP字节流中提取SSL记录。</p><p>版本字段是自解释的。</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/SSL%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png"></p><h2 id="常见网络攻击"><a href="#常见网络攻击" class="headerlink" title="常见网络攻击"></a>常见网络攻击</h2><h3 id="局域网ARP泛洪与欺骗"><a href="#局域网ARP泛洪与欺骗" class="headerlink" title="局域网ARP泛洪与欺骗"></a>局域网ARP泛洪与欺骗</h3><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>地址解析协议，根据IP地址获取MAC地址的一个网络层协议。</p><ol><li>ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机</li><li>每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包</li><li>ARP接收返回消息，以此确定目标机的MAC地址，与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</li></ol><p>正常的通信是除非一开始mac表中没有目标主机的mac和端口，这样才进行数据广播，只要mac表中有相应的绑定关系，之后两台主机间的通信，都是由交换机直接根据mac和端口绑定进行转发，其他的主机是获取不到这两台主机之间的数据的。</p><h4 id="泛洪"><a href="#泛洪" class="headerlink" title="泛洪"></a>泛洪</h4><p>主机A在自己的ARP缓存中没有找到主机B的IP地址，并且交换机中也没有主机B的信息。交换机会将数据报发送到A所在端口以外的所有端口，这就是泛洪。</p><h4 id="泛洪攻击的实现方法"><a href="#泛洪攻击的实现方法" class="headerlink" title="泛洪攻击的实现方法"></a>泛洪攻击的实现方法</h4><p>泛洪攻击的目标就是想获取主机之间的通信数据。要想达到这个目的，就需要强迫交换机进行数据广播，那就要实现mac表中没有目标主机的mac和端口绑定。</p><p>通过伪造大量的未知mac地址进行通信，交换机进行不断的学习，很快mac表就会被充满，这样正常的主机的mac地址在经过老化之后，就无法再添加到mac地址表中，导致之后的数据都变成了广播。</p><h4 id="欺骗方法"><a href="#欺骗方法" class="headerlink" title="欺骗方法"></a>欺骗方法</h4><p>然后抓取合法的计算机回复自己的mac地址，并将自己IP地址伪装成抓取到的IP地址。</p><p>ARP攻击主要在局域网中，因为ARP包不会跨网络传播。</p><h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h4><ol><li>进行MAC和IP地址进行绑定</li><li>杀毒软件开启arp防火墙</li></ol><h3 id="DDoS（Distributed-Denial-of-Service）"><a href="#DDoS（Distributed-Denial-of-Service）" class="headerlink" title="DDoS（Distributed Denial of Service）"></a>DDoS（Distributed Denial of Service）</h3><p>分布式拒绝服务。攻击者利用多台计算机对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。</p><h4 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h4><ol><li>高防服务器</li><li>黑名单</li><li>DDos清洗，发现一直占用资源，清洗</li><li>CDN加速，隐藏真实IP，分流到各个节点。</li></ol><h3 id="TCP-SYN-Flood-（SYN-泛洪攻击）"><a href="#TCP-SYN-Flood-（SYN-泛洪攻击）" class="headerlink" title="TCP SYN Flood （SYN 泛洪攻击）"></a>TCP SYN Flood （SYN 泛洪攻击）</h3><p>经典的DOS攻击<br>攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段的到来，服务器不断为这些半开连接分配资源，导致服务器的连接资源被消耗殆尽。。</p><h4 id="防御系统"><a href="#防御系统" class="headerlink" title="防御系统"></a>防御系统</h4><p>SYN cookie</p><ol><li> 当服务器接收到SYN报文段时，不分配资源。生成TCP序列号，与源和目的IP地址与端口号以及仅服务器知道的散列函数有关。称为cookie，但服务器不记忆该cookie和其他状态信息，发送回源主机。</li><li> 收到ACK报文段后，通过cookie与ACK验证是否合法，生成连接。</li></ol><h3 id="XSS（Cross-Site-Scripting）-跨站脚本攻击"><a href="#XSS（Cross-Site-Scripting）-跨站脚本攻击" class="headerlink" title="XSS（Cross Site Scripting） 跨站脚本攻击"></a>XSS（Cross Site Scripting） 跨站脚本攻击</h3><p>是最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><p>HTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，<title>与</title>之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。</p><p>常用的XSS攻击手段和目的有：</p><ol><li>盗用cookie，获取敏感信息。</li><li>利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</li><li>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li><li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</li><li>利用虚假输入表单骗取用户个人信息</li><li>显示伪造的文章或图片</li></ol><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><h3 id="OS注入攻击"><a href="#OS注入攻击" class="headerlink" title="OS注入攻击"></a>OS注入攻击</h3><h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.png"><br><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E5%9B%A0%E8%BE%93%E5%87%BA%E5%80%BC%E8%BD%AC%E7%A7%BB%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E.png"><br><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安全通信&quot;&gt;&lt;a href=&quot;#安全通信&quot; class=&quot;headerlink&quot; title=&quot;安全通信&quot;&gt;&lt;/a&gt;安全通信&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt; 机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密&lt;/li&gt;
&lt;li&gt; 报文完整性</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（二）应用层</title>
    <link href="https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://leslieaibin.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-10-29T12:15:42.000Z</published>
    <updated>2020-10-30T03:12:09.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><h4 id="1-客户-服务器体系结构"><a href="#1-客户-服务器体系结构" class="headerlink" title="1.   客户-服务器体系结构"></a>1.   客户-服务器体系结构</h4><pre><code>会出现一台单独的服务器跟不上所有客户请求的情况，需要配备大量主机的数据中心</code></pre><h4 id="2-P2P体系结构"><a href="#2-P2P体系结构" class="headerlink" title="2.   P2P体系结构"></a>2.   P2P体系结构</h4><pre><code>应用程序在间断连接的主机对之间直接通信，对等方。有自扩展性。未来P2P应用由于高度非集中式结构，面临安全性、性能和可靠性挑战。</code></pre><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进行通信的实际上是<strong>进程</strong>，而不是程序。</p><p>在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而通信。</p><h4 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h4><h4 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h4><pre><code>进程通过叫**套接字**的软件接口向网络发送和接受报文。套接字也称为应用程序编程接口（Application Programming Interface，API）</code></pre><h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><pre><code>1.  主机的地址（IP地址）2.  目的主机中接受指定接受进程的标识符（端口号）。</code></pre><h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><pre><code>1. 可靠数据传输2.  吞吐量3. 定时4. 安全性</code></pre><h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><pre><code>1. TCP服务2. UDP服务3. 因特网运输协议所不提供的服务    Tcp可以提供可靠的端到端数据传送，并且可以通过SSL加强以提供安全服务。但是吞吐量和定时服务没有被提供。</code></pre><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>超文本传输协议（HyperText Transfer Protocol） HTTP</p><p>统一资源定位符（Uniform Resource Locator） URL(网页地址)</p><p>统一资源标识符（Uniform Resource Identifier） URI（由某个协议方案标识的资源的定位标识符）</p><p>HTTP使用TCP作为它的支撑运输协议。HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。这是分层体系结构的最大优点。</p><p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议（stateless protocol）</p><h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><ul><li><p>非持续连接<br>  每个请求/响应对是经过一个<strong>单独</strong>的TCP连接发送</p><p>  缺点：</p><ol><li>   必须为每个请求的对象建立和维护一个全新的连接。对每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量。</li><li>   每一个对象经受两倍RTT的交付时间，一个RTT用于建立TCP，另一个RTT用于请求和接受一个对象。</li></ol></li><li><p>持续连接<br>  每个请求/响应对是经过一个<strong>相同</strong>的TCP连接发送</p><p>  对对象的请求可以一个接一个的发出，而不必等待对未决请求的回答。</p></li><li><p>HTTP/1.1 中默认保持持久连接，但是1.0版本的HTTP需要设置 connection:keep-live</p></li></ul><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="HTTP请求报文"></p><p>包括请求行、首部行、空行、实体体</p><p>HTTP请求报文的第一行叫请求行， 有3个字段：方法字段、URL字段、HTTP版本字段。</p><p>使用GET方法是实体体为空，使用POST方法时才使用实体体。</p><p>CR（Carriage Return） 回车符<br>LF（Line Feed） 换行符</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="HTTP响应报文"></p><p>包括状态行、首部行、空行、实体体</p><p>HTTP响应报文的第一行叫状态行，有3个字段： 协议版本字段、状态码字段、相应状态信息。</p><p>实体体部分时报文的主要部分，它包含了所请求的对象。</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP/1.1 协议中定了 9 种方法来表明Request-URL指定资源的不同的操作方式</p><ol><li> OPTIONS 询问支持的方法。返回服务器针对特定资源的HTTP请求方法</li><li> HEAD 获得报文首部。向服务器索要与GET请求一致的响应，而响应体不会被返回</li><li> GET 获取资源。  向特定资源发出请求（GET可能会被爬虫随意访问）</li><li> POST 传输实体主体。 向指定资源提交数据处理的请求（提交表单、上传文件）数据被包含在请求体中。POST可能会导致新建资源或已有资源的修改</li><li> PUT 传输文件。 自身不带验证机制，存在安全性问题。向指定资源上传最新内容</li><li> DELETE 删除文件。与PUT一样，存在安全性问题。请求服务器删除 REQUEST_URL 所标识的资源</li><li> TRACE 追踪路径。回显服务器收到的请求</li><li> CONNECT 在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后将网络隧道传输。</li><li> PATCH 局部修改某一资源</li></ol><p>当请求的资源不支持请求方法时，服务器返回405（Method Nnt Allowed）</p><p>当服务器不认识或不支持方法时，返回501（Not Implement）</p><h5 id="GET-与-POST的区别"><a href="#GET-与-POST的区别" class="headerlink" title="GET 与 POST的区别"></a>GET 与 POST的区别</h5><p><strong>作用</strong> GET用于获取资源，POST用于传输实体主体</p><p><strong>参数</strong>  GET 和POST 都能使用额外的参数，但是GET的参数以查询字符串的方式出现在URL中，这个过程用户可见。而POST的参数存储在实体主体中。因为URL只支持ASCII码，因此GET参数中文会被编码，空格被编码为%20</p><p><strong>安全</strong> 安全的HTTP方法不会改变服务器状态，可以说是只读的</p><p>GET方法安全，POST不是，POST方法传出主题内容，可能是表单数据，服务器可能把其存进数据库中，这样状态就发生了改变。</p><p><strong>幂等性</strong> 幂等性的方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。</p><p>所有安全的方法是幂等的，GET、HEAD、PUT、DELETE应该是幂等的。<br>而post方法不是幂等的。</p><p><strong>其他</strong> GET传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递。</p><p>GET方式只支持ASCII字符，向服务器传输的中文字符可能乱码。post支持标准字符集，可以正确的传递中文字符。</p><h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><h5 id="HTTP首部Request"><a href="#HTTP首部Request" class="headerlink" title="HTTP首部Request"></a>HTTP首部Request</h5><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">客户端能够接受的内容类型</td><td align="center">text/html</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">浏览器可以支持的web服务器返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Accept-Language</td><td align="center">浏览器可以接受的语言</td><td align="center">zh-CN</td></tr><tr><td align="center">Cache-Control</td><td align="center">指定请求和相应遵循的缓存机制</td><td align="center">max-age=0</td></tr><tr><td align="center">Connection</td><td align="center">表示是否需要持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Cookie    HTTP</td><td align="center">请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器</td><td align="center">键值对</td></tr><tr><td align="center">Host</td><td align="center">请求服务器的域名和端口号</td><td align="center"><a href="http://www.baidu.com/">www.baidu.com</a></td></tr><tr><td align="center">Upgrade-Insecure-Requests</td><td align="center">浏览器可以处理HTTPS协议</td><td align="center">1</td></tr><tr><td align="center">User-Agent</td><td align="center">发出请求的用户信息</td><td align="center">Mozilla/5.0</td></tr></tbody></table><h5 id="HTTP首部Response"><a href="#HTTP首部Response" class="headerlink" title="HTTP首部Response"></a>HTTP首部Response</h5><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">告诉所有的缓存机制是否可以缓存及缓存哪种类型</td><td align="center">private</td></tr><tr><td align="center">Connection</td><td align="center">是否保持持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Content-Encoding</td><td align="center">返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Content-type</td><td align="center">返回内容的MIME类型</td><td align="center">text/html charset=utf-8</td></tr><tr><td align="center">Date</td><td align="center">原始服务器消息发出时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Expires</td><td align="center">响应过期的时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Server    Web</td><td align="center">服务器软件名称</td><td align="center">BWS1.1</td></tr><tr><td align="center">Set-Cookie</td><td align="center">设置浏览器缓存</td><td align="center">BDSVRTM=114; path=/</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">文件传输编码</td><td align="center">chunked</td></tr></tbody></table><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>状态码的类别<br> <img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E7%B1%BB%E5%88%AB.jpg"></p><h5 id="100-Containue：收到了请求的初始部分，请客户端继续"><a href="#100-Containue：收到了请求的初始部分，请客户端继续" class="headerlink" title="100 Containue：收到了请求的初始部分，请客户端继续"></a>100 Containue：收到了请求的初始部分，请客户端继续</h5><h5 id="200-Ok-请求被正常处理"><a href="#200-Ok-请求被正常处理" class="headerlink" title="200 Ok: 请求被正常处理"></a>200 Ok: 请求被正常处理</h5><h5 id="204-No-Content：-请求被接受，但是响应报文只有状态行和首部行，不含实体体。"><a href="#204-No-Content：-请求被接受，但是响应报文只有状态行和首部行，不含实体体。" class="headerlink" title="204 No Content： 请求被接受，但是响应报文只有状态行和首部行，不含实体体。"></a>204 No Content： 请求被接受，但是响应报文只有状态行和首部行，不含实体体。</h5><h5 id="206-Partial-Content-客户端进行了范围请求，服务器成功执行了这部分的GET请求"><a href="#206-Partial-Content-客户端进行了范围请求，服务器成功执行了这部分的GET请求" class="headerlink" title="206 Partial Content:客户端进行了范围请求，服务器成功执行了这部分的GET请求"></a>206 Partial Content:客户端进行了范围请求，服务器成功执行了这部分的GET请求</h5><h5 id="301-Moved-Permanently-永久重定向"><a href="#301-Moved-Permanently-永久重定向" class="headerlink" title="301 Moved Permanently 永久重定向"></a>301 Moved Permanently 永久重定向</h5><h5 id="302-Found-临时重定向，资源被临时移动了。"><a href="#302-Found-临时重定向，资源被临时移动了。" class="headerlink" title="302 Found 临时重定向，资源被临时移动了。"></a>302 Found 临时重定向，资源被临时移动了。</h5><h5 id="303-See-Other-表示请求对应的资源代表另一个URI，应该使用GET获取资源"><a href="#303-See-Other-表示请求对应的资源代表另一个URI，应该使用GET获取资源" class="headerlink" title="303 See Other 表示请求对应的资源代表另一个URI，应该使用GET获取资源"></a>303 See Other 表示请求对应的资源代表另一个URI，应该使用GET获取资源</h5><h5 id="304-Not-Modified-当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）"><a href="#304-Not-Modified-当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）" class="headerlink" title="304 Not Modified 当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）"></a>304 Not Modified 当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）</h5><h5 id="307-Temporary-Redirect-临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。"><a href="#307-Temporary-Redirect-临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。" class="headerlink" title="307 Temporary Redirect 临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。"></a>307 Temporary Redirect 临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。</h5><h5 id="400-Bad-Request-请求报文中存在语法错误。"><a href="#400-Bad-Request-请求报文中存在语法错误。" class="headerlink" title="400 Bad Request 请求报文中存在语法错误。"></a>400 Bad Request 请求报文中存在语法错误。</h5><h5 id="401-Unauthorized-请求需要进行认证"><a href="#401-Unauthorized-请求需要进行认证" class="headerlink" title="401 Unauthorized 请求需要进行认证"></a>401 Unauthorized 请求需要进行认证</h5><h5 id="403-Forbidden-请求被服务器拒绝"><a href="#403-Forbidden-请求被服务器拒绝" class="headerlink" title="403 Forbidden 请求被服务器拒绝"></a>403 Forbidden 请求被服务器拒绝</h5><h5 id="404-Not-Found-服务器无法找到对应资源"><a href="#404-Not-Found-服务器无法找到对应资源" class="headerlink" title="404 Not Found 服务器无法找到对应资源"></a>404 Not Found 服务器无法找到对应资源</h5><h5 id="405-Method-Not-Allowed-请求中带有不支持的方法"><a href="#405-Method-Not-Allowed-请求中带有不支持的方法" class="headerlink" title="405 Method Not Allowed 请求中带有不支持的方法"></a>405 Method Not Allowed 请求中带有不支持的方法</h5><h5 id="500-Internet-Server-Error-服务器内部错误"><a href="#500-Internet-Server-Error-服务器内部错误" class="headerlink" title="500 Internet Server Error 服务器内部错误"></a>500 Internet Server Error 服务器内部错误</h5><h5 id="501-Not-Implemented-服务器不认识或不支持对应的请求方法"><a href="#501-Not-Implemented-服务器不认识或不支持对应的请求方法" class="headerlink" title="501 Not Implemented 服务器不认识或不支持对应的请求方法"></a>501 Not Implemented 服务器不认识或不支持对应的请求方法</h5><h5 id="502-Bad-GateWay-代理或网关服务器从下一条链路收到了伪响应"><a href="#502-Bad-GateWay-代理或网关服务器从下一条链路收到了伪响应" class="headerlink" title="502 Bad GateWay 代理或网关服务器从下一条链路收到了伪响应"></a>502 Bad GateWay 代理或网关服务器从下一条链路收到了伪响应</h5><h5 id="503-Server-Unavailable-服务器正忙"><a href="#503-Server-Unavailable-服务器正忙" class="headerlink" title="503 Server Unavailable 服务器正忙"></a>503 Server Unavailable 服务器正忙</h5><h5 id="504-GateWay-Timeout-一个代理网关等待另一服务器超时了"><a href="#504-GateWay-Timeout-一个代理网关等待另一服务器超时了" class="headerlink" title="504 GateWay Timeout 一个代理网关等待另一服务器超时了"></a>504 GateWay Timeout 一个代理网关等待另一服务器超时了</h5><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>HTTP服务器时无状态的，但是一个Web站点通常希望能够识别用户，（限制访问、用户身份）为此使用cookie技术。</p><p>网络服务器用HTTP头向客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。</p><p>cookie技术的4个组件：</p><ol><li> HTTP响应报文中的cookie首部行</li><li> HTTP请求报文中的cookie首部行</li><li> 用户端系统中保留有一个cookie文件，由浏览器进行管理。</li><li> 位于Web站点的后端数据库</li></ol><p>过期时间：</p><ul><li>会话cookie： 若不设置过期时间，表示这个cookie的生命周期未浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie</li><li>持久cookie： 若设置了过期时间，浏览器会把cookie存储到硬盘上（可以拒绝），关闭后在打开这些cookie仍然有效</li></ul><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息</p><p>当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。</p><h4 id="session-id的存储"><a href="#session-id的存储" class="headerlink" title="session_id的存储"></a>session_id的存储</h4><ol><li> 保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session</li><li> 由于cookie可以被人为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符</li><li> 另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id</li></ol><h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><ul><li><h4 id="存取方式不同"><a href="#存取方式不同" class="headerlink" title="存取方式不同"></a>存取方式不同</h4><p>  cookie只能保存ASCII字符，Unicode和二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较难。<br>  而session中能够存取任何类型的数据，十分方便。</p></li><li><h4 id="隐私策略不同"><a href="#隐私策略不同" class="headerlink" title="隐私策略不同"></a>隐私策略不同</h4><p>  cookie存储在客户端浏览器中，对客户可见，客户端可以窥探甚至修改cookie内容。<br>  session存储在服务器上，对用户透明，不存在泄漏风险。<br>  cookie可以像google及百度一样将敏感信息加密后保存，在服务器上进行解密。</p></li><li><h4 id="有效时间不同"><a href="#有效时间不同" class="headerlink" title="有效时间不同"></a>有效时间不同</h4><p>  由于session依赖于session_ID的cookie，而session_id的过期时间默认为-1，关闭浏览器即消失。而cookie可以设置长期的保存。</p></li><li><h4 id="服务器压力不同"><a href="#服务器压力不同" class="headerlink" title="服务器压力不同"></a>服务器压力不同</h4><p>  由于不从的存储方式，存储在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大。</p></li><li><h4 id="浏览器支持不同"><a href="#浏览器支持不同" class="headerlink" title="浏览器支持不同"></a>浏览器支持不同</h4><p>  cookie需要客户端浏览器的支持，假如客户端禁用或不支持cookie，则会话跟踪会失效<br>  假如客户端不支持cookie，就需要运用session及URL地址重写。注意，所有用到session的程序url都要进行重写，否则session会话会失效</p></li><li><h4 id="跨域支持不同"><a href="#跨域支持不同" class="headerlink" title="跨域支持不同"></a>跨域支持不同</h4><p>  cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用<br>  session尽在当前域名有效</p></li></ul><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。</p><h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>条件GET使缓存器证实他的对象是最新的。</p><ol><li> 请求报文中使用GET方法</li><li> 请求报文中包含”If-Modified-Since”首部行</li></ol><p>304 Not Modified 告诉缓存器可以继续使用该对象</p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol><li> HTTPS协议需要CA申请证书，需要缴费</li><li> HTTP是超文本传输协议，明文传输，HTTPS是SSL加密传输</li><li> 80 和443</li><li> HTTP连接很简单，无状态，HTTPS经过SSL+HTTP协议构建的，加密传输，身份认证</li><li> HTTPS耗性能，安全性要求低用HTTP</li></ol><h3 id="CGI（Common-Gateway-Interface）公共网关接口"><a href="#CGI（Common-Gateway-Interface）公共网关接口" class="headerlink" title="CGI（Common Gateway Interface）公共网关接口"></a>CGI（Common Gateway Interface）公共网关接口</h3><p>CGI 是HTTP 中重要的技术之一，有着不可替代的作用。CGI是一个web服务器的标注接口。通过CGI接口Web服务器就能获取客户端提交的信息转交给服务器端的CGI程序处理，最后结果返回给客户端。</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/CGI.png"></p><p>CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。服务器和客户端之间的通信，是浏览器和服务端web服务器的HTTP通信，所以只需知道浏览器执行哪个CGI程序即可.</p><h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件系统由3个主要组成部分：<strong>用户代理（user-agent)**、</strong>邮件服务器（mail server)<strong>、</strong>简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）**</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>25号端口、TCP连接、<br>传输的三个阶段： 握手、传输、关闭连接。</p><h3 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a>与HTTP的对比</h3><p>都是TCP连接，持续的HTTP和SMTP都是持续连接。</p><ol><li>HTTP是一个拉协议，TCP连接由想接受文件的机器发起。SMTP是一个推协议，TCP连接由发送文件的机器发起。</li><li>SMTP要求报文采用7比特ASCII码格式，如果报文包含了非7比特ASCII字符，必须按照7比特ASCII码进行编码。HTTP数据则不受这种限制。</li><li>如何处理一个既包含文本又包含图形的文档。HTTP把每个对象封装到各自的HTTP响应报文中，SMTP则把所有报文对象放在同一个报文之中。</li></ol><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>必须包含From首部行和To首部行。也许Subject首部行</p><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>由于取报文是一个拉操作，而SMTP是一个退协议。所以有邮件访问协议</p><h4 id="第三版邮局协议（Post-Office-Protocol-Version3，POP3）"><a href="#第三版邮局协议（Post-Office-Protocol-Version3，POP3）" class="headerlink" title="第三版邮局协议（Post Office Protocol-Version3，POP3）"></a>第三版邮局协议（Post Office Protocol-Version3，POP3）</h4><h4 id="因特网邮件访问协议（Internet-Mail-Access-Protocol，-IMAP）"><a href="#因特网邮件访问协议（Internet-Mail-Access-Protocol，-IMAP）" class="headerlink" title="因特网邮件访问协议（Internet Mail Access Protocol， IMAP）"></a>因特网邮件访问协议（Internet Mail Access Protocol， IMAP）</h4><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h2 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h2><p>FTP使用两个并行的TCP连接来传输数据，一个TCP（21号端口）被称为控制连接，用来传输FTP命令；一个TCP（20号端口）连接称为数据连接用于传输文件数据。</p><p>因为在FTP协议内，控制信息是通过一个独立的TCP连接传输，所以我们称FTP的控制信息是<strong>带外传送</strong>的，如果控制信息和数据信息通过同一个TCP传输，则称为带内传送</p><p>FTP中控制连接贯穿整个会话，但是数据连接在一个文件开始传输时建立，传输结束后关闭，所以每次传输一个新文件时，都会建立一个数据连接。</p><p>FTP需要在整个会话期间，保留用户的状态，也就是将控制连接同用户账户关联起来，同时记录在远程目录树上的操作，这就限制了FTP可以同时维持的会话总数</p><h2 id="因特网的目录服务：-DNS"><a href="#因特网的目录服务：-DNS" class="headerlink" title="因特网的目录服务： DNS"></a>因特网的目录服务： DNS</h2><h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>主机名到IP地址转换的目录服务。<br>域名系统：（Domain Name System， DNS）</p><p>DNS运行在UDP传输协议之上，使用53号端口</p><p>DNS是：1. 一个由分层的DNS服务器实现的分布式数据库。2.   一个使得主机能够查询分布式数据库的应用层协议。</p><p>DNS采用分布式的设计方案，因为单一的DNS服务器无法解决单点故障，无法保证通信容量以及无法临近所有的查询主机和维护困难等问题。</p><p><strong>根DNS服务器</strong>：因特网上由13个根DNS服务器，每台服务器是一个冗余的计算机网络以*提供安全性和可靠性</p><p><strong>顶级域DNS服务器</strong>：负责顶级域名如com、org、net、edu等以及各个国家顶级域名的转换。</p><p><strong>权威DNS服务器</strong>：因特网上，具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。</p><p><strong>本地DNS服务器</strong>：邻近其所在网络的其他主机。当主机发出DNS请求时，请求被发往本地DNS服务器，起着代理的作用。</p><p><strong>递归查询</strong>：从请求主机到本地DNS服务器的查询是递归的，</p><p><strong>迭代查询</strong>：其余都是迭代的</p><p><strong>DNS缓存</strong>每当DNS服务器发出请求后受到回答时，就将回答的内容缓存在自己的主机空间上。注意有效时间</p><h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><p>p2p体系结构具有良好的自扩展性。这种扩展性的直接成因是对等方除了是比特的消费者之外还是重新分发者。</p><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流</strong></p><p>在一个洪流中的对等方彼此下载等长度的文件<strong>块</strong></p><p>当一个对等方下载文件块的时候，也向其他对等方发送了多个块，一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件。 </p><p>P2P文件共享协议，参与一个特定文件分发的所有对等方结合被称为一个洪流（torrent），在一个洪流的对等方彼此下载等长度的文件块，可以随时离开洪流，也可继续向其他对等方上载。每个洪流都有一个追踪器。</p><p>Alice加入某洪流时，会在追踪器里进行注册，周期性通知追踪器它仍在洪流中。我们称所有与ALICE成功的创建了一个TCP链接的对等方成为邻近对等方。</p><p>洪流随机从参与对等方的结合中选择一个子集，将他们的IP地址发给Alice，Alice维护这张对等方列表，试图与所有对等方建立并行的TCP连接。</p><p>Alice周期询问每个邻近对等方（连上的）他们有的文件块列表，她随时知道邻居有哪些文件块</p><p>Alice使用最稀缺优先技术，首先请求那些邻居们副本数量最少的块，使该文件块迅速分发，以均衡每个块在洪流中的副本数量</p><p>BitTorrent使用一种算法，Alice优先从像她传时速度最快的邻居（4个，每10s修改一次）那里获取文件块。</p><p>每过30s，Alice也要随机选择另外一个对等方Bob，向他发送块。若Alice是Bob最快的前四快，Bob也是Alice的前4快，则Bob和Alice互相发送数据。</p><p>每过30s换一个新的对象，互相交换数据（一报还一报），为了使对等方能够找到彼此协调的速率上传</p><h3 id="分布式散列表（DHT）"><a href="#分布式散列表（DHT）" class="headerlink" title="分布式散列表（DHT）"></a>分布式散列表（DHT）</h3><h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><h3 id="经HTTP的动态适应性流（Dynamic-Adaptive-Streaming-over-HTTP，DASH）"><a href="#经HTTP的动态适应性流（Dynamic-Adaptive-Streaming-over-HTTP，DASH）" class="headerlink" title="经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）"></a>经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）</h3><p>在DASH中视频编码为几个不同的版本，每个版本具有不同的比特率，对应于不同的质量水平。</p><h3 id="内容分发网（Content-Distribution-Network，CDN-）"><a href="#内容分发网（Content-Distribution-Network，CDN-）" class="headerlink" title="内容分发网（Content Distribution Network，CDN ）"></a>内容分发网（Content Distribution Network，CDN ）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;应用层协议原理&quot;&gt;&lt;a href=&quot;#应用层协议原理&quot; class=&quot;headerlink&quot; title=&quot;应用层协议原理&quot;&gt;&lt;/a&gt;应用层协议原理&lt;/h2&gt;&lt;h3 id=&quot;网络应用程序体系结构&quot;&gt;&lt;a href=&quot;#网络应用程序体系结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://leslieaibin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
